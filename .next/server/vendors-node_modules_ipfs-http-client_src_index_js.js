exports.id = "vendors-node_modules_ipfs-http-client_src_index_js";
exports.ids = ["vendors-node_modules_ipfs-http-client_src_index_js"];
exports.modules = {

/***/ "./node_modules/@libp2p/interface-peer-id/dist/src/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@libp2p/interface-peer-id/dist/src/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symbol": function() { return /* binding */ symbol; },
/* harmony export */   "isPeerId": function() { return /* binding */ isPeerId; }
/* harmony export */ });
const symbol = Symbol.for('@libp2p/peer-id');
function isPeerId(other) {
    return other != null && Boolean(other[symbol]);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@libp2p/logger/dist/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@libp2p/logger/dist/src/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logger": function() { return /* binding */ logger; },
/* harmony export */   "disable": function() { return /* binding */ disable; },
/* harmony export */   "enable": function() { return /* binding */ enable; },
/* harmony export */   "enabled": function() { return /* binding */ enabled; }
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "debug");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base32 */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base32.js");
/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/bases/base64 */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base64.js");




// Add a formatter for converting to a base58 string
debug__WEBPACK_IMPORTED_MODULE_0__.formatters.b = (v) => {
    return v == null ? 'undefined' : multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_1__.base58btc.baseEncode(v);
};
// Add a formatter for converting to a base32 string
debug__WEBPACK_IMPORTED_MODULE_0__.formatters.t = (v) => {
    return v == null ? 'undefined' : multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_2__.base32.baseEncode(v);
};
// Add a formatter for converting to a base64 string
debug__WEBPACK_IMPORTED_MODULE_0__.formatters.m = (v) => {
    return v == null ? 'undefined' : multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_3__.base64.baseEncode(v);
};
// Add a formatter for stringifying peer ids
debug__WEBPACK_IMPORTED_MODULE_0__.formatters.p = (v) => {
    return v == null ? 'undefined' : v.toString();
};
// Add a formatter for stringifying CIDs
debug__WEBPACK_IMPORTED_MODULE_0__.formatters.c = (v) => {
    return v == null ? 'undefined' : v.toString();
};
// Add a formatter for stringifying Datastore keys
debug__WEBPACK_IMPORTED_MODULE_0__.formatters.k = (v) => {
    return v == null ? 'undefined' : v.toString();
};
function logger(name) {
    return Object.assign(debug__WEBPACK_IMPORTED_MODULE_0__(name), {
        error: debug__WEBPACK_IMPORTED_MODULE_0__(`${name}:error`),
        trace: debug__WEBPACK_IMPORTED_MODULE_0__(`${name}:trace`)
    });
}
function disable() {
    debug__WEBPACK_IMPORTED_MODULE_0__.disable();
}
function enable(namespaces) {
    debug__WEBPACK_IMPORTED_MODULE_0__.enable(namespaces);
}
function enabled(namespaces) {
    return debug__WEBPACK_IMPORTED_MODULE_0__.enabled(namespaces);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "or": function() { return /* binding */ or; },
/* harmony export */   "Codec": function() { return /* binding */ Codec; },
/* harmony export */   "from": function() { return /* binding */ from; },
/* harmony export */   "baseX": function() { return /* binding */ baseX; },
/* harmony export */   "rfc4648": function() { return /* binding */ rfc4648; }
/* harmony export */ });
/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/base-x.js */ "./node_modules/@libp2p/logger/node_modules/multiformats/vendor/base-x.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interface.js */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/interface.js");


// Linter can't see that API is used in types.
// eslint-disable-next-line


/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.BaseEncoder}
 */
class Encoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor (name, prefix, baseEncode) {
    this.name = name
    this.prefix = prefix
    this.baseEncode = baseEncode
  }

  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode (bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`
    } else {
      throw Error('Unknown type, must be binary type')
    }
  }
}

/**
 * @template {string} Prefix
 */
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.UnibaseDecoder<Prefix>}
 * @implements {API.BaseDecoder}
 */
class Decoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseDecode) {
    this.name = name
    this.prefix = prefix
    /* c8 ignore next 3 */
    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character')
    }
    /** @private */
    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))
    this.baseDecode = baseDecode
  }

  /**
   * @param {string} text
   */
  decode (text) {
    if (typeof text === 'string') {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)
      }
      return this.baseDecode(text.slice(this.prefix.length))
    } else {
      throw Error('Can only multibase decode strings')
    }
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }
}

/**
 * @template {string} Prefix
 * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders
 */

/**
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.CombobaseDecoder<Prefix>}
 */
class ComposedDecoder {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor (decoders) {
    this.decoders = decoders
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }

  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode (input) {
    const prefix = /** @type {Prefix} */ (input[0])
    const decoder = this.decoders[prefix]
    if (decoder) {
      return decoder.decode(input)
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
  }
}

/**
 * @template {string} L
 * @template {string} R
 * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left
 * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right
 * @returns {ComposedDecoder<L|R>}
 */
const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({
  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),
  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })
}))

/**
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseCodec<Prefix>}
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.BaseCodec}
 * @implements {API.BaseEncoder}
 * @implements {API.BaseDecoder}
 */
class Codec {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseEncode, baseDecode) {
    this.name = name
    this.prefix = prefix
    this.baseEncode = baseEncode
    this.baseDecode = baseDecode
    this.encoder = new Encoder(name, prefix, baseEncode)
    this.decoder = new Decoder(name, prefix, baseDecode)
  }

  /**
   * @param {Uint8Array} input
   */
  encode (input) {
    return this.encoder.encode(input)
  }

  /**
   * @param {string} input
   */
  decode (input) {
    return this.decoder.decode(input)
  }
}

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {(bytes:Uint8Array) => string} options.encode
 * @param {(input:string) => Uint8Array} options.decode
 * @returns {Codec<Base, Prefix>}
 */
const from = ({ name, prefix, encode, decode }) =>
  new Codec(name, prefix, encode, decode)

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @returns {Codec<Base, Prefix>}
 */
const baseX = ({ prefix, name, alphabet }) => {
  const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__.default)(alphabet, name)
  return from({
    prefix,
    name,
    encode,
    /**
     * @param {string} text
     */
    decode: text => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.coerce)(decode(text))
  })
}

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @param {string} name
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar, name) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError(`Non-${name} character`)
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @param {number} options.bitsPerChar
 */
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
  return from({
    prefix,
    name,
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    decode (input) {
      return decode(input, alphabet, bitsPerChar, name)
    }
  })
}


/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base32.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base32.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base32": function() { return /* binding */ base32; },
/* harmony export */   "base32upper": function() { return /* binding */ base32upper; },
/* harmony export */   "base32pad": function() { return /* binding */ base32pad; },
/* harmony export */   "base32padupper": function() { return /* binding */ base32padupper; },
/* harmony export */   "base32hex": function() { return /* binding */ base32hex; },
/* harmony export */   "base32hexupper": function() { return /* binding */ base32hexupper; },
/* harmony export */   "base32hexpad": function() { return /* binding */ base32hexpad; },
/* harmony export */   "base32hexpadupper": function() { return /* binding */ base32hexpadupper; },
/* harmony export */   "base32z": function() { return /* binding */ base32z; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js");


const base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
})

const base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
})

const base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
})

const base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
})

const base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
})

const base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
})

const base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
})

const base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
})

const base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
})


/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base58.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base58.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base58btc": function() { return /* binding */ base58btc; },
/* harmony export */   "base58flickr": function() { return /* binding */ base58flickr; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js");


const base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
})

const base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
})


/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base64.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base64.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64": function() { return /* binding */ base64; },
/* harmony export */   "base64pad": function() { return /* binding */ base64pad; },
/* harmony export */   "base64url": function() { return /* binding */ base64url; },
/* harmony export */   "base64urlpad": function() { return /* binding */ base64urlpad; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
})

const base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
})

const base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
})

const base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
})


/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/interface.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/src/bases/interface.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/src/bytes.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/src/bytes.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "coerce": function() { return /* binding */ coerce; },
/* harmony export */   "isBinary": function() { return /* binding */ isBinary; },
/* harmony export */   "fromHex": function() { return /* binding */ fromHex; },
/* harmony export */   "toHex": function() { return /* binding */ toHex; },
/* harmony export */   "fromString": function() { return /* binding */ fromString; },
/* harmony export */   "toString": function() { return /* binding */ toString; },
/* harmony export */   "empty": function() { return /* binding */ empty; }
/* harmony export */ });
const empty = new Uint8Array(0)

/**
 * @param {Uint8Array} d
 */
const toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')

/**
 * @param {string} hex
 */
const fromHex = hex => {
  const hexes = hex.match(/../g)
  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty
}

/**
 * @param {Uint8Array} aa
 * @param {Uint8Array} bb
 */
const equals = (aa, bb) => {
  if (aa === bb) return true
  if (aa.byteLength !== bb.byteLength) {
    return false
  }

  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false
    }
  }

  return true
}

/**
 * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o
 * @returns {Uint8Array}
 */
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o
  if (o instanceof ArrayBuffer) return new Uint8Array(o)
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
  }
  throw new Error('Unknown type, must be binary type')
}

/**
 * @param {any} o
 * @returns {o is ArrayBuffer|ArrayBufferView}
 */
const isBinary = o =>
  o instanceof ArrayBuffer || ArrayBuffer.isView(o)

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
const fromString = str => (new TextEncoder()).encode(str)

/**
 * @param {Uint8Array} b
 * @returns {string}
 */
const toString = b => (new TextDecoder()).decode(b)




/***/ }),

/***/ "./node_modules/@libp2p/logger/node_modules/multiformats/vendor/base-x.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@libp2p/logger/node_modules/multiformats/vendor/base-x.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET, name) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    var b58 = new Uint8Array(size);
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0;
        // Skip leading spaces.
    if (source[psz] === ' ') { return }
        // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
      if (carry === 255) { return }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
        // Skip trailing spaces.
    if (source[psz] === ' ') { return }
        // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error(`Non-${name} character`)
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
var src = base;

var _brrp__multiformats_scope_baseX = src;

/* harmony default export */ __webpack_exports__["default"] = (_brrp__multiformats_scope_baseX);


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/dist/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/dist/src/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPeerId": function() { return /* binding */ createPeerId; },
/* harmony export */   "peerIdFromPeerId": function() { return /* binding */ peerIdFromPeerId; },
/* harmony export */   "peerIdFromString": function() { return /* binding */ peerIdFromString; },
/* harmony export */   "peerIdFromBytes": function() { return /* binding */ peerIdFromBytes; },
/* harmony export */   "peerIdFromCID": function() { return /* binding */ peerIdFromCID; },
/* harmony export */   "peerIdFromKeys": function() { return /* binding */ peerIdFromKeys; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js");
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/basics */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/digest */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js");
/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/hashes/identity */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js");
/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uint8arrays/equals */ "./node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/equals.js");
/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/hashes/sha2 */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2.js");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var _libp2p_interface_peer_id__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface-peer-id */ "./node_modules/@libp2p/interface-peer-id/dist/src/index.js");









const baseDecoder = Object
    .values(multiformats_basics__WEBPACK_IMPORTED_MODULE_1__.bases)
    .map(codec => codec.decoder)
    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141
    .reduce((acc, curr) => acc.or(curr), multiformats_basics__WEBPACK_IMPORTED_MODULE_1__.bases.identity.decoder);
// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv
const LIBP2P_KEY_CODE = 0x72;
const MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
const MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
class PeerIdImpl {
    constructor(init) {
        this.type = init.type;
        this.multihash = init.multihash;
        this.privateKey = init.privateKey;
        // mark string cache as non-enumerable
        Object.defineProperty(this, 'string', {
            enumerable: false,
            writable: true
        });
    }
    get [Symbol.toStringTag]() {
        return `PeerId(${this.toString()})`;
    }
    get [_libp2p_interface_peer_id__WEBPACK_IMPORTED_MODULE_8__.symbol]() {
        return true;
    }
    toString() {
        if (this.string == null) {
            this.string = multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__.base58btc.encode(this.multihash.bytes).slice(1);
        }
        return this.string;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
        return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toBytes() {
        return this.multihash.bytes;
    }
    /**
     * Returns Multiaddr as a JSON encoded object
     */
    toJSON() {
        return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */
    equals(id) {
        if (id instanceof Uint8Array) {
            return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(this.multihash.bytes, id);
        }
        else if (typeof id === 'string') {
            return peerIdFromString(id).equals(this);
        }
        else if (id?.multihash?.bytes != null) {
            return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(this.multihash.bytes, id.multihash.bytes);
        }
        else {
            throw new Error('not valid Id');
        }
    }
}
class RSAPeerIdImpl extends PeerIdImpl {
    constructor(init) {
        super({ ...init, type: 'RSA' });
        this.type = 'RSA';
        this.publicKey = init.publicKey;
    }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
    constructor(init) {
        super({ ...init, type: 'Ed25519' });
        this.type = 'Ed25519';
        this.publicKey = init.multihash.digest;
    }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
    constructor(init) {
        super({ ...init, type: 'secp256k1' });
        this.type = 'secp256k1';
        this.publicKey = init.multihash.digest;
    }
}
function createPeerId(init) {
    return new PeerIdImpl(init);
}
function peerIdFromPeerId(other) {
    if (other.type === 'RSA') {
        return new RSAPeerIdImpl(other);
    }
    if (other.type === 'Ed25519') {
        return new Ed25519PeerIdImpl(other);
    }
    if (other.type === 'secp256k1') {
        return new Secp256k1PeerIdImpl(other);
    }
    throw err_code__WEBPACK_IMPORTED_MODULE_7__(new Error('Not a PeerId'), 'ERR_INVALID_PARAMETERS');
}
function peerIdFromString(str, decoder) {
    decoder = decoder ?? baseDecoder;
    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {
        // identity hash ed25519/secp256k1 key or sha2-256 hash of
        // rsa public key - base58btc encoded either way
        const multihash = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.decode(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__.base58btc.decode(`z${str}`));
        if (str.startsWith('12D')) {
            return new Ed25519PeerIdImpl({ multihash });
        }
        else if (str.startsWith('16U')) {
            return new Secp256k1PeerIdImpl({ multihash });
        }
        else {
            return new RSAPeerIdImpl({ multihash });
        }
    }
    return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf) {
    try {
        const multihash = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.decode(buf);
        if (multihash.code === multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code) {
            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
                return new Ed25519PeerIdImpl({ multihash });
            }
            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
                return new Secp256k1PeerIdImpl({ multihash });
            }
        }
        if (multihash.code === multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256.code) {
            return new RSAPeerIdImpl({ multihash });
        }
    }
    catch {
        return peerIdFromCID(multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(buf));
    }
    throw new Error('Supplied PeerID CID is invalid');
}
function peerIdFromCID(cid) {
    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {
        throw new Error('Supplied PeerID CID is invalid');
    }
    const multihash = cid.multihash;
    if (multihash.code === multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256.code) {
        return new RSAPeerIdImpl({ multihash: cid.multihash });
    }
    else if (multihash.code === multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code) {
        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
            return new Ed25519PeerIdImpl({ multihash: cid.multihash });
        }
        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
        }
    }
    throw new Error('Supplied PeerID CID is invalid');
}
/**
 * @param publicKey - A marshalled public key
 * @param privateKey - A marshalled private key
 */
async function peerIdFromKeys(publicKey, privateKey) {
    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash: multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.create(multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code, publicKey), privateKey });
    }
    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash: multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.create(multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code, publicKey), privateKey });
    }
    return new RSAPeerIdImpl({ multihash: await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256.digest(publicKey), publicKey, privateKey });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "or": function() { return /* binding */ or; },
/* harmony export */   "Codec": function() { return /* binding */ Codec; },
/* harmony export */   "from": function() { return /* binding */ from; },
/* harmony export */   "baseX": function() { return /* binding */ baseX; },
/* harmony export */   "rfc4648": function() { return /* binding */ rfc4648; }
/* harmony export */ });
/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/base-x.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interface.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/interface.js");


// Linter can't see that API is used in types.
// eslint-disable-next-line


/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.BaseEncoder}
 */
class Encoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor (name, prefix, baseEncode) {
    this.name = name
    this.prefix = prefix
    this.baseEncode = baseEncode
  }

  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode (bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`
    } else {
      throw Error('Unknown type, must be binary type')
    }
  }
}

/**
 * @template {string} Prefix
 */
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.UnibaseDecoder<Prefix>}
 * @implements {API.BaseDecoder}
 */
class Decoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseDecode) {
    this.name = name
    this.prefix = prefix
    /* c8 ignore next 3 */
    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character')
    }
    /** @private */
    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))
    this.baseDecode = baseDecode
  }

  /**
   * @param {string} text
   */
  decode (text) {
    if (typeof text === 'string') {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)
      }
      return this.baseDecode(text.slice(this.prefix.length))
    } else {
      throw Error('Can only multibase decode strings')
    }
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }
}

/**
 * @template {string} Prefix
 * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders
 */

/**
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.CombobaseDecoder<Prefix>}
 */
class ComposedDecoder {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor (decoders) {
    this.decoders = decoders
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }

  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode (input) {
    const prefix = /** @type {Prefix} */ (input[0])
    const decoder = this.decoders[prefix]
    if (decoder) {
      return decoder.decode(input)
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
  }
}

/**
 * @template {string} L
 * @template {string} R
 * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left
 * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right
 * @returns {ComposedDecoder<L|R>}
 */
const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({
  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),
  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })
}))

/**
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseCodec<Prefix>}
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.BaseCodec}
 * @implements {API.BaseEncoder}
 * @implements {API.BaseDecoder}
 */
class Codec {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseEncode, baseDecode) {
    this.name = name
    this.prefix = prefix
    this.baseEncode = baseEncode
    this.baseDecode = baseDecode
    this.encoder = new Encoder(name, prefix, baseEncode)
    this.decoder = new Decoder(name, prefix, baseDecode)
  }

  /**
   * @param {Uint8Array} input
   */
  encode (input) {
    return this.encoder.encode(input)
  }

  /**
   * @param {string} input
   */
  decode (input) {
    return this.decoder.decode(input)
  }
}

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {(bytes:Uint8Array) => string} options.encode
 * @param {(input:string) => Uint8Array} options.decode
 * @returns {Codec<Base, Prefix>}
 */
const from = ({ name, prefix, encode, decode }) =>
  new Codec(name, prefix, encode, decode)

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @returns {Codec<Base, Prefix>}
 */
const baseX = ({ prefix, name, alphabet }) => {
  const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__.default)(alphabet, name)
  return from({
    prefix,
    name,
    encode,
    /**
     * @param {string} text
     */
    decode: text => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.coerce)(decode(text))
  })
}

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @param {string} name
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar, name) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError(`Non-${name} character`)
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @param {number} options.bitsPerChar
 */
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
  return from({
    prefix,
    name,
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    decode (input) {
      return decode(input, alphabet, bitsPerChar, name)
    }
  })
}


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base10": function() { return /* binding */ base10; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");


const base10 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: '9',
  name: 'base10',
  alphabet: '0123456789'
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base16": function() { return /* binding */ base16; },
/* harmony export */   "base16upper": function() { return /* binding */ base16upper; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'f',
  name: 'base16',
  alphabet: '0123456789abcdef',
  bitsPerChar: 4
})

const base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'F',
  name: 'base16upper',
  alphabet: '0123456789ABCDEF',
  bitsPerChar: 4
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base2": function() { return /* binding */ base2; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base2 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: '0',
  name: 'base2',
  alphabet: '01',
  bitsPerChar: 1
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base256emoji": function() { return /* binding */ base256emoji; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");


const alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')
const alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))
const alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function encode (data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c]
    return p
  }, '')
}

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
function decode (str) {
  const byts = []
  for (const char of str) {
    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]
    if (byt === undefined) {
      throw new Error(`Non-base256emoji character: ${char}`)
    }
    byts.push(byt)
  }
  return new Uint8Array(byts)
}

const base256emoji = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  prefix: '🚀',
  name: 'base256emoji',
  encode,
  decode
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base32": function() { return /* binding */ base32; },
/* harmony export */   "base32upper": function() { return /* binding */ base32upper; },
/* harmony export */   "base32pad": function() { return /* binding */ base32pad; },
/* harmony export */   "base32padupper": function() { return /* binding */ base32padupper; },
/* harmony export */   "base32hex": function() { return /* binding */ base32hex; },
/* harmony export */   "base32hexupper": function() { return /* binding */ base32hexupper; },
/* harmony export */   "base32hexpad": function() { return /* binding */ base32hexpad; },
/* harmony export */   "base32hexpadupper": function() { return /* binding */ base32hexpadupper; },
/* harmony export */   "base32z": function() { return /* binding */ base32z; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");


const base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
})

const base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
})

const base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
})

const base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
})

const base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
})

const base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
})

const base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
})

const base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
})

const base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base36": function() { return /* binding */ base36; },
/* harmony export */   "base36upper": function() { return /* binding */ base36upper; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");


const base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
})

const base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base58btc": function() { return /* binding */ base58btc; },
/* harmony export */   "base58flickr": function() { return /* binding */ base58flickr; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");


const base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
})

const base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64": function() { return /* binding */ base64; },
/* harmony export */   "base64pad": function() { return /* binding */ base64pad; },
/* harmony export */   "base64url": function() { return /* binding */ base64url; },
/* harmony export */   "base64urlpad": function() { return /* binding */ base64urlpad; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
})

const base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
})

const base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
})

const base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base8": function() { return /* binding */ base8; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base8 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: '7',
  name: 'base8',
  alphabet: '01234567',
  bitsPerChar: 3
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": function() { return /* binding */ identity; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
// @ts-check




const identity = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  prefix: '\x00',
  name: 'identity',
  encode: (buf) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.toString)(buf),
  decode: (str) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromString)(str)
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/interface.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/interface.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.CID; },
/* harmony export */   "hasher": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.hasher; },
/* harmony export */   "digest": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.digest; },
/* harmony export */   "varint": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.varint; },
/* harmony export */   "bytes": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.bytes; },
/* harmony export */   "hashes": function() { return /* binding */ hashes; },
/* harmony export */   "bases": function() { return /* binding */ bases; },
/* harmony export */   "codecs": function() { return /* binding */ codecs; }
/* harmony export */ });
/* harmony import */ var _bases_identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/identity.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js");
/* harmony import */ var _bases_base2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base2.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js");
/* harmony import */ var _bases_base8_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base8.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js");
/* harmony import */ var _bases_base10_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base10.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js");
/* harmony import */ var _bases_base16_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bases/base16.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js");
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js");
/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bases/base36.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var _bases_base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bases/base64.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js");
/* harmony import */ var _bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bases/base256emoji.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js");
/* harmony import */ var _hashes_sha2_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hashes/sha2.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2.js");
/* harmony import */ var _hashes_identity_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hashes/identity.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js");
/* harmony import */ var _codecs_raw_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./codecs/raw.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/raw.js");
/* harmony import */ var _codecs_json_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./codecs/json.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/index.js");
// @ts-check



















const bases = { ..._bases_identity_js__WEBPACK_IMPORTED_MODULE_0__, ..._bases_base2_js__WEBPACK_IMPORTED_MODULE_1__, ..._bases_base8_js__WEBPACK_IMPORTED_MODULE_2__, ..._bases_base10_js__WEBPACK_IMPORTED_MODULE_3__, ..._bases_base16_js__WEBPACK_IMPORTED_MODULE_4__, ..._bases_base32_js__WEBPACK_IMPORTED_MODULE_5__, ..._bases_base36_js__WEBPACK_IMPORTED_MODULE_6__, ..._bases_base58_js__WEBPACK_IMPORTED_MODULE_7__, ..._bases_base64_js__WEBPACK_IMPORTED_MODULE_8__, ..._bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_9__ }
const hashes = { ..._hashes_sha2_js__WEBPACK_IMPORTED_MODULE_10__, ..._hashes_identity_js__WEBPACK_IMPORTED_MODULE_11__ }
const codecs = { raw: _codecs_raw_js__WEBPACK_IMPORTED_MODULE_12__, json: _codecs_json_js__WEBPACK_IMPORTED_MODULE_13__ }




/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "coerce": function() { return /* binding */ coerce; },
/* harmony export */   "isBinary": function() { return /* binding */ isBinary; },
/* harmony export */   "fromHex": function() { return /* binding */ fromHex; },
/* harmony export */   "toHex": function() { return /* binding */ toHex; },
/* harmony export */   "fromString": function() { return /* binding */ fromString; },
/* harmony export */   "toString": function() { return /* binding */ toString; },
/* harmony export */   "empty": function() { return /* binding */ empty; }
/* harmony export */ });
const empty = new Uint8Array(0)

/**
 * @param {Uint8Array} d
 */
const toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')

/**
 * @param {string} hex
 */
const fromHex = hex => {
  const hexes = hex.match(/../g)
  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty
}

/**
 * @param {Uint8Array} aa
 * @param {Uint8Array} bb
 */
const equals = (aa, bb) => {
  if (aa === bb) return true
  if (aa.byteLength !== bb.byteLength) {
    return false
  }

  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false
    }
  }

  return true
}

/**
 * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o
 * @returns {Uint8Array}
 */
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o
  if (o instanceof ArrayBuffer) return new Uint8Array(o)
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
  }
  throw new Error('Unknown type, must be binary type')
}

/**
 * @param {any} o
 * @returns {o is ArrayBuffer|ArrayBufferView}
 */
const isBinary = o =>
  o instanceof ArrayBuffer || ArrayBuffer.isView(o)

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
const fromString = str => (new TextEncoder()).encode(str)

/**
 * @param {Uint8Array} b
 * @returns {string}
 */
const toString = b => (new TextDecoder()).decode(b)




/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": function() { return /* binding */ format; },
/* harmony export */   "CID": function() { return /* binding */ CID; }
/* harmony export */ });
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./varint.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./link/interface.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/link/interface.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _link_interface_js__WEBPACK_IMPORTED_MODULE_5__) if(["default","format","CID"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _link_interface_js__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);





// Linter can see that API is used in types.
// eslint-disable-next-line


// This way TS will also expose all the types from module


/**
 * @template {API.Link<unknown, number, number, API.Version>} T
 * @template {string} Prefix
 * @param {T} link
 * @param {API.MultibaseEncoder<Prefix>} [base]
 * @returns {API.ToString<T, Prefix>}
 */
const format = (link, base) => {
  const { bytes, version } = link
  switch (version) {
    case 0:
      return toStringV0(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */ (base) || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.encoder
      )
    default:
      return toStringV1(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */ (base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.encoder)
      )
  }
}

/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */
const cache = new WeakMap()

/**
 * @param {API.UnknownLink} cid
 * @returns {Map<string, string>}
 */
const baseCache = cid => {
  const baseCache = cache.get(cid)
  if (baseCache == null) {
    const baseCache = new Map()
    cache.set(cid, baseCache)
    return baseCache
  }
  return baseCache
}

/**
 * @template {unknown} [Data=unknown]
 * @template {number} [Format=number]
 * @template {number} [Alg=number]
 * @template {API.Version} [Version=API.Version]
 * @implements {API.Link<Data, Format, Alg, Version>}
 */

class CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor (version, code, multihash, bytes) {
    /** @readonly */
    this.code = code
    /** @readonly */
    this.version = version
    /** @readonly */
    this.multihash = multihash
    /** @readonly */
    this.bytes = bytes

    // ArrayBufferView
    /** @readonly */
    this.byteOffset = bytes.byteOffset
    /** @readonly */
    this.byteLength = bytes.byteLength

    // Circular reference
    /** @readonly */
    this.asCID = this
  }

  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0 () {
    switch (this.version) {
      case 0: {
        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)
      }
      case 1: {
        const { code, multihash } = this

        if (code !== DAG_PB_CODE) {
          throw new Error('Cannot convert a non dag-pb CID to CIDv0')
        }

        // sha2-256
        if (multihash.code !== SHA_256_CODE) {
          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
        }

        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (
          CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)
          )
        )
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        )
      }
    }
  }

  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1 () {
    switch (this.version) {
      case 0: {
        const { code, digest } = this.multihash
        const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, digest)
        return /** @type {CID<Data, Format, Alg, 1>} */ (
          CID.createV1(this.code, multihash)
        )
      }
      case 1: {
        return /** @type {CID<Data, Format, Alg, 1>} */ (this)
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        )
      }
    }
  }

  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals (other) {
    return CID.equals(this, other)
  }

  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals (self, other) {
    const unknown =
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (
        other
      )
    return (
      unknown &&
      self.code === unknown.code &&
      self.version === unknown.version &&
      _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.equals(self.multihash, unknown.multihash)
    )
  }

  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString (base) {
    return format(this, base)
  }

  toJSON () {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    }
  }

  link () {
    return this
  }

  get [Symbol.toStringTag] () {
    return 'CID'
  }

  // Legacy

  [Symbol.for('nodejs.util.inspect.custom')] () {
    return `CID(${this.toString()})`
  }

  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returs null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID (input) {
    const value = /** @type {any} */ (input)
    if (value instanceof CID) {
      // If value is instance of CID then we're all set.
      return value
    } else if (value != null && value.asCID === value) {
      // If value isn't instance of this CID class but `this.asCID === this` is
      // true it is CID instance coming from a different implementation (diff
      // version or duplicate). In that case we rebase it to this `CID`
      // implementation so caller is guaranteed to get instance with expected
      // API.
      const { version, code, multihash, bytes } = value
      return new CID(
        version,
        code,
        /** @type {API.MultihashDigest<Alg>} */ (multihash),
        bytes || encodeCID(version, code, multihash.bytes)
      )
    } else if (value != null && value[cidSymbol] === true) {
      // If value is a CID from older implementation that used to be tagged via
      // symbol we still rebase it to the this `CID` implementation by
      // delegating that to a constructor.
      const { version, multihash, code } = value
      const digest =
        /** @type {API.MultihashDigest<Alg>} */
        (_hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.decode(multihash))
      return CID.create(version, code, digest)
    } else {
      // Otherwise value is not a CID (or an incompatible version of it) in
      // which case we return `null`.
      return null
    }
  }

  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create (version, code, digest) {
    if (typeof code !== 'number') {
      throw new Error('String codecs are no longer supported')
    }

    switch (version) {
      case 0: {
        if (code !== DAG_PB_CODE) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          )
        } else {
          return new CID(version, code, digest, digest.bytes)
        }
      }
      case 1: {
        const bytes = encodeCID(version, code, digest.bytes)
        return new CID(version, code, digest, bytes)
      }
      default: {
        throw new Error('Invalid version')
      }
    }
  }

  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0 (digest) {
    return CID.create(0, DAG_PB_CODE, digest)
  }

  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1 (code, digest) {
    return CID.create(1, code, digest)
  }

  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode (bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes)
    if (remainder.length) {
      throw new Error('Incorrect length')
    }
    return cid
  }

  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst (bytes) {
    const specs = CID.inspectBytes(bytes)
    const prefixSize = specs.size - specs.multihashSize
    const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_4__.coerce)(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    )
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error('Incorrect length')
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    )
    const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.Digest(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    )
    const cid =
      specs.version === 0
        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))
        : CID.createV1(specs.codec, digest)
    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]
  }

  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes (initialBytes) {
    let offset = 0
    const next = () => {
      const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_0__.decode(initialBytes.subarray(offset))
      offset += length
      return i
    }

    let version = /** @type {V} */ (next())
    let codec = /** @type {C} */ (DAG_PB_CODE)
    if (/** @type {number} */(version) === 18) {
      // CIDv0
      version = /** @type {V} */ (0)
      offset = 0
    } else {
      codec = /** @type {C} */ (next())
    }

    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`)
    }

    const prefixSize = offset
    const multihashCode = /** @type {A} */ (next()) // multihash code
    const digestSize = next() // multihash length
    const size = offset + digestSize
    const multihashSize = size - prefixSize

    return { version, codec, multihashCode, digestSize, multihashSize, size }
  }

  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse (source, base) {
    const [prefix, bytes] = parseCIDtoBytes(source, base)

    const cid = CID.decode(bytes)

    // Cache string representation to avoid computing it on `this.toString()`
    baseCache(cid).set(prefix, source)

    return cid
  }
}

/**
 * @template {string} Prefix
 * @template {unknown} Data
 * @template {number} Code
 * @template {number} Alg
 * @template {API.Version} Ver
 * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
 * @param {API.MultibaseDecoder<Prefix>} [base]
 * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}
 */
const parseCIDtoBytes = (source, base) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case 'Q': {
      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc
      return [
        /** @type {Prefix} */ (_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix),
        decoder.decode(`${_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix}${source}`)
      ]
    }
    case _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix: {
      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc
      return [/** @type {Prefix} */(_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix), decoder.decode(source)]
    }
    case _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix: {
      const decoder = base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32
      return [/** @type {Prefix} */(_bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix), decoder.decode(source)]
    }
    default: {
      if (base == null) {
        throw Error(
          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'
        )
      }
      return [/** @type {Prefix} */(source[0]), base.decode(source)]
    }
  }
}

/**
 *
 * @param {Uint8Array} bytes
 * @param {Map<string, string>} cache
 * @param {API.MultibaseEncoder<'z'>} base
 */
const toStringV0 = (bytes, cache, base) => {
  const { prefix } = base
  if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base.name} encoding`)
  }

  const cid = cache.get(prefix)
  if (cid == null) {
    const cid = base.encode(bytes).slice(1)
    cache.set(prefix, cid)
    return cid
  } else {
    return cid
  }
}

/**
 * @template {string} Prefix
 * @param {Uint8Array} bytes
 * @param {Map<string, string>} cache
 * @param {API.MultibaseEncoder<Prefix>} base
 */
const toStringV1 = (bytes, cache, base) => {
  const { prefix } = base
  const cid = cache.get(prefix)
  if (cid == null) {
    const cid = base.encode(bytes)
    cache.set(prefix, cid)
    return cid
  } else {
    return cid
  }
}

const DAG_PB_CODE = 0x70
const SHA_256_CODE = 0x12

/**
 * @param {API.Version} version
 * @param {number} code
 * @param {Uint8Array} multihash
 * @returns {Uint8Array}
 */
const encodeCID = (version, code, multihash) => {
  const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(version)
  const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code)
  const bytes = new Uint8Array(hashOffset + multihash.byteLength)
  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(version, bytes, 0)
  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(code, bytes, codeOffset)
  bytes.set(multihash, hashOffset)
  return bytes
}

const cidSymbol = Symbol.for('@ipld/js-cid/CID')


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": function() { return /* binding */ name; },
/* harmony export */   "code": function() { return /* binding */ code; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
// @ts-check

/**
 * @template T
 * @typedef {import('./interface.js').ByteView<T>} ByteView
 */

const textEncoder = new TextEncoder()
const textDecoder = new TextDecoder()

const name = 'json'
const code = 0x0200

/**
 * @template T
 * @param {T} node
 * @returns {ByteView<T>}
 */
const encode = (node) => textEncoder.encode(JSON.stringify(node))

/**
 * @template T
 * @param {ByteView<T>} data
 * @returns {T}
 */
const decode = (data) => JSON.parse(textDecoder.decode(data))


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/raw.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/raw.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": function() { return /* binding */ name; },
/* harmony export */   "code": function() { return /* binding */ code; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
// @ts-check



/**
 * @template T
 * @typedef {import('./interface.js').ByteView<T>} ByteView
 */

const name = 'raw'
const code = 0x55

/**
 * @param {Uint8Array} node
 * @returns {ByteView<Uint8Array>}
 */
const encode = (node) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(node)

/**
 * @param {ByteView<Uint8Array>} data
 * @returns {Uint8Array}
 */
const decode = (data) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(data)


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": function() { return /* binding */ create; },
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "Digest": function() { return /* binding */ Digest; }
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js");



/**
 * Creates a multihash digest.
 *
 * @template {number} Code
 * @param {Code} code
 * @param {Uint8Array} digest
 */
const create = (code, digest) => {
  const size = digest.byteLength
  const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code)
  const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size)

  const bytes = new Uint8Array(digestOffset + size)
  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0)
  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset)
  bytes.set(digest, digestOffset)

  return new Digest(code, size, digest, bytes)
}

/**
 * Turns bytes representation of multihash digest into an instance.
 *
 * @param {Uint8Array} multihash
 * @returns {MultihashDigest}
 */
const decode = (multihash) => {
  const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash)
  const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes)
  const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset))
  const digest = bytes.subarray(sizeOffset + digestOffset)

  if (digest.byteLength !== size) {
    throw new Error('Incorrect length')
  }

  return new Digest(code, size, digest, bytes)
}

/**
 * @param {MultihashDigest} a
 * @param {unknown} b
 * @returns {b is MultihashDigest}
 */
const equals = (a, b) => {
  if (a === b) {
    return true
  } else {
    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)

    return (
      a.code === data.code &&
      a.size === data.size &&
      data.bytes instanceof Uint8Array &&
      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, data.bytes)
    )
  }
}

/**
 * @typedef {import('./interface.js').MultihashDigest} MultihashDigest
 */

/**
 * Represents a multihash digest which carries information about the
 * hashing alogrithm and an actual hash digest.
 *
 * @template {number} Code
 * @template {number} Size
 * @class
 * @implements {MultihashDigest}
 */
class Digest {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor (code, size, digest, bytes) {
    this.code = code
    this.size = size
    this.digest = digest
    this.bytes = bytes
  }
}


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "from": function() { return /* binding */ from; },
/* harmony export */   "Hasher": function() { return /* binding */ Hasher; }
/* harmony export */ });
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js");


/**
 * @template {string} Name
 * @template {number} Code
 * @param {object} options
 * @param {Name} options.name
 * @param {Code} options.code
 * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode
 */
const from = ({ name, code, encode }) => new Hasher(name, code, encode)

/**
 * Hasher represents a hashing algorithm implementation that produces as
 * `MultihashDigest`.
 *
 * @template {string} Name
 * @template {number} Code
 * @class
 * @implements {MultihashHasher<Code>}
 */
class Hasher {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor (name, code, encode) {
    this.name = name
    this.code = code
    this.encode = encode
  }

  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest (input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input)
      return result instanceof Uint8Array
        ? _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, result)
        /* c8 ignore next 1 */
        : result.then(digest => _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest))
    } else {
      throw Error('Unknown type, must be binary type')
      /* c8 ignore next 1 */
    }
  }
}

/**
 * @template {number} Alg
 * @typedef {import('./interface.js').MultihashHasher} MultihashHasher
 */

/**
 * @template T
 * @typedef {Promise<T>|T} Await
 */


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": function() { return /* binding */ identity; }
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./digest.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js");



const code = 0x0
const name = 'identity'

/** @type {(input:Uint8Array) => Uint8Array} */
const encode = _bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce

/**
 * @param {Uint8Array} input
 * @returns {Digest.Digest<typeof code, number>}
 */
const digest = (input) => _digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, encode(input))

const identity = { code, name, encode, digest }


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sha256": function() { return /* binding */ sha256; },
/* harmony export */   "sha512": function() { return /* binding */ sha512; }
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hasher.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
// @ts-check





const sha256 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_1__.from)({
  name: 'sha2-256',
  code: 0x12,
  encode: (input) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha256').update(input).digest())
})

const sha512 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_1__.from)({
  name: 'sha2-512',
  code: 0x13,
  encode: input => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha512').update(input).digest())
})


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": function() { return /* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_0__.CID; },
/* harmony export */   "hasher": function() { return /* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__; },
/* harmony export */   "digest": function() { return /* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__; },
/* harmony export */   "varint": function() { return /* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_1__; },
/* harmony export */   "bytes": function() { return /* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_2__; }
/* harmony export */ });
/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cid.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./varint.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interface.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/interface.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _interface_js__WEBPACK_IMPORTED_MODULE_5__) if(["default","CID","hasher","digest","varint","bytes"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _interface_js__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);





// This way TS will also expose all the types from module





/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/interface.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/interface.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/link/interface.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/link/interface.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "encodeTo": function() { return /* binding */ encodeTo; },
/* harmony export */   "encodingLength": function() { return /* binding */ encodingLength; }
/* harmony export */ });
/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/varint.js */ "./node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js");


/**
 * @param {Uint8Array} data
 * @param {number} [offset=0]
 * @returns {[number, number]}
 */
const decode = (data, offset = 0) => {
  const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.decode(data, offset)
  return [code, _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.decode.bytes]
}

/**
 * @param {number} int
 * @param {Uint8Array} target
 * @param {number} [offset=0]
 */
const encodeTo = (int, target, offset = 0) => {
  _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.encode(int, target, offset)
  return target
}

/**
 * @param {number} int
 * @returns {number}
 */
const encodingLength = (int) => {
  return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.encodingLength(int)
}


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET, name) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    var b58 = new Uint8Array(size);
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0;
        // Skip leading spaces.
    if (source[psz] === ' ') { return }
        // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
      if (carry === 255) { return }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
        // Skip trailing spaces.
    if (source[psz] === ' ') { return }
        // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error(`Non-${name} character`)
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
var src = base;

var _brrp__multiformats_scope_baseX = src;

/* harmony default export */ __webpack_exports__["default"] = (_brrp__multiformats_scope_baseX);


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var encode_1 = encode;

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31);

function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB;
    num /= 128;
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  
  encode.bytes = offset - oldOffset + 1;
  
  return out
}

var decode = read;

var MSB$1 = 0x80
  , REST$1 = 0x7F;

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++];
    res += shift < 28
      ? (b & REST$1) << shift
      : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1)

  read.bytes = counter - offset;

  return res
}

var N1 = Math.pow(2,  7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

var length = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
};

var varint = {
    encode: encode_1
  , decode: decode
  , encodingLength: length
};

var _brrp_varint = varint;

/* harmony default export */ __webpack_exports__["default"] = (_brrp_varint);


/***/ }),

/***/ "./node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/equals.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/equals.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": function() { return /* binding */ equals; }
/* harmony export */ });
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multiaddrToUri": function() { return /* binding */ multiaddrToUri; }
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");

const reduceValue = (_, v) => v;
const tcpUri = (str, port, parts, opts) => {
    // return tcp when explicitly requested
    if ((opts != null) && opts.assumeHttp === false)
        return `tcp://${str}:${port}`;
    // check if tcp is the last protocol in multiaddr
    let protocol = 'tcp';
    let explicitPort = `:${port}`;
    const last = parts[parts.length - 1];
    if (last.protocol === 'tcp') {
        // assume http and produce clean urls
        protocol = port === '443' ? 'https' : 'http';
        explicitPort = port === '443' || port === '80' ? '' : explicitPort;
    }
    return `${protocol}://${str}${explicitPort}`;
};
const Reducers = {
    ip4: reduceValue,
    ip6: (str, content, i, parts) => (parts.length === 1 && parts[0].protocol === 'ip6'
        ? content
        : `[${content}]`),
    tcp: (str, content, i, parts, opts) => (parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))
        ? `${str}:${content}`
        : tcpUri(str, content, parts, opts)),
    udp: (str, content) => `udp://${str}:${content}`,
    dnsaddr: reduceValue,
    dns4: reduceValue,
    dns6: reduceValue,
    ipfs: (str, content) => `${str}/ipfs/${content}`,
    p2p: (str, content) => `${str}/p2p/${content}`,
    http: str => `http://${str}`,
    https: str => `https://${str}`,
    ws: str => `ws://${str}`,
    wss: str => `wss://${str}`,
    'p2p-websocket-star': str => `${str}/p2p-websocket-star`,
    'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,
    'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`
};
function multiaddrToUri(input, opts) {
    const ma = (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(input);
    const parts = ma.toString().split('/').slice(1);
    return ma
        .tuples()
        .map(tuple => ({
        protocol: parts.shift() ?? '',
        content: (tuple[1] != null) ? parts.shift() ?? '' : ''
    }))
        .reduce((str, part, i, parts) => {
        const reduce = Reducers[part.protocol];
        if (reduce == null) {
            throw new Error(`Unsupported protocol ${part.protocol}`);
        }
        return reduce(str, part.content, i, parts, opts);
    }, '');
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/codec.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/codec.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stringToStringTuples": function() { return /* binding */ stringToStringTuples; },
/* harmony export */   "stringTuplesToString": function() { return /* binding */ stringTuplesToString; },
/* harmony export */   "stringTuplesToTuples": function() { return /* binding */ stringTuplesToTuples; },
/* harmony export */   "tuplesToStringTuples": function() { return /* binding */ tuplesToStringTuples; },
/* harmony export */   "tuplesToBytes": function() { return /* binding */ tuplesToBytes; },
/* harmony export */   "sizeForAddr": function() { return /* binding */ sizeForAddr; },
/* harmony export */   "bytesToTuples": function() { return /* binding */ bytesToTuples; },
/* harmony export */   "bytesToString": function() { return /* binding */ bytesToString; },
/* harmony export */   "stringToBytes": function() { return /* binding */ stringToBytes; },
/* harmony export */   "fromString": function() { return /* binding */ fromString; },
/* harmony export */   "fromBytes": function() { return /* binding */ fromBytes; },
/* harmony export */   "validateBytes": function() { return /* binding */ validateBytes; },
/* harmony export */   "isValidBytes": function() { return /* binding */ isValidBytes; },
/* harmony export */   "cleanPath": function() { return /* binding */ cleanPath; },
/* harmony export */   "ParseError": function() { return /* binding */ ParseError; },
/* harmony export */   "protoFromTuple": function() { return /* binding */ protoFromTuple; }
/* harmony export */ });
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert.js */ "./node_modules/@multiformats/multiaddr/dist/src/convert.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");
/* harmony import */ var varint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! varint */ "./node_modules/@multiformats/multiaddr/node_modules/varint/index.js");
/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");





/**
 * string -> [[str name, str addr]... ]
 */
function stringToStringTuples(str) {
    const tuples = [];
    const parts = str.split('/').slice(1); // skip first empty elem
    if (parts.length === 1 && parts[0] === '') {
        return [];
    }
    for (let p = 0; p < parts.length; p++) {
        const part = parts[p];
        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(part);
        if (proto.size === 0) {
            tuples.push([part]);
            continue;
        }
        p++; // advance addr part
        if (p >= parts.length) {
            throw ParseError('invalid address: ' + str);
        }
        // if it's a path proto, take the rest
        if (proto.path === true) {
            tuples.push([
                part,
                // TODO: should we need to check each path part to see if it's a proto?
                // This would allow for other protocols to be added after a unix path,
                // however it would have issues if the path had a protocol name in the path
                cleanPath(parts.slice(p).join('/'))
            ]);
            break;
        }
        tuples.push([part, parts[p]]);
    }
    return tuples;
}
/**
 * [[str name, str addr]... ] -> string
 */
function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        parts.push(proto.name);
        if (tup.length > 1 && tup[1] != null) {
            parts.push(tup[1]);
        }
        return null;
    });
    return cleanPath(parts.join('/'));
}
/**
 * [[str name, str addr]... ] -> [[int code, Uint8Array]... ]
 */
function stringTuplesToTuples(tuples) {
    return tuples.map((tup) => {
        if (!Array.isArray(tup)) {
            tup = [tup];
        }
        const proto = protoFromTuple(tup);
        if (tup.length > 1) {
            return [proto.code, (0,_convert_js__WEBPACK_IMPORTED_MODULE_0__.convertToBytes)(proto.code, tup[1])];
        }
        return [proto.code];
    });
}
/**
 * Convert tuples to string tuples
 *
 * [[int code, Uint8Array]... ] -> [[int code, str addr]... ]
 */
function tuplesToStringTuples(tuples) {
    return tuples.map(tup => {
        const proto = protoFromTuple(tup);
        if (tup[1] != null) {
            return [proto.code, (0,_convert_js__WEBPACK_IMPORTED_MODULE_0__.convertToString)(proto.code, tup[1])];
        }
        return [proto.code];
    });
}
/**
 * [[int code, Uint8Array ]... ] -> Uint8Array
 */
function tuplesToBytes(tuples) {
    return fromBytes((0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_3__.concat)(tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        let buf = Uint8Array.from(varint__WEBPACK_IMPORTED_MODULE_2__.encode(proto.code));
        if (tup.length > 1 && tup[1] != null) {
            buf = (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_3__.concat)([buf, tup[1]]); // add address buffer
        }
        return buf;
    })));
}
function sizeForAddr(p, addr) {
    if (p.size > 0) {
        return p.size / 8;
    }
    else if (p.size === 0) {
        return 0;
    }
    else {
        const size = varint__WEBPACK_IMPORTED_MODULE_2__.decode(addr);
        return size + varint__WEBPACK_IMPORTED_MODULE_2__.decode.bytes;
    }
}
function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while (i < buf.length) {
        const code = varint__WEBPACK_IMPORTED_MODULE_2__.decode(buf, i);
        const n = varint__WEBPACK_IMPORTED_MODULE_2__.decode.bytes;
        const p = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(code);
        const size = sizeForAddr(p, buf.slice(i + n));
        if (size === 0) {
            tuples.push([code]);
            i += n;
            continue;
        }
        const addr = buf.slice(i + n, i + n + size);
        i += (size + n);
        if (i > buf.length) { // did not end _exactly_ at buffer.length
            throw ParseError('Invalid address Uint8Array: ' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_4__.toString)(buf, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([code, addr]);
    }
    return tuples;
}
/**
 * Uint8Array -> String
 */
function bytesToString(buf) {
    const a = bytesToTuples(buf);
    const b = tuplesToStringTuples(a);
    return stringTuplesToString(b);
}
/**
 * String -> Uint8Array
 */
function stringToBytes(str) {
    str = cleanPath(str);
    const a = stringToStringTuples(str);
    const b = stringTuplesToTuples(a);
    return tuplesToBytes(b);
}
/**
 * String -> Uint8Array
 */
function fromString(str) {
    return stringToBytes(str);
}
/**
 * Uint8Array -> Uint8Array
 */
function fromBytes(buf) {
    const err = validateBytes(buf);
    if (err != null) {
        throw err;
    }
    return Uint8Array.from(buf); // copy
}
function validateBytes(buf) {
    try {
        bytesToTuples(buf); // try to parse. will throw if breaks
    }
    catch (err) {
        return err;
    }
}
function isValidBytes(buf) {
    return validateBytes(buf) === undefined;
}
function cleanPath(str) {
    return '/' + str.trim().split('/').filter((a) => a).join('/');
}
function ParseError(str) {
    return new Error('Error parsing address: ' + str);
}
function protoFromTuple(tup) {
    const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(tup[0]);
    return proto;
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/convert.js":
/*!******************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/convert.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convert": function() { return /* binding */ convert; },
/* harmony export */   "convertToString": function() { return /* binding */ convertToString; },
/* harmony export */   "convertToBytes": function() { return /* binding */ convertToBytes; }
/* harmony export */ });
/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ip.js */ "./node_modules/@multiformats/multiaddr/dist/src/ip.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/cid */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js");
/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/bases/base32 */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/basics */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/basics.js");
/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/hashes/digest */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js");
/* harmony import */ var varint__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! varint */ "./node_modules/@multiformats/multiaddr/node_modules/varint/index.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uint8arrays/from-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js");
/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js");











/**
 * converts (serializes) addresses
 */
function convert(proto, a) {
    if (a instanceof Uint8Array) {
        return convertToString(proto, a);
    }
    else {
        return convertToBytes(proto, a);
    }
}
/**
 * Convert [code,Uint8Array] to string
 */
function convertToString(proto, buf) {
    const protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(proto);
    switch (protocol.code) {
        case 4: // ipv4
        case 41: // ipv6
            return bytes2ip(buf);
        case 6: // tcp
        case 273: // udp
        case 33: // dccp
        case 132: // sctp
            return bytes2port(buf).toString();
        case 53: // dns
        case 54: // dns4
        case 55: // dns6
        case 56: // dnsaddr
        case 400: // unix
        case 777: // memory
            return bytes2str(buf);
        case 421: // ipfs
            return bytes2mh(buf);
        case 444: // onion
            return bytes2onion(buf);
        case 445: // onion3
            return bytes2onion(buf);
        case 466: // certhash
            return bytes2mb(buf);
        default:
            return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_8__.toString)(buf, 'base16'); // no clue. convert to hex
    }
}
function convertToBytes(proto, str) {
    const protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(proto);
    switch (protocol.code) {
        case 4: // ipv4
            return ip2bytes(str);
        case 41: // ipv6
            return ip2bytes(str);
        case 6: // tcp
        case 273: // udp
        case 33: // dccp
        case 132: // sctp
            return port2bytes(parseInt(str, 10));
        case 53: // dns
        case 54: // dns4
        case 55: // dns6
        case 56: // dnsaddr
        case 400: // unix
        case 777: // memory
            return str2bytes(str);
        case 421: // ipfs
            return mh2bytes(str);
        case 444: // onion
            return onion2bytes(str);
        case 445: // onion3
            return onion32bytes(str);
        case 466: // certhash
            return mb2bytes(str);
        default:
            return (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_9__.fromString)(str, 'base16'); // no clue. convert from hex
    }
}
const decoders = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_5__.bases).map((c) => c.decoder);
const anybaseDecoder = (function () {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d) => (acc = acc.or(d)));
    return acc;
})();
function ip2bytes(ipString) {
    if (!_ip_js__WEBPACK_IMPORTED_MODULE_0__.isIP(ipString)) {
        throw new Error('invalid ip address');
    }
    return _ip_js__WEBPACK_IMPORTED_MODULE_0__.toBytes(ipString);
}
function bytes2ip(ipBuff) {
    const ipString = _ip_js__WEBPACK_IMPORTED_MODULE_0__.toString(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
        throw new Error('ipBuff is required');
    }
    if (!_ip_js__WEBPACK_IMPORTED_MODULE_0__.isIP(ipString)) {
        throw new Error('invalid ip address');
    }
    return ipString;
}
function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
}
function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
    const buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_9__.fromString)(str);
    const size = Uint8Array.from(varint__WEBPACK_IMPORTED_MODULE_7__.encode(buf.length));
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_10__.concat)([size, buf], size.length + buf.length);
}
function bytes2str(buf) {
    const size = varint__WEBPACK_IMPORTED_MODULE_7__.decode(buf);
    buf = buf.slice(varint__WEBPACK_IMPORTED_MODULE_7__.decode.bytes);
    if (buf.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_8__.toString)(buf);
}
function mh2bytes(hash) {
    let mh;
    if (hash[0] === 'Q' || hash[0] === '1') {
        mh = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_6__.decode(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_4__.base58btc.decode(`z${hash}`)).bytes;
    }
    else {
        mh = multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.parse(hash).multihash.bytes;
    }
    // the address is a varint prefixed multihash string representation
    const size = Uint8Array.from(varint__WEBPACK_IMPORTED_MODULE_7__.encode(mh.length));
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_10__.concat)([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(varint__WEBPACK_IMPORTED_MODULE_7__.encode(mb.length));
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_10__.concat)([size, mb], size.length + mb.length);
}
function bytes2mb(buf) {
    const size = varint__WEBPACK_IMPORTED_MODULE_7__.decode(buf);
    const hash = buf.slice(varint__WEBPACK_IMPORTED_MODULE_7__.decode.bytes);
    if (hash.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return 'u' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_8__.toString)(hash, 'base64url');
}
/**
 * Converts bytes to bas58btc string
 */
function bytes2mh(buf) {
    const size = varint__WEBPACK_IMPORTED_MODULE_7__.decode(buf);
    const address = buf.slice(varint__WEBPACK_IMPORTED_MODULE_7__.decode.bytes);
    if (address.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_8__.toString)(address, 'base58btc');
}
function onion2bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_3__.base32.decode('b' + addr[0]);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_10__.concat)([buf, portBuf], buf.length + portBuf.length);
}
function onion32bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_3__.base32.decode(`b${addr[0]}`);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_10__.concat)([buf, portBuf], buf.length + portBuf.length);
}
function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_8__.toString)(addrBytes, 'base32');
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
}
//# sourceMappingURL=convert.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolvers": function() { return /* binding */ resolvers; },
/* harmony export */   "fromNodeAddress": function() { return /* binding */ fromNodeAddress; },
/* harmony export */   "isName": function() { return /* binding */ isName; },
/* harmony export */   "isMultiaddr": function() { return /* binding */ isMultiaddr; },
/* harmony export */   "multiaddr": function() { return /* binding */ multiaddr; },
/* harmony export */   "protocols": function() { return /* reexport safe */ _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol; }
/* harmony export */ });
/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codec.js */ "./node_modules/@multiformats/multiaddr/dist/src/codec.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");
/* harmony import */ var varint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! varint */ "./node_modules/@multiformats/multiaddr/node_modules/varint/index.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/cid */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");
/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uint8arrays/equals */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js");
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a;








const inspect = Symbol.for('nodejs.util.inspect.custom');
const DNS_CODES = [
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('dns').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('dns4').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('dns6').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('dnsaddr').code
];
const P2P_CODES = [
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('p2p').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('ipfs').code
];
const resolvers = new Map();
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');
/**
 * Creates a Multiaddr from a node-friendly address object
 *
 * @example
 * ```js
 * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 * ```
 */
function fromNodeAddress(addr, transport) {
    if (addr == null) {
        throw new Error('requires node address object');
    }
    if (transport == null) {
        throw new Error('requires transport protocol');
    }
    let ip;
    switch (addr.family) {
        case 4:
            ip = 'ip4';
            break;
        case 6:
            ip = 'ip6';
            break;
        default:
            throw Error('Invalid addr family, should be 4 or 6.');
    }
    return new DefaultMultiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));
}
/**
 * Returns if something is a Multiaddr that is a name
 */
function isName(addr) {
    if (!isMultiaddr(addr)) {
        return false;
    }
    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto) => proto.resolvable);
}
/**
 * Check if object is a CID instance
 */
function isMultiaddr(value) {
    return Boolean(value?.[symbol]);
}
/**
 * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from
 * a Uint8Array, String or another Multiaddr instance
 * public key.
 *
 */
class DefaultMultiaddr {
    /**
     * @example
     * ```js
     * new Multiaddr('/ip4/127.0.0.1/tcp/4001')
     * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
     * ```
     *
     * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
     */
    constructor(addr) {
        _DefaultMultiaddr_string.set(this, void 0);
        _DefaultMultiaddr_tuples.set(this, void 0);
        _DefaultMultiaddr_stringTuples.set(this, void 0);
        this[_a] = true;
        // default
        if (addr == null) {
            addr = '';
        }
        if (addr instanceof Uint8Array) {
            this.bytes = _codec_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(addr);
        }
        else if (typeof addr === 'string') {
            if (addr.length > 0 && addr.charAt(0) !== '/') {
                throw new Error(`multiaddr "${addr}" must start with a "/"`);
            }
            this.bytes = _codec_js__WEBPACK_IMPORTED_MODULE_0__.fromString(addr);
        }
        else if (isMultiaddr(addr)) { // Multiaddr
            this.bytes = _codec_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(addr.bytes); // validate + copy buffer
        }
        else {
            throw new Error('addr must be a string, Buffer, or another Multiaddr');
        }
    }
    toString() {
        if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null) {
            __classPrivateFieldSet(this, _DefaultMultiaddr_string, _codec_js__WEBPACK_IMPORTED_MODULE_0__.bytesToString(this.bytes), "f");
        }
        return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
    }
    toJSON() {
        return this.toString();
    }
    toOptions() {
        const codes = this.protoCodes();
        const parts = this.toString().split('/').slice(1);
        let transport;
        let port;
        if (parts.length > 2) {
            // default to https when protocol & port are omitted from DNS addrs
            if (DNS_CODES.includes(codes[0]) && P2P_CODES.includes(codes[1])) {
                transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('tcp').name;
                port = 443;
            }
            else {
                transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(parts[2]).name;
                port = parseInt(parts[3]);
            }
        }
        else if (DNS_CODES.includes(codes[0])) {
            transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)('tcp').name;
            port = 443;
        }
        else {
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        }
        const opts = {
            family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,
            host: parts[1],
            transport,
            port
        };
        return opts;
    }
    protos() {
        return this.protoCodes().map(code => Object.assign({}, (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(code)));
    }
    protoCodes() {
        const codes = [];
        const buf = this.bytes;
        let i = 0;
        while (i < buf.length) {
            const code = varint__WEBPACK_IMPORTED_MODULE_2__.decode(buf, i);
            const n = varint__WEBPACK_IMPORTED_MODULE_2__.decode.bytes;
            const p = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(code);
            const size = _codec_js__WEBPACK_IMPORTED_MODULE_0__.sizeForAddr(p, buf.slice(i + n));
            i += (size + n);
            codes.push(code);
        }
        return codes;
    }
    protoNames() {
        return this.protos().map(proto => proto.name);
    }
    tuples() {
        if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null) {
            __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, _codec_js__WEBPACK_IMPORTED_MODULE_0__.bytesToTuples(this.bytes), "f");
        }
        return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
    }
    stringTuples() {
        if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null) {
            __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, _codec_js__WEBPACK_IMPORTED_MODULE_0__.tuplesToStringTuples(this.tuples()), "f");
        }
        return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
    }
    encapsulate(addr) {
        addr = new DefaultMultiaddr(addr);
        return new DefaultMultiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        }
        return new DefaultMultiaddr(s.slice(0, i));
    }
    decapsulateCode(code) {
        const tuples = this.tuples();
        for (let i = tuples.length - 1; i >= 0; i--) {
            if (tuples[i][0] === code) {
                return new DefaultMultiaddr(_codec_js__WEBPACK_IMPORTED_MODULE_0__.tuplesToBytes(tuples.slice(0, i)));
            }
        }
        return this;
    }
    getPeerId() {
        try {
            const tuples = this.stringTuples().filter((tuple) => {
                if (tuple[0] === _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.names.ipfs.code) {
                    return true;
                }
                return false;
            });
            // Get the last ipfs tuple ['ipfs', 'peerid string']
            const tuple = tuples.pop();
            if (tuple?.[1] != null) {
                const peerIdStr = tuple[1];
                // peer id is base58btc encoded string but not multibase encoded so add the `z`
                // prefix so we can validate that it is correctly encoded
                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
                    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_4__.base58btc.decode(`z${peerIdStr}`), 'base58btc');
                }
                // try to parse peer id as CID
                return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.parse(peerIdStr).multihash.bytes, 'base58btc');
            }
            return null;
        }
        catch (e) {
            return null;
        }
    }
    getPath() {
        let path = null;
        try {
            path = this.stringTuples().filter((tuple) => {
                const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol)(tuple[0]);
                if (proto.path === true) {
                    return true;
                }
                return false;
            })[0][1];
            if (path == null) {
                path = null;
            }
        }
        catch {
            path = null;
        }
        return path;
    }
    equals(addr) {
        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_7__.equals)(this.bytes, addr.bytes);
    }
    async resolve(options) {
        const resolvableProto = this.protos().find((p) => p.resolvable);
        // Multiaddr is not resolvable?
        if (resolvableProto == null) {
            return [this];
        }
        const resolver = resolvers.get(resolvableProto.name);
        if (resolver == null) {
            throw err_code__WEBPACK_IMPORTED_MODULE_5__(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER');
        }
        const addresses = await resolver(this, options);
        return addresses.map((a) => new DefaultMultiaddr(a));
    }
    nodeAddress() {
        const options = this.toOptions();
        if (options.transport !== 'tcp' && options.transport !== 'udp') {
            throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        }
        return {
            family: options.family,
            address: options.host,
            port: options.port
        };
    }
    isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) {
            return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
            return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
            return false;
        }
        return true;
    }
    /**
     * Returns Multiaddr as a human-readable string.
     * For post Node.js v10.0.0.
     * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
     *
     * @example
     * ```js
     * console.log(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
     * ```
     */
    [(_DefaultMultiaddr_string = new WeakMap(), _DefaultMultiaddr_tuples = new WeakMap(), _DefaultMultiaddr_stringTuples = new WeakMap(), _a = symbol, inspect)]() {
        return this.inspect();
    }
    inspect() {
        return '<Multiaddr ' +
            (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.bytes, 'base16') + ' - ' +
            _codec_js__WEBPACK_IMPORTED_MODULE_0__.bytesToString(this.bytes) + '>';
    }
}
/**
 * Static factory
 *
 * @example
 * ```js
 * new Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 * ```
 *
 * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
 */
function multiaddr(addr) {
    return new DefaultMultiaddr(addr);
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/ip.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isIP": function() { return /* reexport safe */ is_ip__WEBPACK_IMPORTED_MODULE_0__.isIP; },
/* harmony export */   "isV4": function() { return /* binding */ isV4; },
/* harmony export */   "isV6": function() { return /* binding */ isV6; },
/* harmony export */   "toBytes": function() { return /* binding */ toBytes; },
/* harmony export */   "toString": function() { return /* binding */ toString; }
/* harmony export */ });
/* harmony import */ var is_ip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-ip */ "is-ip");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");



const isV4 = is_ip__WEBPACK_IMPORTED_MODULE_0__.isIPv4;
const isV6 = is_ip__WEBPACK_IMPORTED_MODULE_0__.isIPv6;
// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7
// but with buf/offset args removed because we don't use them
const toBytes = function (ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
        const bytes = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte) => {
            bytes[offset++] = parseInt(byte, 10) & 0xff;
        });
        return bytes;
    }
    if (isV6(ip)) {
        const sections = ip.split(':', 8);
        let i;
        for (i = 0; i < sections.length; i++) {
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
                v4Buffer = toBytes(sections[i]);
                sections[i] = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(v4Buffer.slice(0, 2), 'base16');
            }
            if (v4Buffer != null && ++i < 8) {
                sections.splice(i, 0, (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(v4Buffer.slice(2, 4), 'base16'));
            }
        }
        if (sections[0] === '') {
            while (sections.length < 8)
                sections.unshift('0');
        }
        else if (sections[sections.length - 1] === '') {
            while (sections.length < 8)
                sections.push('0');
        }
        else if (sections.length < 8) {
            for (i = 0; i < sections.length && sections[i] !== ''; i++)
                ;
            const argv = [i, 1];
            for (i = 9 - sections.length; i > 0; i--) {
                argv.push('0');
            }
            sections.splice.apply(sections, argv);
        }
        const bytes = new Uint8Array(offset + 16);
        for (i = 0; i < sections.length; i++) {
            const word = parseInt(sections[i], 16);
            bytes[offset++] = (word >> 8) & 0xff;
            bytes[offset++] = word & 0xff;
        }
        return bytes;
    }
    throw new Error('invalid ip address');
};
// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63
const toString = function (buf, offset = 0, length) {
    offset = ~~offset;
    length = length ?? (buf.length - offset);
    const view = new DataView(buf.buffer);
    if (length === 4) {
        const result = [];
        // IPv4
        for (let i = 0; i < length; i++) {
            result.push(buf[offset + i]);
        }
        return result.join('.');
    }
    if (length === 16) {
        const result = [];
        // IPv6
        for (let i = 0; i < length; i += 2) {
            result.push(view.getUint16(offset + i).toString(16));
        }
        return result.join(':')
            .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')
            .replace(/:{3,4}/, '::');
    }
    return '';
};
//# sourceMappingURL=ip.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "names": function() { return /* binding */ names; },
/* harmony export */   "codes": function() { return /* binding */ codes; },
/* harmony export */   "table": function() { return /* binding */ table; },
/* harmony export */   "createProtocol": function() { return /* binding */ createProtocol; },
/* harmony export */   "getProtocol": function() { return /* binding */ getProtocol; }
/* harmony export */ });
const V = -1;
const names = {};
const codes = {};
const table = [
    [4, 32, 'ip4'],
    [6, 16, 'tcp'],
    [33, 16, 'dccp'],
    [41, 128, 'ip6'],
    [42, V, 'ip6zone'],
    [53, V, 'dns', true],
    [54, V, 'dns4', true],
    [55, V, 'dns6', true],
    [56, V, 'dnsaddr', true],
    [132, 16, 'sctp'],
    [273, 16, 'udp'],
    [275, 0, 'p2p-webrtc-star'],
    [276, 0, 'p2p-webrtc-direct'],
    [277, 0, 'p2p-stardust'],
    [280, 0, 'webrtc'],
    [290, 0, 'p2p-circuit'],
    [301, 0, 'udt'],
    [302, 0, 'utp'],
    [400, V, 'unix', false, true],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [421, V, 'ipfs'],
    // `p2p` is the preferred name for 421, and is now the default
    [421, V, 'p2p'],
    [443, 0, 'https'],
    [444, 96, 'onion'],
    [445, 296, 'onion3'],
    [446, V, 'garlic64'],
    [460, 0, 'quic'],
    [465, 0, 'webtransport'],
    [466, V, 'certhash'],
    [477, 0, 'ws'],
    [478, 0, 'wss'],
    [479, 0, 'p2p-websocket-star'],
    [480, 0, 'http'],
    [777, V, 'memory']
];
// populate tables
table.forEach(row => {
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
});
function createProtocol(code, size, name, resolvable, path) {
    return {
        code,
        size,
        name,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
    };
}
function getProtocol(proto) {
    if (typeof proto === 'number') {
        if (codes[proto] != null) {
            return codes[proto];
        }
        throw new Error(`no protocol with code: ${proto}`);
    }
    else if (typeof proto === 'string') {
        if (names[proto] != null) {
            return names[proto];
        }
        throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
}
//# sourceMappingURL=protocols-table.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "or": function() { return /* binding */ or; },
/* harmony export */   "Codec": function() { return /* binding */ Codec; },
/* harmony export */   "from": function() { return /* binding */ from; },
/* harmony export */   "baseX": function() { return /* binding */ baseX; },
/* harmony export */   "rfc4648": function() { return /* binding */ rfc4648; }
/* harmony export */ });
/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/base-x.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/base-x.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/interface.js");


// Linter can't see that API is used in types.
// eslint-disable-next-line


/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.BaseEncoder}
 */
class Encoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor (name, prefix, baseEncode) {
    this.name = name
    this.prefix = prefix
    this.baseEncode = baseEncode
  }

  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode (bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`
    } else {
      throw Error('Unknown type, must be binary type')
    }
  }
}

/**
 * @template {string} Prefix
 */
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.UnibaseDecoder<Prefix>}
 * @implements {API.BaseDecoder}
 */
class Decoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseDecode) {
    this.name = name
    this.prefix = prefix
    /* c8 ignore next 3 */
    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character')
    }
    /** @private */
    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))
    this.baseDecode = baseDecode
  }

  /**
   * @param {string} text
   */
  decode (text) {
    if (typeof text === 'string') {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)
      }
      return this.baseDecode(text.slice(this.prefix.length))
    } else {
      throw Error('Can only multibase decode strings')
    }
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }
}

/**
 * @template {string} Prefix
 * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders
 */

/**
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.CombobaseDecoder<Prefix>}
 */
class ComposedDecoder {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor (decoders) {
    this.decoders = decoders
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }

  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode (input) {
    const prefix = /** @type {Prefix} */ (input[0])
    const decoder = this.decoders[prefix]
    if (decoder) {
      return decoder.decode(input)
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
  }
}

/**
 * @template {string} L
 * @template {string} R
 * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left
 * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right
 * @returns {ComposedDecoder<L|R>}
 */
const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({
  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),
  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })
}))

/**
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseCodec<Prefix>}
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.BaseCodec}
 * @implements {API.BaseEncoder}
 * @implements {API.BaseDecoder}
 */
class Codec {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseEncode, baseDecode) {
    this.name = name
    this.prefix = prefix
    this.baseEncode = baseEncode
    this.baseDecode = baseDecode
    this.encoder = new Encoder(name, prefix, baseEncode)
    this.decoder = new Decoder(name, prefix, baseDecode)
  }

  /**
   * @param {Uint8Array} input
   */
  encode (input) {
    return this.encoder.encode(input)
  }

  /**
   * @param {string} input
   */
  decode (input) {
    return this.decoder.decode(input)
  }
}

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {(bytes:Uint8Array) => string} options.encode
 * @param {(input:string) => Uint8Array} options.decode
 * @returns {Codec<Base, Prefix>}
 */
const from = ({ name, prefix, encode, decode }) =>
  new Codec(name, prefix, encode, decode)

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @returns {Codec<Base, Prefix>}
 */
const baseX = ({ prefix, name, alphabet }) => {
  const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__.default)(alphabet, name)
  return from({
    prefix,
    name,
    encode,
    /**
     * @param {string} text
     */
    decode: text => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.coerce)(decode(text))
  })
}

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @param {string} name
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar, name) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError(`Non-${name} character`)
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @param {number} options.bitsPerChar
 */
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
  return from({
    prefix,
    name,
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    decode (input) {
      return decode(input, alphabet, bitsPerChar, name)
    }
  })
}


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base10.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base10.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base10": function() { return /* binding */ base10; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");


const base10 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: '9',
  name: 'base10',
  alphabet: '0123456789'
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base16.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base16.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base16": function() { return /* binding */ base16; },
/* harmony export */   "base16upper": function() { return /* binding */ base16upper; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'f',
  name: 'base16',
  alphabet: '0123456789abcdef',
  bitsPerChar: 4
})

const base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'F',
  name: 'base16upper',
  alphabet: '0123456789ABCDEF',
  bitsPerChar: 4
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base2.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base2.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base2": function() { return /* binding */ base2; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base2 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: '0',
  name: 'base2',
  alphabet: '01',
  bitsPerChar: 1
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base256emoji.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base256emoji.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base256emoji": function() { return /* binding */ base256emoji; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");


const alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')
const alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))
const alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function encode (data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c]
    return p
  }, '')
}

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
function decode (str) {
  const byts = []
  for (const char of str) {
    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]
    if (byt === undefined) {
      throw new Error(`Non-base256emoji character: ${char}`)
    }
    byts.push(byt)
  }
  return new Uint8Array(byts)
}

const base256emoji = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  prefix: '🚀',
  name: 'base256emoji',
  encode,
  decode
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base32": function() { return /* binding */ base32; },
/* harmony export */   "base32upper": function() { return /* binding */ base32upper; },
/* harmony export */   "base32pad": function() { return /* binding */ base32pad; },
/* harmony export */   "base32padupper": function() { return /* binding */ base32padupper; },
/* harmony export */   "base32hex": function() { return /* binding */ base32hex; },
/* harmony export */   "base32hexupper": function() { return /* binding */ base32hexupper; },
/* harmony export */   "base32hexpad": function() { return /* binding */ base32hexpad; },
/* harmony export */   "base32hexpadupper": function() { return /* binding */ base32hexpadupper; },
/* harmony export */   "base32z": function() { return /* binding */ base32z; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");


const base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
})

const base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
})

const base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
})

const base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
})

const base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
})

const base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
})

const base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
})

const base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
})

const base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base36.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base36.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base36": function() { return /* binding */ base36; },
/* harmony export */   "base36upper": function() { return /* binding */ base36upper; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");


const base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
})

const base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base58btc": function() { return /* binding */ base58btc; },
/* harmony export */   "base58flickr": function() { return /* binding */ base58flickr; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");


const base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
})

const base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base64.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base64.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64": function() { return /* binding */ base64; },
/* harmony export */   "base64pad": function() { return /* binding */ base64pad; },
/* harmony export */   "base64url": function() { return /* binding */ base64url; },
/* harmony export */   "base64urlpad": function() { return /* binding */ base64urlpad; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
})

const base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
})

const base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
})

const base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base8.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base8.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base8": function() { return /* binding */ base8; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");
// @ts-check



const base8 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: '7',
  name: 'base8',
  alphabet: '01234567',
  bitsPerChar: 3
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": function() { return /* binding */ identity; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
// @ts-check




const identity = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  prefix: '\x00',
  name: 'identity',
  encode: (buf) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.toString)(buf),
  decode: (str) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromString)(str)
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/interface.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/interface.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/basics.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/basics.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.CID; },
/* harmony export */   "hasher": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.hasher; },
/* harmony export */   "digest": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.digest; },
/* harmony export */   "varint": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.varint; },
/* harmony export */   "bytes": function() { return /* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.bytes; },
/* harmony export */   "hashes": function() { return /* binding */ hashes; },
/* harmony export */   "bases": function() { return /* binding */ bases; },
/* harmony export */   "codecs": function() { return /* binding */ codecs; }
/* harmony export */ });
/* harmony import */ var _bases_identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/identity.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js");
/* harmony import */ var _bases_base2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base2.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base2.js");
/* harmony import */ var _bases_base8_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base8.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base8.js");
/* harmony import */ var _bases_base10_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base10.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base10.js");
/* harmony import */ var _bases_base16_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bases/base16.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base16.js");
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js");
/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bases/base36.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base36.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var _bases_base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bases/base64.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base64.js");
/* harmony import */ var _bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bases/base256emoji.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base256emoji.js");
/* harmony import */ var _hashes_sha2_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hashes/sha2.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2.js");
/* harmony import */ var _hashes_identity_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hashes/identity.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/identity.js");
/* harmony import */ var _codecs_raw_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./codecs/raw.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/raw.js");
/* harmony import */ var _codecs_json_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./codecs/json.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/json.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/index.js");
// @ts-check



















const bases = { ..._bases_identity_js__WEBPACK_IMPORTED_MODULE_0__, ..._bases_base2_js__WEBPACK_IMPORTED_MODULE_1__, ..._bases_base8_js__WEBPACK_IMPORTED_MODULE_2__, ..._bases_base10_js__WEBPACK_IMPORTED_MODULE_3__, ..._bases_base16_js__WEBPACK_IMPORTED_MODULE_4__, ..._bases_base32_js__WEBPACK_IMPORTED_MODULE_5__, ..._bases_base36_js__WEBPACK_IMPORTED_MODULE_6__, ..._bases_base58_js__WEBPACK_IMPORTED_MODULE_7__, ..._bases_base64_js__WEBPACK_IMPORTED_MODULE_8__, ..._bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_9__ }
const hashes = { ..._hashes_sha2_js__WEBPACK_IMPORTED_MODULE_10__, ..._hashes_identity_js__WEBPACK_IMPORTED_MODULE_11__ }
const codecs = { raw: _codecs_raw_js__WEBPACK_IMPORTED_MODULE_12__, json: _codecs_json_js__WEBPACK_IMPORTED_MODULE_13__ }




/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "coerce": function() { return /* binding */ coerce; },
/* harmony export */   "isBinary": function() { return /* binding */ isBinary; },
/* harmony export */   "fromHex": function() { return /* binding */ fromHex; },
/* harmony export */   "toHex": function() { return /* binding */ toHex; },
/* harmony export */   "fromString": function() { return /* binding */ fromString; },
/* harmony export */   "toString": function() { return /* binding */ toString; },
/* harmony export */   "empty": function() { return /* binding */ empty; }
/* harmony export */ });
const empty = new Uint8Array(0)

/**
 * @param {Uint8Array} d
 */
const toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')

/**
 * @param {string} hex
 */
const fromHex = hex => {
  const hexes = hex.match(/../g)
  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty
}

/**
 * @param {Uint8Array} aa
 * @param {Uint8Array} bb
 */
const equals = (aa, bb) => {
  if (aa === bb) return true
  if (aa.byteLength !== bb.byteLength) {
    return false
  }

  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false
    }
  }

  return true
}

/**
 * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o
 * @returns {Uint8Array}
 */
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o
  if (o instanceof ArrayBuffer) return new Uint8Array(o)
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
  }
  throw new Error('Unknown type, must be binary type')
}

/**
 * @param {any} o
 * @returns {o is ArrayBuffer|ArrayBufferView}
 */
const isBinary = o =>
  o instanceof ArrayBuffer || ArrayBuffer.isView(o)

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
const fromString = str => (new TextEncoder()).encode(str)

/**
 * @param {Uint8Array} b
 * @returns {string}
 */
const toString = b => (new TextDecoder()).decode(b)




/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": function() { return /* binding */ format; },
/* harmony export */   "CID": function() { return /* binding */ CID; }
/* harmony export */ });
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js");
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./link/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/link/interface.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _link_interface_js__WEBPACK_IMPORTED_MODULE_5__) if(["default","format","CID"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _link_interface_js__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);





// Linter can see that API is used in types.
// eslint-disable-next-line


// This way TS will also expose all the types from module


/**
 * @template {API.Link<unknown, number, number, API.Version>} T
 * @template {string} Prefix
 * @param {T} link
 * @param {API.MultibaseEncoder<Prefix>} [base]
 * @returns {API.ToString<T, Prefix>}
 */
const format = (link, base) => {
  const { bytes, version } = link
  switch (version) {
    case 0:
      return toStringV0(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */ (base) || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.encoder
      )
    default:
      return toStringV1(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */ (base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.encoder)
      )
  }
}

/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */
const cache = new WeakMap()

/**
 * @param {API.UnknownLink} cid
 * @returns {Map<string, string>}
 */
const baseCache = cid => {
  const baseCache = cache.get(cid)
  if (baseCache == null) {
    const baseCache = new Map()
    cache.set(cid, baseCache)
    return baseCache
  }
  return baseCache
}

/**
 * @template {unknown} [Data=unknown]
 * @template {number} [Format=number]
 * @template {number} [Alg=number]
 * @template {API.Version} [Version=API.Version]
 * @implements {API.Link<Data, Format, Alg, Version>}
 */

class CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor (version, code, multihash, bytes) {
    /** @readonly */
    this.code = code
    /** @readonly */
    this.version = version
    /** @readonly */
    this.multihash = multihash
    /** @readonly */
    this.bytes = bytes

    // ArrayBufferView
    /** @readonly */
    this.byteOffset = bytes.byteOffset
    /** @readonly */
    this.byteLength = bytes.byteLength

    // Circular reference
    /** @readonly */
    this.asCID = this
  }

  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0 () {
    switch (this.version) {
      case 0: {
        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)
      }
      case 1: {
        const { code, multihash } = this

        if (code !== DAG_PB_CODE) {
          throw new Error('Cannot convert a non dag-pb CID to CIDv0')
        }

        // sha2-256
        if (multihash.code !== SHA_256_CODE) {
          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
        }

        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (
          CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)
          )
        )
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        )
      }
    }
  }

  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1 () {
    switch (this.version) {
      case 0: {
        const { code, digest } = this.multihash
        const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, digest)
        return /** @type {CID<Data, Format, Alg, 1>} */ (
          CID.createV1(this.code, multihash)
        )
      }
      case 1: {
        return /** @type {CID<Data, Format, Alg, 1>} */ (this)
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        )
      }
    }
  }

  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals (other) {
    return CID.equals(this, other)
  }

  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals (self, other) {
    const unknown =
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (
        other
      )
    return (
      unknown &&
      self.code === unknown.code &&
      self.version === unknown.version &&
      _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.equals(self.multihash, unknown.multihash)
    )
  }

  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString (base) {
    return format(this, base)
  }

  toJSON () {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    }
  }

  link () {
    return this
  }

  get [Symbol.toStringTag] () {
    return 'CID'
  }

  // Legacy

  [Symbol.for('nodejs.util.inspect.custom')] () {
    return `CID(${this.toString()})`
  }

  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returs null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID (input) {
    const value = /** @type {any} */ (input)
    if (value instanceof CID) {
      // If value is instance of CID then we're all set.
      return value
    } else if (value != null && value.asCID === value) {
      // If value isn't instance of this CID class but `this.asCID === this` is
      // true it is CID instance coming from a different implementation (diff
      // version or duplicate). In that case we rebase it to this `CID`
      // implementation so caller is guaranteed to get instance with expected
      // API.
      const { version, code, multihash, bytes } = value
      return new CID(
        version,
        code,
        /** @type {API.MultihashDigest<Alg>} */ (multihash),
        bytes || encodeCID(version, code, multihash.bytes)
      )
    } else if (value != null && value[cidSymbol] === true) {
      // If value is a CID from older implementation that used to be tagged via
      // symbol we still rebase it to the this `CID` implementation by
      // delegating that to a constructor.
      const { version, multihash, code } = value
      const digest =
        /** @type {API.MultihashDigest<Alg>} */
        (_hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.decode(multihash))
      return CID.create(version, code, digest)
    } else {
      // Otherwise value is not a CID (or an incompatible version of it) in
      // which case we return `null`.
      return null
    }
  }

  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create (version, code, digest) {
    if (typeof code !== 'number') {
      throw new Error('String codecs are no longer supported')
    }

    switch (version) {
      case 0: {
        if (code !== DAG_PB_CODE) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          )
        } else {
          return new CID(version, code, digest, digest.bytes)
        }
      }
      case 1: {
        const bytes = encodeCID(version, code, digest.bytes)
        return new CID(version, code, digest, bytes)
      }
      default: {
        throw new Error('Invalid version')
      }
    }
  }

  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0 (digest) {
    return CID.create(0, DAG_PB_CODE, digest)
  }

  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1 (code, digest) {
    return CID.create(1, code, digest)
  }

  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode (bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes)
    if (remainder.length) {
      throw new Error('Incorrect length')
    }
    return cid
  }

  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst (bytes) {
    const specs = CID.inspectBytes(bytes)
    const prefixSize = specs.size - specs.multihashSize
    const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_4__.coerce)(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    )
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error('Incorrect length')
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    )
    const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.Digest(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    )
    const cid =
      specs.version === 0
        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))
        : CID.createV1(specs.codec, digest)
    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]
  }

  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes (initialBytes) {
    let offset = 0
    const next = () => {
      const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_0__.decode(initialBytes.subarray(offset))
      offset += length
      return i
    }

    let version = /** @type {V} */ (next())
    let codec = /** @type {C} */ (DAG_PB_CODE)
    if (/** @type {number} */(version) === 18) {
      // CIDv0
      version = /** @type {V} */ (0)
      offset = 0
    } else {
      codec = /** @type {C} */ (next())
    }

    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`)
    }

    const prefixSize = offset
    const multihashCode = /** @type {A} */ (next()) // multihash code
    const digestSize = next() // multihash length
    const size = offset + digestSize
    const multihashSize = size - prefixSize

    return { version, codec, multihashCode, digestSize, multihashSize, size }
  }

  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse (source, base) {
    const [prefix, bytes] = parseCIDtoBytes(source, base)

    const cid = CID.decode(bytes)

    // Cache string representation to avoid computing it on `this.toString()`
    baseCache(cid).set(prefix, source)

    return cid
  }
}

/**
 * @template {string} Prefix
 * @template {unknown} Data
 * @template {number} Code
 * @template {number} Alg
 * @template {API.Version} Ver
 * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
 * @param {API.MultibaseDecoder<Prefix>} [base]
 * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}
 */
const parseCIDtoBytes = (source, base) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case 'Q': {
      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc
      return [
        /** @type {Prefix} */ (_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix),
        decoder.decode(`${_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix}${source}`)
      ]
    }
    case _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix: {
      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc
      return [/** @type {Prefix} */(_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix), decoder.decode(source)]
    }
    case _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix: {
      const decoder = base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32
      return [/** @type {Prefix} */(_bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix), decoder.decode(source)]
    }
    default: {
      if (base == null) {
        throw Error(
          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'
        )
      }
      return [/** @type {Prefix} */(source[0]), base.decode(source)]
    }
  }
}

/**
 *
 * @param {Uint8Array} bytes
 * @param {Map<string, string>} cache
 * @param {API.MultibaseEncoder<'z'>} base
 */
const toStringV0 = (bytes, cache, base) => {
  const { prefix } = base
  if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base.name} encoding`)
  }

  const cid = cache.get(prefix)
  if (cid == null) {
    const cid = base.encode(bytes).slice(1)
    cache.set(prefix, cid)
    return cid
  } else {
    return cid
  }
}

/**
 * @template {string} Prefix
 * @param {Uint8Array} bytes
 * @param {Map<string, string>} cache
 * @param {API.MultibaseEncoder<Prefix>} base
 */
const toStringV1 = (bytes, cache, base) => {
  const { prefix } = base
  const cid = cache.get(prefix)
  if (cid == null) {
    const cid = base.encode(bytes)
    cache.set(prefix, cid)
    return cid
  } else {
    return cid
  }
}

const DAG_PB_CODE = 0x70
const SHA_256_CODE = 0x12

/**
 * @param {API.Version} version
 * @param {number} code
 * @param {Uint8Array} multihash
 * @returns {Uint8Array}
 */
const encodeCID = (version, code, multihash) => {
  const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(version)
  const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code)
  const bytes = new Uint8Array(hashOffset + multihash.byteLength)
  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(version, bytes, 0)
  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(code, bytes, codeOffset)
  bytes.set(multihash, hashOffset)
  return bytes
}

const cidSymbol = Symbol.for('@ipld/js-cid/CID')


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/json.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/json.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": function() { return /* binding */ name; },
/* harmony export */   "code": function() { return /* binding */ code; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
// @ts-check

/**
 * @template T
 * @typedef {import('./interface.js').ByteView<T>} ByteView
 */

const textEncoder = new TextEncoder()
const textDecoder = new TextDecoder()

const name = 'json'
const code = 0x0200

/**
 * @template T
 * @param {T} node
 * @returns {ByteView<T>}
 */
const encode = (node) => textEncoder.encode(JSON.stringify(node))

/**
 * @template T
 * @param {ByteView<T>} data
 * @returns {T}
 */
const decode = (data) => JSON.parse(textDecoder.decode(data))


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/raw.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/raw.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": function() { return /* binding */ name; },
/* harmony export */   "code": function() { return /* binding */ code; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
// @ts-check



/**
 * @template T
 * @typedef {import('./interface.js').ByteView<T>} ByteView
 */

const name = 'raw'
const code = 0x55

/**
 * @param {Uint8Array} node
 * @returns {ByteView<Uint8Array>}
 */
const encode = (node) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(node)

/**
 * @param {ByteView<Uint8Array>} data
 * @returns {Uint8Array}
 */
const decode = (data) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(data)


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": function() { return /* binding */ create; },
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "Digest": function() { return /* binding */ Digest; }
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js");



/**
 * Creates a multihash digest.
 *
 * @template {number} Code
 * @param {Code} code
 * @param {Uint8Array} digest
 */
const create = (code, digest) => {
  const size = digest.byteLength
  const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code)
  const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size)

  const bytes = new Uint8Array(digestOffset + size)
  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0)
  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset)
  bytes.set(digest, digestOffset)

  return new Digest(code, size, digest, bytes)
}

/**
 * Turns bytes representation of multihash digest into an instance.
 *
 * @param {Uint8Array} multihash
 * @returns {MultihashDigest}
 */
const decode = (multihash) => {
  const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash)
  const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes)
  const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset))
  const digest = bytes.subarray(sizeOffset + digestOffset)

  if (digest.byteLength !== size) {
    throw new Error('Incorrect length')
  }

  return new Digest(code, size, digest, bytes)
}

/**
 * @param {MultihashDigest} a
 * @param {unknown} b
 * @returns {b is MultihashDigest}
 */
const equals = (a, b) => {
  if (a === b) {
    return true
  } else {
    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)

    return (
      a.code === data.code &&
      a.size === data.size &&
      data.bytes instanceof Uint8Array &&
      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, data.bytes)
    )
  }
}

/**
 * @typedef {import('./interface.js').MultihashDigest} MultihashDigest
 */

/**
 * Represents a multihash digest which carries information about the
 * hashing alogrithm and an actual hash digest.
 *
 * @template {number} Code
 * @template {number} Size
 * @class
 * @implements {MultihashDigest}
 */
class Digest {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor (code, size, digest, bytes) {
    this.code = code
    this.size = size
    this.digest = digest
    this.bytes = bytes
  }
}


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "from": function() { return /* binding */ from; },
/* harmony export */   "Hasher": function() { return /* binding */ Hasher; }
/* harmony export */ });
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js");


/**
 * @template {string} Name
 * @template {number} Code
 * @param {object} options
 * @param {Name} options.name
 * @param {Code} options.code
 * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode
 */
const from = ({ name, code, encode }) => new Hasher(name, code, encode)

/**
 * Hasher represents a hashing algorithm implementation that produces as
 * `MultihashDigest`.
 *
 * @template {string} Name
 * @template {number} Code
 * @class
 * @implements {MultihashHasher<Code>}
 */
class Hasher {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor (name, code, encode) {
    this.name = name
    this.code = code
    this.encode = encode
  }

  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest (input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input)
      return result instanceof Uint8Array
        ? _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, result)
        /* c8 ignore next 1 */
        : result.then(digest => _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest))
    } else {
      throw Error('Unknown type, must be binary type')
      /* c8 ignore next 1 */
    }
  }
}

/**
 * @template {number} Alg
 * @typedef {import('./interface.js').MultihashHasher} MultihashHasher
 */

/**
 * @template T
 * @typedef {Promise<T>|T} Await
 */


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/identity.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/identity.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": function() { return /* binding */ identity; }
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js");



const code = 0x0
const name = 'identity'

/** @type {(input:Uint8Array) => Uint8Array} */
const encode = _bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce

/**
 * @param {Uint8Array} input
 * @returns {Digest.Digest<typeof code, number>}
 */
const digest = (input) => _digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, encode(input))

const identity = { code, name, encode, digest }


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sha256": function() { return /* binding */ sha256; },
/* harmony export */   "sha512": function() { return /* binding */ sha512; }
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hasher.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
// @ts-check





const sha256 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_1__.from)({
  name: 'sha2-256',
  code: 0x12,
  encode: (input) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha256').update(input).digest())
})

const sha512 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_1__.from)({
  name: 'sha2-512',
  code: 0x13,
  encode: input => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha512').update(input).digest())
})


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": function() { return /* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_0__.CID; },
/* harmony export */   "hasher": function() { return /* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__; },
/* harmony export */   "digest": function() { return /* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__; },
/* harmony export */   "varint": function() { return /* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_1__; },
/* harmony export */   "bytes": function() { return /* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_2__; }
/* harmony export */ });
/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cid.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js");
/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/interface.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _interface_js__WEBPACK_IMPORTED_MODULE_5__) if(["default","CID","hasher","digest","varint","bytes"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _interface_js__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);





// This way TS will also expose all the types from module





/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/interface.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/interface.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/link/interface.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/link/interface.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// this is dummy module overlayed by interface.ts


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "encodeTo": function() { return /* binding */ encodeTo; },
/* harmony export */   "encodingLength": function() { return /* binding */ encodingLength; }
/* harmony export */ });
/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/varint.js");


/**
 * @param {Uint8Array} data
 * @param {number} [offset=0]
 * @returns {[number, number]}
 */
const decode = (data, offset = 0) => {
  const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.decode(data, offset)
  return [code, _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.decode.bytes]
}

/**
 * @param {number} int
 * @param {Uint8Array} target
 * @param {number} [offset=0]
 */
const encodeTo = (int, target, offset = 0) => {
  _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.encode(int, target, offset)
  return target
}

/**
 * @param {number} int
 * @returns {number}
 */
const encodingLength = (int) => {
  return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__.default.encodingLength(int)
}


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/base-x.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/base-x.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET, name) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    var b58 = new Uint8Array(size);
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0;
        // Skip leading spaces.
    if (source[psz] === ' ') { return }
        // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
      if (carry === 255) { return }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
        // Skip trailing spaces.
    if (source[psz] === ' ') { return }
        // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error(`Non-${name} character`)
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
var src = base;

var _brrp__multiformats_scope_baseX = src;

/* harmony default export */ __webpack_exports__["default"] = (_brrp__multiformats_scope_baseX);


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/varint.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/varint.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var encode_1 = encode;

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31);

function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB;
    num /= 128;
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  
  encode.bytes = offset - oldOffset + 1;
  
  return out
}

var decode = read;

var MSB$1 = 0x80
  , REST$1 = 0x7F;

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++];
    res += shift < 28
      ? (b & REST$1) << shift
      : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1)

  read.bytes = counter - offset;

  return res
}

var N1 = Math.pow(2,  7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

var length = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
};

var varint = {
    encode: encode_1
  , decode: decode
  , encodingLength: length
};

var _brrp_varint = varint;

/* harmony default export */ __webpack_exports__["default"] = (_brrp_varint);


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alloc": function() { return /* binding */ alloc; },
/* harmony export */   "allocUnsafe": function() { return /* binding */ allocUnsafe; }
/* harmony export */ });
/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/as-uint8array.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js");

/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */
function alloc(size = 0) {
    if (globalThis.Buffer?.alloc != null) {
        return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__.asUint8Array)(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
}
/**
 * Where possible returns a Uint8Array of the requested size that references
 * uninitialized memory. Only use if you are certain you will immediately
 * overwrite every value in the returned `Uint8Array`.
 */
function allocUnsafe(size = 0) {
    if (globalThis.Buffer?.allocUnsafe != null) {
        return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__.asUint8Array)(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
}
//# sourceMappingURL=alloc.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concat": function() { return /* binding */ concat; }
/* harmony export */ });
/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alloc.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js");
/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/as-uint8array.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js");


/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 */
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(length);
    let offset = 0;
    for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__.asUint8Array)(output);
}
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": function() { return /* binding */ equals; }
/* harmony export */ });
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromString": function() { return /* binding */ fromString; }
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js");
/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/as-uint8array.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js");


/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function fromString(string, encoding = 'utf8') {
    const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__.default[encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__.asUint8Array)(globalThis.Buffer.from(string, 'utf-8'));
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
}
//# sourceMappingURL=from-string.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toString": function() { return /* binding */ toString; }
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js");

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function toString(array, encoding = 'utf8') {
    const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__.default[encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
}
//# sourceMappingURL=to-string.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asUint8Array": function() { return /* binding */ asUint8Array; }
/* harmony export */ });
/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */
function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
}
//# sourceMappingURL=as-uint8array.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/basics */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/src/basics.js");
/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../alloc.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js");


function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf) => {
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf) => {
    let string = 'a';
    for (let i = 0; i < buf.length; i++) {
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str) => {
    str = str.substring(1);
    const buf = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_1__.allocUnsafe)(str.length);
    for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases.base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii,
    ...multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases
};
/* harmony default export */ __webpack_exports__["default"] = (BASES);
//# sourceMappingURL=bases.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/varint/decode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/varint/decode.js ***!
  \****************************************************************************/
/***/ (function(module) {

module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/varint/encode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/varint/encode.js ***!
  \****************************************************************************/
/***/ (function(module) {

module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/varint/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/varint/index.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = {
    encode: __webpack_require__(/*! ./encode.js */ "./node_modules/@multiformats/multiaddr/node_modules/varint/encode.js")
  , decode: __webpack_require__(/*! ./decode.js */ "./node_modules/@multiformats/multiaddr/node_modules/varint/decode.js")
  , encodingLength: __webpack_require__(/*! ./length.js */ "./node_modules/@multiformats/multiaddr/node_modules/varint/length.js")
}


/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/varint/length.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/varint/length.js ***!
  \****************************************************************************/
/***/ (function(module) {


var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}


/***/ }),

/***/ "./node_modules/dag-jose/lib/encryption.js":
/*!*************************************************!*\
  !*** ./node_modules/dag-jose/lib/encryption.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromSplit": function() { return /* binding */ fromSplit; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dag-jose/lib/utils.js");

function fromSplit(split) {
    const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
    const jwe = {
        ciphertext,
        iv,
        protected: protectedHeader,
        tag,
    };
    if (encrypted_key)
        jwe.recipients = [{ encrypted_key }];
    return jwe;
}
function encodeRecipient(recipient) {
    const encRec = {};
    if (recipient.encrypted_key)
        encRec.encrypted_key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(recipient.encrypted_key);
    if (recipient.header)
        encRec.header = recipient.header;
    return encRec;
}
function encode(jwe) {
    const encJwe = {
        ciphertext: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(jwe.ciphertext),
        protected: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(jwe.protected),
        iv: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(jwe.iv),
        tag: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(jwe.tag),
    };
    if (jwe.aad)
        encJwe.aad = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(jwe.aad);
    if (jwe.recipients)
        encJwe.recipients = jwe.recipients.map(encodeRecipient);
    if (jwe.unprotected)
        encJwe.unprotected = jwe.unprotected;
    return encJwe;
}
function decodeRecipient(encoded) {
    const recipient = {};
    if (encoded.encrypted_key)
        recipient.encrypted_key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.encrypted_key);
    if (encoded.header)
        recipient.header = encoded.header;
    return recipient;
}
function decode(encoded) {
    const jwe = {
        ciphertext: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.ciphertext),
        protected: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.protected),
        iv: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.iv),
        tag: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.tag),
    };
    if (encoded.aad)
        jwe.aad = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.aad);
    if (encoded.recipients)
        jwe.recipients = encoded.recipients.map(decodeRecipient);
    if (encoded.unprotected)
        jwe.unprotected = encoded.unprotected;
    return jwe;
}
//# sourceMappingURL=encryption.js.map

/***/ }),

/***/ "./node_modules/dag-jose/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/dag-jose/lib/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": function() { return /* binding */ name; },
/* harmony export */   "code": function() { return /* binding */ code; },
/* harmony export */   "toGeneral": function() { return /* binding */ toGeneral; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
/* harmony import */ var _signing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signing.js */ "./node_modules/dag-jose/lib/signing.js");
/* harmony import */ var _encryption_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encryption.js */ "./node_modules/dag-jose/lib/encryption.js");
/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ipld/dag-cbor */ "@ipld/dag-cbor");



const name = 'dag-jose';
const code = 133;
function isDagJWS(jose) {
    return ('payload' in jose &&
        typeof jose.payload === 'string' &&
        'signatures' in jose &&
        Array.isArray(jose.signatures));
}
function isEncodedJWS(jose) {
    return ('payload' in jose &&
        jose.payload instanceof Uint8Array &&
        'signatures' in jose &&
        Array.isArray(jose.signatures));
}
function isEncodedJWE(jose) {
    return ('ciphertext' in jose &&
        jose.ciphertext instanceof Uint8Array &&
        'iv' in jose &&
        jose.iv instanceof Uint8Array &&
        'protected' in jose &&
        jose.protected instanceof Uint8Array &&
        'tag' in jose &&
        jose.tag instanceof Uint8Array);
}
function isDagJWE(jose) {
    return ('ciphertext' in jose &&
        typeof jose.ciphertext === 'string' &&
        'iv' in jose &&
        typeof jose.iv === 'string' &&
        'protected' in jose &&
        typeof jose.protected === 'string' &&
        'tag' in jose &&
        typeof jose.tag === 'string');
}
function toGeneral(jose) {
    if (typeof jose === 'string') {
        const split = jose.split('.');
        if (split.length === 3) {
            return _signing_js__WEBPACK_IMPORTED_MODULE_0__.fromSplit(split);
        }
        else if (split.length === 5) {
            return _encryption_js__WEBPACK_IMPORTED_MODULE_1__.fromSplit(split);
        }
        throw new Error('Not a valid JOSE string');
    }
    if (isDagJWS(jose) || isDagJWE(jose)) {
        return jose;
    }
    throw new Error('Not a valid unencoded JOSE object');
}
function encode(obj) {
    if (typeof obj === 'string') {
        obj = toGeneral(obj);
    }
    let encodedJose;
    if (isDagJWS(obj)) {
        encodedJose = _signing_js__WEBPACK_IMPORTED_MODULE_0__.encode(obj);
    }
    else if (isDagJWE(obj)) {
        encodedJose = _encryption_js__WEBPACK_IMPORTED_MODULE_1__.encode(obj);
    }
    else {
        throw new Error('Not a valid JOSE object');
    }
    return new Uint8Array(_ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_2__.encode(encodedJose));
}
function decode(data) {
    let encoded;
    try {
        encoded = _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_2__.decode(data);
    }
    catch (e) {
        throw new Error('Not a valid DAG-JOSE object');
    }
    if (isEncodedJWS(encoded)) {
        return _signing_js__WEBPACK_IMPORTED_MODULE_0__.decode(encoded);
    }
    else if (isEncodedJWE(encoded)) {
        return _encryption_js__WEBPACK_IMPORTED_MODULE_1__.decode(encoded);
    }
    else {
        throw new Error('Not a valid DAG-JOSE object');
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/dag-jose/lib/signing.js":
/*!**********************************************!*\
  !*** ./node_modules/dag-jose/lib/signing.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromSplit": function() { return /* binding */ fromSplit; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "decode": function() { return /* binding */ decode; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dag-jose/lib/utils.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");


function fromSplit(split) {
    const [protectedHeader, payload, signature] = split;
    return {
        payload,
        signatures: [{ protected: protectedHeader, signature }],
        link: multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(payload)),
    };
}
function encodeSignature(signature) {
    const encoded = {
        signature: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(signature.signature),
    };
    if (signature.header)
        encoded.header = signature.header;
    if (signature.protected)
        encoded.protected = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(signature.protected);
    return encoded;
}
function encode(jws) {
    const payload = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64url)(jws.payload);
    try {
        multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(payload);
    }
    catch (e) {
        throw new Error('Not a valid DagJWS');
    }
    return {
        payload,
        signatures: jws.signatures.map(encodeSignature),
    };
}
function decodeSignature(encoded) {
    const sign = {
        signature: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.signature),
    };
    if (encoded.header)
        sign.header = encoded.header;
    if (encoded.protected)
        sign.protected = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.protected);
    return sign;
}
function decode(encoded) {
    const decoded = {
        payload: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64url)(encoded.payload),
        signatures: encoded.signatures.map(decodeSignature),
    };
    decoded.link = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(new Uint8Array(encoded.payload));
    return decoded;
}
//# sourceMappingURL=signing.js.map

/***/ }),

/***/ "./node_modules/dag-jose/lib/utils.js":
/*!********************************************!*\
  !*** ./node_modules/dag-jose/lib/utils.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toBase64url": function() { return /* binding */ toBase64url; },
/* harmony export */   "fromBase64url": function() { return /* binding */ fromBase64url; }
/* harmony export */ });
/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base64 */ "multiformats/bases/base64");

function toBase64url(b) {
    return multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__.base64url.encode(b).slice(1);
}
function fromBase64url(s) {
    return multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__.base64url.decode(`u${s}`);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/ipfs-core-utils/node_modules/nanoid/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/node_modules/nanoid/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "urlAlphabet": function() { return /* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet; },
/* harmony export */   "random": function() { return /* binding */ random; },
/* harmony export */   "customRandom": function() { return /* binding */ customRandom; },
/* harmony export */   "customAlphabet": function() { return /* binding */ customAlphabet; },
/* harmony export */   "nanoid": function() { return /* binding */ nanoid; }
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/ipfs-core-utils/node_modules/nanoid/url-alphabet/index.js");



const POOL_SIZE_MULTIPLIER = 128
let pool, poolOffset
let fillPool = bytes => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)
    ;(0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync)(pool)
    poolOffset = 0
  } else if (poolOffset + bytes > pool.length) {
    (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync)(pool)
    poolOffset = 0
  }
  poolOffset += bytes
}
let random = bytes => {
  fillPool((bytes -= 0))
  return pool.subarray(poolOffset - bytes, poolOffset)
}
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let i = step
      while (i--) {
        id += alphabet[bytes[i] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) => {
  fillPool((size -= 0))
  let id = ''
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet[pool[i] & 63]
  }
  return id
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/node_modules/nanoid/url-alphabet/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/node_modules/nanoid/url-alphabet/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "urlAlphabet": function() { return /* binding */ urlAlphabet; }
/* harmony export */ });
const urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/agent.js":
/*!***************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/agent.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ "https");



/**
 * @param {URL} [url]
 */
/* harmony default export */ __webpack_exports__["default"] = ((url) => {
  if (!url) {
    throw new Error('URL required')
  }

  return url.protocol.startsWith('https') ? https__WEBPACK_IMPORTED_MODULE_1__.Agent : http__WEBPACK_IMPORTED_MODULE_0__.Agent
});


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseCandidateMultiple": function() { return /* binding */ normaliseCandidateMultiple; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! browser-readablestream-to-it */ "browser-readablestream-to-it");
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-peekable */ "it-peekable");
/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-map */ "it-map");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-core-utils/src/files/utils.js");
/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ipfs-unixfs */ "./node_modules/ipfs-unixfs/src/index.js");







/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidate} ImportCandidate
 * @typedef {import('ipfs-core-types/src/utils').ToContent} ToContent
 * @typedef {import('ipfs-unixfs-importer').ImportCandidate} ImporterImportCandidate
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 */

/**
 * @param {ImportCandidateStream} input
 * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent
 */
// eslint-disable-next-line complexity
async function * normaliseCandidateMultiple (input, normaliseContent) {
  // String
  // Uint8Array|ArrayBuffer|TypedArray
  // Blob|File
  // fs.ReadStream
  // @ts-expect-error _readableState is a property of a node fs.ReadStream
  if (typeof input === 'string' || input instanceof String || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(input) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBlob)(input) || input._readableState) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT')
  }

  // Browser ReadableStream
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isReadableStream)(input)) {
    input = browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_1__(input)
  }

  // Iterable<?>
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_2__(input)
    const { value, done } = await peekable.peek()

    if (done) {
      // make sure empty iterators result in empty files
      yield * []
      return
    }

    peekable.push(value)

    // (Async)Iterable<Number>
    // (Async)Iterable<Bytes>
    if (Number.isInteger(value)) {
      throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT')
    }

    // (Async)Iterable<fs.ReadStream>
    // @ts-expect-error private field
    if (value._readableState) {
      // @ts-expect-error Node fs.ReadStreams have a `.path` property so we need to pass it as the content
      yield * it_map__WEBPACK_IMPORTED_MODULE_3__(peekable, (/** @type {ImportCandidate} */ value) => toFileObject({ content: value }, normaliseContent))
      return
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(value)) {
      // @ts-expect-error peekable is still an iterable of ImportCandidates
      yield toFileObject({ content: peekable }, normaliseContent)
      return
    }

    // (Async)Iterable<(Async)Iterable<?>>
    // (Async)Iterable<ReadableStream<?>>
    // ReadableStream<(Async)Iterable<?>>
    // ReadableStream<ReadableStream<?>>
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFileObject)(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isReadableStream)(value) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBlob)(value)) {
      yield * it_map__WEBPACK_IMPORTED_MODULE_3__(peekable, (/** @type {ImportCandidate} */ value) => toFileObject(value, normaliseContent))
      return
    }
  }

  // { path, content: ? }
  // Note: Detected _after_ (Async)Iterable<?> because Node.js fs.ReadStreams have a
  // `path` property that passes this check.
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFileObject)(input)) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT')
  }

  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')
}

/**
 * @param {ImportCandidate} input
 * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent
 */
async function toFileObject (input, normaliseContent) {
  // @ts-expect-error - Those properties don't exist on most input types
  const { path, mode, mtime, content } = input

  /** @type {ImporterImportCandidate} */
  const file = {
    path: path || '',
    mode: (0,ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__.parseMode)(mode),
    mtime: (0,ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__.parseMtime)(mtime)
  }

  if (content) {
    file.content = await normaliseContent(content)
  } else if (!path) { // Not already a file object with path or content prop
    // @ts-expect-error - input still can be different ToContent
    file.content = await normaliseContent(input)
  }

  return file
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseCandidateSingle": function() { return /* binding */ normaliseCandidateSingle; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! browser-readablestream-to-it */ "browser-readablestream-to-it");
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-peekable */ "it-peekable");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-core-utils/src/files/utils.js");
/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-unixfs */ "./node_modules/ipfs-unixfs/src/index.js");






/**
 * @typedef {import('ipfs-core-types/src/utils').ToContent} ToContent
 * @typedef {import('ipfs-unixfs-importer').ImportCandidate} ImporterImportCandidate
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidate} ImportCandidate
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 */

/**
 * @param {ImportCandidate} input
 * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent
 */
// eslint-disable-next-line complexity
async function * normaliseCandidateSingle (input, normaliseContent) {
  if (input === null || input === undefined) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')
  }

  // String
  if (typeof input === 'string' || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent)
    return
  }

  // Uint8Array|ArrayBuffer|TypedArray
  // Blob|File
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isBytes)(input) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isBlob)(input)) {
    yield toFileObject(input, normaliseContent)
    return
  }

  // Browser ReadableStream
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isReadableStream)(input)) {
    input = browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_1__(input)
  }

  // Iterable<?>
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    // @ts-expect-error it's (async)iterable
    const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_2__(input)

    /** @type {any} value **/
    const { value, done } = await peekable.peek()

    if (done) {
      // make sure empty iterators result in empty files
      yield { content: [] }
      return
    }

    peekable.push(value)

    // (Async)Iterable<Number>
    // (Async)Iterable<Bytes>
    // (Async)Iterable<String>
    if (Number.isInteger(value) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value) || typeof value === 'string' || value instanceof String) {
      yield toFileObject(peekable, normaliseContent)
      return
    }

    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead'), 'ERR_UNEXPECTED_INPUT')
  }

  // { path, content: ? }
  // Note: Detected _after_ (Async)Iterable<?> because Node.js fs.ReadStreams have a
  // `path` property that passes this check.
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isFileObject)(input)) {
    yield toFileObject(input, normaliseContent)
    return
  }

  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), 'ERR_UNEXPECTED_INPUT')
}

/**
 * @param {ImportCandidate} input
 * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent
 */
async function toFileObject (input, normaliseContent) {
  // @ts-expect-error - Those properties don't exist on most input types
  const { path, mode, mtime, content } = input

  /** @type {ImporterImportCandidate} */
  const file = {
    path: path || '',
    mode: (0,ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__.parseMode)(mode),
    mtime: (0,ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__.parseMtime)(mtime)
  }

  if (content) {
    file.content = await normaliseContent(content)
  } else if (!path) { // Not already a file object with path or content prop
    // @ts-expect-error - input still can be different ToContent
    file.content = await normaliseContent(input)
  }

  return file
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-content.browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-content.browser.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseContent": function() { return /* binding */ normaliseContent; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-peekable */ "it-peekable");
/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! browser-readablestream-to-it */ "browser-readablestream-to-it");
/* harmony import */ var it_all__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-all */ "it-all");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-core-utils/src/files/utils.js");






/**
 * @param {import('ipfs-core-types/src/utils').ToContent} input
 */
async function normaliseContent (input) {
  // Bytes
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(input)) {
    return new Blob([input])
  }

  // String
  if (typeof input === 'string' || input instanceof String) {
    return new Blob([input.toString()])
  }

  // Blob | File
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBlob)(input)) {
    return input
  }

  // Browser stream
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isReadableStream)(input)) {
    input = browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__(input)
  }

  // (Async)Iterator<?>
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    /** @type {any} peekable */
    const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_1__(input)

    /** @type {any} value **/
    const { value, done } = await peekable.peek()

    if (done) {
      // make sure empty iterators result in empty files
      return itToBlob(peekable)
    }

    peekable.push(value)

    // (Async)Iterable<Number>
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await it_all__WEBPACK_IMPORTED_MODULE_3__(peekable))])
    }

    // (Async)Iterable<Bytes|String>
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(value) || typeof value === 'string' || value instanceof String) {
      return itToBlob(peekable)
    }
  }

  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')
}

/**
 * @param {AsyncIterable<BlobPart>|Iterable<BlobPart>} stream
 */
async function itToBlob (stream) {
  const parts = []

  for await (const chunk of stream) {
    parts.push(chunk)
  }

  return new Blob(parts)
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-content.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-content.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseContent": function() { return /* binding */ normaliseContent; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ "uint8arrays/from-string");
/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! browser-readablestream-to-it */ "browser-readablestream-to-it");
/* harmony import */ var blob_to_it__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blob-to-it */ "blob-to-it");
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-peekable */ "it-peekable");
/* harmony import */ var it_all__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! it-all */ "it-all");
/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! it-map */ "it-map");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-core-utils/src/files/utils.js");









/**
 * @template T
 * @param {T} thing
 */
async function * toAsyncIterable (thing) {
  yield thing
}

/**
 * @param {import('ipfs-core-types/src/utils').ToContent} input
 */
async function normaliseContent (input) {
  // Bytes | String
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isBytes)(input)) {
    return toAsyncIterable(toBytes(input))
  }

  if (typeof input === 'string' || input instanceof String) {
    return toAsyncIterable(toBytes(input.toString()))
  }

  // Blob
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isBlob)(input)) {
    return blob_to_it__WEBPACK_IMPORTED_MODULE_3__(input)
  }

  // Browser stream
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isReadableStream)(input)) {
    input = browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__(input)
  }

  // (Async)Iterator<?>
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    /** @type {any} peekable */
    const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_4__(input)

    /** @type {any} value */
    const { value, done } = await peekable.peek()

    if (done) {
      // make sure empty iterators result in empty files
      return toAsyncIterable(new Uint8Array(0))
    }

    peekable.push(value)

    // (Async)Iterable<Number>
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await it_all__WEBPACK_IMPORTED_MODULE_5__(peekable)))
    }

    // (Async)Iterable<Bytes|String>
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isBytes)(value) || typeof value === 'string' || value instanceof String) {
      return it_map__WEBPACK_IMPORTED_MODULE_6__(peekable, toBytes)
    }
  }

  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')
}

/**
 * @param {ArrayBuffer | ArrayBufferView | string | InstanceType<typeof window.String> | number[]} chunk
 */
function toBytes (chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk
  }

  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength)
  }

  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk)
  }

  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk)
  }

  return (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(chunk.toString())
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseInput": function() { return /* binding */ normaliseInput; }
/* harmony export */ });
/* harmony import */ var _normalise_content_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalise-content.browser.js */ "./node_modules/ipfs-core-utils/src/files/normalise-content.browser.js");
/* harmony import */ var _normalise_candidate_multiple_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalise-candidate-multiple.js */ "./node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js");



/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 * @typedef {import('ipfs-core-types/src/utils').BrowserImportCandidate} BrowserImportCandidate
 */

/**
 * Transforms any of the `ipfs.addAll` input types into
 *
 * ```
 * AsyncIterable<{ path, mode, mtime, content: Blob }>
 * ```
 *
 * See https://github.com/ipfs/js-ipfs/blob/master/docs/core-api/FILES.md#ipfsadddata-options
 *
 * @param {ImportCandidateStream} input
 * @returns {AsyncGenerator<BrowserImportCandidate, void, undefined>}
 */
function normaliseInput (input) {
  // @ts-expect-error browser normaliseContent returns a Blob not an AsyncIterable<Uint8Array>
  return (0,_normalise_candidate_multiple_js__WEBPACK_IMPORTED_MODULE_1__.normaliseCandidateMultiple)(input, _normalise_content_browser_js__WEBPACK_IMPORTED_MODULE_0__.normaliseContent, true)
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-input-multiple.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-input-multiple.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseInput": function() { return /* binding */ normaliseInput; }
/* harmony export */ });
/* harmony import */ var _normalise_content_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalise-content.js */ "./node_modules/ipfs-core-utils/src/files/normalise-content.js");
/* harmony import */ var _normalise_candidate_multiple_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalise-candidate-multiple.js */ "./node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js");



/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 */

/**
 * Transforms any of the `ipfs.addAll` input types into
 *
 * ```
 * AsyncIterable<{ path, mode, mtime, content: AsyncIterable<Uint8Array> }>
 * ```
 *
 * See https://github.com/ipfs/js-ipfs/blob/master/docs/core-api/FILES.md#ipfsadddata-options
 *
 * @param {ImportCandidateStream} input
 */
function normaliseInput (input) {
  return (0,_normalise_candidate_multiple_js__WEBPACK_IMPORTED_MODULE_1__.normaliseCandidateMultiple)(input, _normalise_content_js__WEBPACK_IMPORTED_MODULE_0__.normaliseContent)
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/normalise-input-single.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/normalise-input-single.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseInput": function() { return /* binding */ normaliseInput; }
/* harmony export */ });
/* harmony import */ var _normalise_content_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalise-content.js */ "./node_modules/ipfs-core-utils/src/files/normalise-content.js");
/* harmony import */ var _normalise_candidate_single_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalise-candidate-single.js */ "./node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js");



/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidate} ImportCandidate
 */

/**
 * Transforms any of the `ipfs.add` input types into
 *
 * ```
 * AsyncIterable<{ path, mode, mtime, content: AsyncIterable<Uint8Array> }>
 * ```
 *
 * See https://github.com/ipfs/js-ipfs/blob/master/docs/core-api/FILES.md#ipfsadddata-options
 *
 * @param {ImportCandidate} input
 */
function normaliseInput (input) {
  return (0,_normalise_candidate_single_js__WEBPACK_IMPORTED_MODULE_1__.normaliseCandidateSingle)(input, _normalise_content_js__WEBPACK_IMPORTED_MODULE_0__.normaliseContent)
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/files/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/files/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isBytes": function() { return /* binding */ isBytes; },
/* harmony export */   "isBlob": function() { return /* binding */ isBlob; },
/* harmony export */   "isFileObject": function() { return /* binding */ isFileObject; },
/* harmony export */   "isReadableStream": function() { return /* binding */ isReadableStream; }
/* harmony export */ });
/**
 * @param {any} obj
 * @returns {obj is ArrayBufferView|ArrayBuffer}
 */
function isBytes (obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer
}

/**
 * @param {any} obj
 * @returns {obj is globalThis.Blob}
 */
function isBlob (obj) {
  return obj.constructor &&
    (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') &&
    typeof obj.stream === 'function'
}

/**
 * An object with a path or content property
 *
 * @param {any} obj
 * @returns {obj is import('ipfs-core-types/src/utils').ImportCandidate}
 */
function isFileObject (obj) {
  return typeof obj === 'object' && (obj.path || obj.content)
}

/**
 * @param {any} value
 * @returns {value is ReadableStream}
 */
const isReadableStream = (value) =>
  value && typeof value.getReader === 'function'


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/mode-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/mode-to-string.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "modeToString": function() { return /* binding */ modeToString; }
/* harmony export */ });

/**
 * @param {number | string | undefined} mode
 */
function modeToString (mode) {
  if (mode == null) {
    return undefined
  }

  if (typeof mode === 'string') {
    return mode
  }

  return mode.toString(8).padStart(4, '0')
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/multibases.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/multibases.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Multibases": function() { return /* binding */ Multibases; }
/* harmony export */ });
/**
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 * @typedef {import('./types').LoadBaseFn} LoadBaseFn
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */

/**
 * @type {LoadBaseFn}
 */
const LOAD_BASE = (name) => Promise.reject(new Error(`No base found for "${name}"`))

class Multibases {
  /**
   * @param {object} options
   * @param {LoadBaseFn} [options.loadBase]
   * @param {MultibaseCodec[]} options.bases
   */
  constructor (options) {
    // Object with current list of active resolvers
    /** @type {Record<string, MultibaseCodec>}} */
    this._basesByName = {}

    // Object with current list of active resolvers
    /** @type {Record<string, MultibaseCodec>}} */
    this._basesByPrefix = {}

    this._loadBase = options.loadBase || LOAD_BASE

    // Enable all supplied codecs
    for (const base of options.bases) {
      this.addBase(base)
    }
  }

  /**
   * Add support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  addBase (base) {
    if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {
      throw new Error(`Codec already exists for codec "${base.name}"`)
    }

    this._basesByName[base.name] = base
    this._basesByPrefix[base.prefix] = base
  }

  /**
   * Remove support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  removeBase (base) {
    delete this._basesByName[base.name]
    delete this._basesByPrefix[base.prefix]
  }

  /**
   * @param {string} nameOrPrefix
   */
  async getBase (nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix]
    }

    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix]
    }

    // If not supported, attempt to dynamically load this codec
    const base = await this._loadBase(nameOrPrefix)

    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {
      this.addBase(base)
    }

    return base
  }

  listBases () {
    return Object.values(this._basesByName)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/multicodecs.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/multicodecs.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Multicodecs": function() { return /* binding */ Multicodecs; }
/* harmony export */ });
/**
 * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec
 * @typedef {import('./types').LoadCodecFn} LoadCodecFn
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */

/**
 * @type {LoadCodecFn}
 */
const LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`))

class Multicodecs {
  /**
   * @param {object} options
   * @param {LoadCodecFn} [options.loadCodec]
   * @param {BlockCodec[]} options.codecs
   */
  constructor (options) {
    // Object with current list of active resolvers
    /** @type {Record<string, BlockCodec>}} */
    this._codecsByName = {}

    // Object with current list of active resolvers
    /** @type {Record<number, BlockCodec>}} */
    this._codecsByCode = {}

    this._loadCodec = options.loadCodec || LOAD_CODEC

    // Enable all supplied codecs
    for (const codec of options.codecs) {
      this.addCodec(codec)
    }
  }

  /**
   * Add support for a block codec
   *
   * @param {BlockCodec} codec
   */
  addCodec (codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`)
    }

    this._codecsByName[codec.name] = codec
    this._codecsByCode[codec.code] = codec
  }

  /**
   * Remove support for a block codec
   *
   * @param {BlockCodec} codec
   */
  removeCodec (codec) {
    delete this._codecsByName[codec.name]
    delete this._codecsByCode[codec.code]
  }

  /**
   * @param {number | string} code
   */
  async getCodec (code) {
    const table = typeof code === 'string' ? this._codecsByName : this._codecsByCode

    if (table[code]) {
      return table[code]
    }

    // If not supported, attempt to dynamically load this codec
    const codec = await this._loadCodec(code)

    if (table[code] == null) {
      this.addCodec(codec)
    }

    return codec
  }

  listCodecs () {
    return Object.values(this._codecsByName)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/multihashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/multihashes.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Multihashes": function() { return /* binding */ Multihashes; }
/* harmony export */ });
/**
 * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher
 * @typedef {import('./types').LoadHasherFn} LoadHasherFn
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */

/**
 * @type {LoadHasherFn}
 */
const LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`))

class Multihashes {
  /**
   * @param {object} options
   * @param {LoadHasherFn} [options.loadHasher]
   * @param {MultihashHasher[]} options.hashers
   */
  constructor (options) {
    // Object with current list of active hashers
    /** @type {Record<string, MultihashHasher>}} */
    this._hashersByName = {}

    // Object with current list of active hashers
    /** @type {Record<number, MultihashHasher>}} */
    this._hashersByCode = {}

    this._loadHasher = options.loadHasher || LOAD_HASHER

    // Enable all supplied hashers
    for (const hasher of options.hashers) {
      this.addHasher(hasher)
    }
  }

  /**
   * Add support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  addHasher (hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`)
    }

    this._hashersByName[hasher.name] = hasher
    this._hashersByCode[hasher.code] = hasher
  }

  /**
   * Remove support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  removeHasher (hasher) {
    delete this._hashersByName[hasher.name]
    delete this._hashersByCode[hasher.code]
  }

  /**
   * @param {number | string} code
   */
  async getHasher (code) {
    const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode

    if (table[code]) {
      return table[code]
    }

    // If not supported, attempt to dynamically load this hasher
    const hasher = await this._loadHasher(code)

    if (table[code] == null) {
      this.addHasher(hasher)
    }

    return hasher
  }

  listHashers () {
    return Object.values(this._hashersByName)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/multipart-request.browser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/multipart-request.browser.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multipartRequest": function() { return /* binding */ multipartRequest; }
/* harmony export */ });
/* harmony import */ var _files_normalise_input_multiple_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./files/normalise-input-multiple.browser.js */ "./node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js");
/* harmony import */ var _mode_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mode-to-string.js */ "./node_modules/ipfs-core-utils/src/mode-to-string.js");

// Import browser version otherwise electron-renderer will end up with node
// version and fail.



/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 */

/**
 * @param {ImportCandidateStream} source
 * @param {AbortController} abortController
 * @param {Headers|Record<string, string>} [headers]
 */
async function multipartRequest (source, abortController, headers = {}) {
  const parts = []
  const formData = new FormData()
  let index = 0
  let total = 0

  for await (const { content, path, mode, mtime } of (0,_files_normalise_input_multiple_browser_js__WEBPACK_IMPORTED_MODULE_0__.normaliseInput)(source)) {
    let fileSuffix = ''
    const type = content ? 'file' : 'dir'

    if (index > 0) {
      fileSuffix = `-${index}`
    }

    let fieldName = type + fileSuffix
    const qs = []

    if (mode !== null && mode !== undefined) {
      qs.push(`mode=${(0,_mode_to_string_js__WEBPACK_IMPORTED_MODULE_1__.modeToString)(mode)}`)
    }

    if ((mtime) != null) {
      const { secs, nsecs } = (mtime)

      qs.push(`mtime=${secs}`)

      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`)
      }
    }

    if (qs.length) {
      fieldName = `${fieldName}?${qs.join('&')}`
    }

    if (content) {
      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : undefined)
      const end = total + content.size
      parts.push({ name: path, start: total, end })
      total = end
    } else if (path != null) {
      formData.set(fieldName, new File([''], encodeURIComponent(path), { type: 'application/x-directory' }))
    } else {
      throw new Error('path or content or both must be set')
    }

    index++
  }

  return {
    total,
    parts,
    headers,
    body: formData
  }
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/multipart-request.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/multipart-request.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multipartRequest": function() { return /* binding */ multipartRequest; }
/* harmony export */ });
/* harmony import */ var ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-utils/src/env.js */ "ipfs-utils/src/env.js");
/* harmony import */ var _multipart_request_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./multipart-request.node.js */ "./node_modules/ipfs-core-utils/src/multipart-request.node.js");
/* harmony import */ var _multipart_request_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multipart-request.browser.js */ "./node_modules/ipfs-core-utils/src/multipart-request.browser.js");
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nanoid */ "./node_modules/ipfs-core-utils/node_modules/nanoid/index.js");





/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 */

/**
 * @param {ImportCandidateStream} source
 * @param {AbortController} abortController
 * @param {Headers|Record<string, string>} [headers]
 * @param {string} [boundary]
 */
async function multipartRequest (source, abortController, headers = {}, boundary = `-----------------------------${(0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)()}`) {
  let req = _multipart_request_node_js__WEBPACK_IMPORTED_MODULE_1__.multipartRequest

  // In electron-renderer we use native fetch and should encode body using native
  // form data.
  if (ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_0__.isElectronRenderer) {
    // @ts-expect-error types are different
    req = _multipart_request_browser_js__WEBPACK_IMPORTED_MODULE_2__.multipartRequest
  }

  return req(source, abortController, headers, boundary)
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/multipart-request.node.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/multipart-request.node.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multipartRequest": function() { return /* binding */ multipartRequest; }
/* harmony export */ });
/* harmony import */ var _files_normalise_input_multiple_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./files/normalise-input-multiple.js */ "./node_modules/ipfs-core-utils/src/files/normalise-input-multiple.js");
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! nanoid */ "./node_modules/ipfs-core-utils/node_modules/nanoid/index.js");
/* harmony import */ var _mode_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mode-to-string.js */ "./node_modules/ipfs-core-utils/src/mode-to-string.js");
/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! merge-options */ "merge-options");
/* harmony import */ var it_to_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-to-stream */ "it-to-stream");
/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/logger */ "./node_modules/@libp2p/logger/dist/src/index.js");
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! it-peekable */ "it-peekable");




// @ts-expect-error no types




const merge = merge_options__WEBPACK_IMPORTED_MODULE_2__.bind({ ignoreUndefined: true })
const log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_4__.logger)('ipfs:core-utils:multipart-request')

/**
 * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream
 */

/**
 * @param {ImportCandidateStream} source
 * @param {AbortController} abortController
 * @param {Headers|Record<string, string>} [headers]
 * @param {string} [boundary]
 */
async function multipartRequest (source, abortController, headers = {}, boundary = `-----------------------------${(0,nanoid__WEBPACK_IMPORTED_MODULE_6__.nanoid)()}`) {
  /**
   * @param {ImportCandidateStream} source
   */
  async function * streamFiles (source) {
    try {
      let index = 0

      // @ts-expect-error
      for await (const { content, path, mode, mtime } of source) {
        let fileSuffix = ''
        const type = content ? 'file' : 'dir'

        if (index > 0) {
          yield '\r\n'

          fileSuffix = `-${index}`
        }

        let fieldName = type + fileSuffix
        const qs = []

        if (mode !== null && mode !== undefined) {
          qs.push(`mode=${(0,_mode_to_string_js__WEBPACK_IMPORTED_MODULE_1__.modeToString)(mode)}`)
        }

        if (mtime != null) {
          const { secs, nsecs } = mtime

          qs.push(`mtime=${secs}`)

          if (nsecs != null) {
            qs.push(`mtime-nsecs=${nsecs}`)
          }
        }

        if (qs.length) {
          fieldName = `${fieldName}?${qs.join('&')}`
        }

        yield `--${boundary}\r\n`
        yield `Content-Disposition: form-data; name="${fieldName}"; filename="${encodeURIComponent(path || '')}"\r\n`
        yield `Content-Type: ${content ? 'application/octet-stream' : 'application/x-directory'}\r\n`
        yield '\r\n'

        if (content) {
          yield * content
        }

        index++
      }
    } catch (/** @type {any} */ err) {
      log(err)
      // workaround for https://github.com/node-fetch/node-fetch/issues/753
      abortController.abort()
    } finally {
      yield `\r\n--${boundary}--\r\n`
    }
  }

  // peek at the first value in order to get the input stream moving
  // and to validate its contents.
  // We cannot do this in the `for await..of` in streamFiles due to
  // https://github.com/node-fetch/node-fetch/issues/753
  const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_5__((0,_files_normalise_input_multiple_js__WEBPACK_IMPORTED_MODULE_0__.normaliseInput)(source))

  /** @type {any} value **/
  const { value, done } = await peekable.peek()

  if (!done) {
    peekable.push(value)
  }

  return {
    parts: null,
    total: -1,
    headers: merge(headers, {
      'Content-Type': `multipart/form-data; boundary=${boundary}`
    }),
    // @ts-expect-error normaliseInput returns unixfs importer import candidates
    body: it_to_stream__WEBPACK_IMPORTED_MODULE_3__(streamFiles(peekable))
  }
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/pins/normalise-input.js":
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/pins/normalise-input.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseInput": function() { return /* binding */ normaliseInput; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");



/**
 * @typedef {object} Pinnable
 * @property {string | InstanceType<typeof window.String> | CID} [path]
 * @property {CID} [cid]
 * @property {boolean} [recursive]
 * @property {any} [metadata]
 *
 * @typedef {CID|string|InstanceType<typeof window.String>|Pinnable} ToPin
 * @typedef {ToPin|Iterable<ToPin>|AsyncIterable<ToPin>} Source
 *
 * @typedef {object} Pin
 * @property {string|CID} path
 * @property {boolean} recursive
 * @property {any} [metadata]
 */

/**
 * Transform one of:
 *
 * ```ts
 * CID
 * String
 * { cid: CID recursive, metadata }
 * { path: String recursive, metadata }
 * Iterable<CID>
 * Iterable<String>
 * Iterable<{ cid: CID recursive, metadata }>
 * Iterable<{ path: String recursive, metadata }>
 * AsyncIterable<CID>
 * AsyncIterable<String>
 * AsyncIterable<{ cid: CID recursive, metadata }>
 * AsyncIterable<{ path: String recursive, metadata }>
 * ```
 * Into:
 *
 * ```ts
 * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>
 * ```
 *
 * @param {Source} input
 * @returns {AsyncIterable<Pin>}
 */
// eslint-disable-next-line complexity
async function * normaliseInput (input) {
  // must give us something
  if (input === null || input === undefined) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')
  }

  // CID
  const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(input)

  if (cid) {
    yield toPin({ cid })
    return
  }

  if (input instanceof String || typeof input === 'string') {
    yield toPin({ path: input })
    return
  }

  // { cid: CID recursive, metadata }
  // @ts-expect-error - it still could be iterable or async iterable
  if (input.cid != null || input.path != null) {
    // @ts-expect-error
    return yield toPin(input)
  }

  // Iterable<?>
  if (Symbol.iterator in input) {
    // @ts-expect-error
    const iterator = input[Symbol.iterator]()
    const first = iterator.next()
    if (first.done) return iterator

    // Iterable<CID|String>
    if (multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(first.value) || first.value instanceof String || typeof first.value === 'string') {
      yield toPin({ cid: first.value })
      for (const cid of iterator) {
        yield toPin({ cid })
      }
      return
    }

    // Iterable<{ cid: CID recursive, metadata }>
    if (first.value.cid != null || first.value.path != null) {
      yield toPin(first.value)
      for (const obj of iterator) {
        yield toPin(obj)
      }
      return
    }

    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')
  }

  // AsyncIterable<?>
  if (Symbol.asyncIterator in input) {
    // @ts-expect-error
    const iterator = input[Symbol.asyncIterator]()
    const first = await iterator.next()
    if (first.done) return iterator

    // AsyncIterable<CID|String>
    if (multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(first.value) || first.value instanceof String || typeof first.value === 'string') {
      yield toPin({ cid: first.value })
      for await (const cid of iterator) {
        yield toPin({ cid })
      }
      return
    }

    // AsyncIterable<{ cid: CID|String recursive, metadata }>
    if (first.value.cid != null || first.value.path != null) {
      yield toPin(first.value)
      for await (const obj of iterator) {
        yield toPin(obj)
      }
      return
    }

    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')
  }

  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')
}

/**
 * @param {Pinnable} input
 */
function toPin (input) {
  const path = input.cid || `${input.path}`

  if (!path) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: Please path either a CID or an IPFS path'), 'ERR_UNEXPECTED_INPUT')
  }

  /** @type {Pin} */
  const pin = {
    path,
    recursive: input.recursive !== false
  }

  if (input.metadata != null) {
    pin.metadata = input.metadata
  }

  return pin
}


/***/ }),

/***/ "./node_modules/ipfs-core-utils/src/to-url-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-core-utils/src/to-url-string.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toUrlString": function() { return /* binding */ toUrlString; }
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var _multiformats_multiaddr_to_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/multiaddr-to-uri */ "./node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js");



/**
 * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr
 */

/**
 * @param {string|Multiaddr|URL} url - A string, multiaddr or URL to convert to a url string
 * @returns {string}
 */
function toUrlString (url) {
  try {
    // @ts-expect-error
    url = (0,_multiformats_multiaddr_to_uri__WEBPACK_IMPORTED_MODULE_1__.multiaddrToUri)((0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(url))
  } catch (/** @type {any} */ err) { }

  url = url.toString()

  return url
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/add-all.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/add-all.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddAll": function() { return /* binding */ createAddAll; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");







/**
 * @typedef {import('ipfs-utils/src/types').ProgressFn} IPFSUtilsHttpUploadProgressFn
 * @typedef {import('ipfs-core-types/src/root').AddProgressFn} IPFSCoreAddProgressFn
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 * @typedef {import('ipfs-core-types/src/root').AddResult} AddResult
 */

const createAddAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)((api) => {
  /**
   * @type {RootAPI["addAll"]}
   */
  async function * addAll (source, options = {}) {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__.abortSignal)(controller.signal, options.signal)
    const { headers, body, total, parts } =
      await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__.multipartRequest)(source, controller, options.headers)

    // In browser response body only starts streaming once upload is
    // complete, at which point all the progress updates are invalid. If
    // length of the content is computable we can interpret progress from
    // `{ total, loaded}` passed to `onUploadProgress` and `multipart.total`
    // in which case we disable progress updates to be written out.
    const [progressFn, onUploadProgress] = typeof options.progress === 'function'
      ? createProgressHandler(total, parts, options.progress)
      : [undefined, undefined]

    const res = await api.post('add', {
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__.toUrlSearchParams)({
        'stream-channels': true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    })

    for await (let file of res.ndjson()) {
      file = (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel)(file)

      if (file.hash !== undefined) {
        yield toCoreInterface(file)
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name)
      }
    }
  }
  return addAll
})

/**
 * Returns simple progress callback when content length isn't computable or a
 * progress event handler that calculates progress from upload progress events.
 *
 * @param {number} total
 * @param {{name:string, start:number, end:number}[]|null} parts
 * @param {IPFSCoreAddProgressFn} progress
 * @returns {[IPFSCoreAddProgressFn|undefined, IPFSUtilsHttpUploadProgressFn|undefined]}
 */
const createProgressHandler = (total, parts, progress) =>
  parts ? [undefined, createOnUploadProgress(total, parts, progress)] : [progress, undefined]

/**
 * Creates a progress handler that interpolates progress from upload progress
 * events and total size of the content that is added.
 *
 * @param {number} size - actual content size
 * @param {{name:string, start:number, end:number}[]} parts
 * @param {IPFSCoreAddProgressFn} progress
 * @returns {IPFSUtilsHttpUploadProgressFn}
 */
const createOnUploadProgress = (size, parts, progress) => {
  let index = 0
  const count = parts.length
  return ({ loaded, total }) => {
    // Derive position from the current progress.
    const position = Math.floor(loaded / total * size)
    while (index < count) {
      const { start, end, name } = parts[index]
      // If within current part range report progress and break the loop
      if (position < end) {
        progress(position - start, name)
        break
      // If passed current part range report final byte for the chunk and
      // move to next one.
      } else {
        progress(end - start, name)
        index += 1
      }
    }
  }
}

/**
 * @param {object} input
 * @param {string} input.name
 * @param {string} input.hash
 * @param {string} input.size
 * @param {string} [input.mode]
 * @param {number} [input.mtime]
 * @param {number} [input.mtimeNsecs]
 */
function toCoreInterface ({ name, hash, size, mode, mtime, mtimeNsecs }) {
  /** @type {AddResult} */
  const output = {
    path: name,
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(hash),
    size: parseInt(size)
  }

  if (mode != null) {
    output.mode = parseInt(mode, 8)
  }

  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    }
  }

  return output
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/add.js":
/*!**************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/add.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": function() { return /* binding */ createAdd; }
/* harmony export */ });
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-all.js */ "./node_modules/ipfs-http-client/src/add-all.js");
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ "it-last");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var ipfs_core_utils_files_normalise_input_single__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/files/normalise-input-single */ "./node_modules/ipfs-core-utils/src/files/normalise-input-single.js");





/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

/**
 * @param {import('./types').Options} options
 */
function createAdd (options) {
  const all = (0,_add_all_js__WEBPACK_IMPORTED_MODULE_0__.createAddAll)(options)
  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(() => {
    /**
     * @type {RootAPI["add"]}
     */
    async function add (input, options = {}) {
      // @ts-expect-error - last may return undefined if source is empty
      return await it_last__WEBPACK_IMPORTED_MODULE_1__(all((0,ipfs_core_utils_files_normalise_input_single__WEBPACK_IMPORTED_MODULE_3__.normaliseInput)(input), options))
    }
    return add
  })(options)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bitswap/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bitswap/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBitswap": function() { return /* binding */ createBitswap; }
/* harmony export */ });
/* harmony import */ var _wantlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wantlist.js */ "./node_modules/ipfs-http-client/src/bitswap/wantlist.js");
/* harmony import */ var _wantlist_for_peer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wantlist-for-peer.js */ "./node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js");
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat.js */ "./node_modules/ipfs-http-client/src/bitswap/stat.js");
/* harmony import */ var _unwant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unwant.js */ "./node_modules/ipfs-http-client/src/bitswap/unwant.js");





/**
 * @param {import('../types').Options} config
 */
function createBitswap (config) {
  return {
    wantlist: (0,_wantlist_js__WEBPACK_IMPORTED_MODULE_0__.createWantlist)(config),
    wantlistForPeer: (0,_wantlist_for_peer_js__WEBPACK_IMPORTED_MODULE_1__.createWantlistForPeer)(config),
    unwant: (0,_unwant_js__WEBPACK_IMPORTED_MODULE_3__.createUnwant)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_2__.createStat)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bitswap/stat.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bitswap/stat.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": function() { return /* binding */ createStat; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-id */ "./node_modules/@libp2p/peer-id/dist/src/index.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI
 */

const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {BitswapAPI["stat"]}
   */
  async function stat (options = {}) {
    const res = await api.post('bitswap/stat', {
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      signal: options.signal,
      headers: options.headers
    })

    return toCoreInterface(await res.json())
  }
  return stat
})

/**
 * @param {any} res
 */
function toCoreInterface (res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((/** @type {{ '/': string }} */ k) => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(k['/'])),
    peers: (res.Peers || []).map((/** @type {string} */ str) => (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bitswap/unwant.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bitswap/unwant.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createUnwant": function() { return /* binding */ createUnwant; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI
 */

const createUnwant = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BitswapAPI["unwant"]}
   */
  async function unwant (cid, options = {}) {
    const res = await api.post('bitswap/unwant', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    })

    return res.json()
  }
  return unwant
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js":
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWantlistForPeer": function() { return /* binding */ createWantlistForPeer; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI
 */

const createWantlistForPeer = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {BitswapAPI["wantlistForPeer"]}
   */
  async function wantlistForPeer (peerId, options = {}) {
    const res = await (await api.post('bitswap/wantlist', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json()

    return (res.Keys || []).map((/** @type {{ '/': string }} */ k) => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(k['/']))
  }
  return wantlistForPeer
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bitswap/wantlist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bitswap/wantlist.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWantlist": function() { return /* binding */ createWantlist; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI
 */

const createWantlist = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {BitswapAPI["wantlist"]}
   */
  async function wantlist (options = {}) {
    const res = await (await api.post('bitswap/wantlist', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })).json()

    return (res.Keys || []).map((/** @type {{ '/': string }} */ k) => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(k['/']))
  }
  return wantlist
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/block/get.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/block/get.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": function() { return /* binding */ createGet; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI
 */

const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BlockAPI["get"]}
   */
  async function get (cid, options = {}) {
    const res = await api.post('block/get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    })

    return new Uint8Array(await res.arrayBuffer())
  }
  return get
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/block/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/block/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBlock": function() { return /* binding */ createBlock; }
/* harmony export */ });
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get.js */ "./node_modules/ipfs-http-client/src/block/get.js");
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./put.js */ "./node_modules/ipfs-http-client/src/block/put.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/block/rm.js");
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stat.js */ "./node_modules/ipfs-http-client/src/block/stat.js");





/**
 * @param {import('../types').Options} config
 */
function createBlock (config) {
  return {
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_0__.createGet)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_1__.createPut)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_2__.createRm)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_3__.createStat)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/block/put.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/block/put.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": function() { return /* binding */ createPut; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");






/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI
 */

const createPut = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {BlockAPI["put"]}
   */
  async function put (data, options = {}) {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal)

    let res
    try {
      const response = await api.post('block/put', {
        signal: signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)(options),
        ...(
          await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)([data], controller, options.headers)
        )
      })
      res = await response.json()
    } catch (/** @type {any} */ err) {
      // Retry with "protobuf"/"cbor" format for go-ipfs
      // TODO: remove when https://github.com/ipfs/go-cid/issues/75 resolved
      if (options.format === 'dag-pb') {
        return put(data, { ...options, format: 'protobuf' })
      } else if (options.format === 'dag-cbor') {
        return put(data, { ...options, format: 'cbor' })
      }

      throw err
    }

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(res.Key)
  }

  return put
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/block/rm.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/block/rm.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI
 * @typedef {import('ipfs-core-types/src/block').RmResult} RmResult
 */

const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {BlockAPI["rm"]}
   */
  async function * rm (cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid]
    }

    const res = await api.post('block/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: cid.map(cid => cid.toString()),
        'stream-channels': true,
        ...options
      }),
      headers: options.headers
    })

    for await (const removed of res.ndjson()) {
      yield toCoreInterface(removed)
    }
  }

  return rm
})

/**
 * @param {*} removed
 */
function toCoreInterface (removed) {
  /** @type {RmResult} */
  const out = {
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(removed.Hash)
  }

  if (removed.Error) {
    out.error = new Error(removed.Error)
  }

  return out
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/block/stat.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/block/stat.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": function() { return /* binding */ createStat; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI
 */

const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {BlockAPI["stat"]}
   */
  async function stat (cid, options = {}) {
    const res = await api.post('block/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return { cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Key), size: data.Size }
  }

  return stat
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bootstrap/add.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bootstrap/add.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": function() { return /* binding */ createAdd; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI
 */

const createAdd = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BootstrapAPI["add"]}
   */
  async function add (addr, options = {}) {
    const res = await api.post('bootstrap/add', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    })

    const { Peers } = await res.json()

    return { Peers: Peers.map((/** @type {string} */ ma) => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(ma)) }
  }

  return add
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bootstrap/clear.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bootstrap/clear.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createClear": function() { return /* binding */ createClear; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI
 */

const createClear = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BootstrapAPI["clear"]}
   */
  async function clear (options = {}) {
    const res = await api.post('bootstrap/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        ...options,
        all: true
      }),
      headers: options.headers
    })

    const { Peers } = await res.json()

    return { Peers: Peers.map((/** @type {string} */ ma) => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(ma)) }
  }

  return clear
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bootstrap/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bootstrap/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBootstrap": function() { return /* binding */ createBootstrap; }
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add.js */ "./node_modules/ipfs-http-client/src/bootstrap/add.js");
/* harmony import */ var _clear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clear.js */ "./node_modules/ipfs-http-client/src/bootstrap/clear.js");
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./list.js */ "./node_modules/ipfs-http-client/src/bootstrap/list.js");
/* harmony import */ var _reset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reset.js */ "./node_modules/ipfs-http-client/src/bootstrap/reset.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/bootstrap/rm.js");






/**
 * @param {import('../types').Options} config
 */
function createBootstrap (config) {
  return {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_0__.createAdd)(config),
    clear: (0,_clear_js__WEBPACK_IMPORTED_MODULE_1__.createClear)(config),
    list: (0,_list_js__WEBPACK_IMPORTED_MODULE_2__.createList)(config),
    reset: (0,_reset_js__WEBPACK_IMPORTED_MODULE_3__.createReset)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_4__.createRm)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bootstrap/list.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bootstrap/list.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createList": function() { return /* binding */ createList; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI
 */

const createList = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BootstrapAPI["list"]}
   */
  async function list (options = {}) {
    const res = await api.post('bootstrap/list', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    const { Peers } = await res.json()

    return { Peers: Peers.map((/** @type {string} */ ma) => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(ma)) }
  }

  return list
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bootstrap/reset.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bootstrap/reset.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createReset": function() { return /* binding */ createReset; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI
 */

const createReset = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BootstrapAPI["reset"]}
   */
  async function reset (options = {}) {
    const res = await api.post('bootstrap/add', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        ...options,
        default: true
      }),
      headers: options.headers
    })

    const { Peers } = await res.json()

    return { Peers: Peers.map((/** @type {string} */ ma) => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(ma)) }
  }

  return reset
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/bootstrap/rm.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/bootstrap/rm.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI
 */

const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {BootstrapAPI["rm"]}
   */
  async function rm (addr, options = {}) {
    const res = await api.post('bootstrap/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    })

    const { Peers } = await res.json()

    return { Peers: Peers.map((/** @type {string} */ ma) => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(ma)) }
  }

  return rm
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/cat.js":
/*!**************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/cat.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCat": function() { return /* binding */ createCat; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createCat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RootAPI["cat"]}
   */
  async function * cat (path, options = {}) {
    const res = await api.post('cat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path.toString(),
        ...options
      }),
      headers: options.headers
    })

    yield * res.iterator()
  }

  return cat
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/commands.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/commands.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCommands": function() { return /* binding */ createCommands; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createCommands = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RootAPI["commands"]}
   */
  const commands = async (options = {}) => {
    const res = await api.post('commands', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    return res.json()
  }
  return commands
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/get-all.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/get-all.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGetAll": function() { return /* binding */ createGetAll; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI
 */

const createGetAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {ConfigAPI["getAll"]}
   */
  const getAll = async (options = {}) => {
    const res = await api.post('config/show', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return data
  }

  return getAll
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/get.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/get.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": function() { return /* binding */ createGet; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI
 */

const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {ConfigAPI["get"]}
   */
  const get = async (key, options = {}) => {
    if (!key) {
      throw new Error('key argument is required')
    }

    const res = await api.post('config', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: key,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return data.Value
  }

  return get
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createConfig": function() { return /* binding */ createConfig; }
/* harmony export */ });
/* harmony import */ var _profiles_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./profiles/index.js */ "./node_modules/ipfs-http-client/src/config/profiles/index.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ "./node_modules/ipfs-http-client/src/config/get.js");
/* harmony import */ var _get_all_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-all.js */ "./node_modules/ipfs-http-client/src/config/get-all.js");
/* harmony import */ var _replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./replace.js */ "./node_modules/ipfs-http-client/src/config/replace.js");
/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./set.js */ "./node_modules/ipfs-http-client/src/config/set.js");






/**
 * @param {import('../types').Options} config
 */
function createConfig (config) {
  return {
    getAll: (0,_get_all_js__WEBPACK_IMPORTED_MODULE_2__.createGetAll)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_1__.createGet)(config),
    set: (0,_set_js__WEBPACK_IMPORTED_MODULE_4__.createSet)(config),
    replace: (0,_replace_js__WEBPACK_IMPORTED_MODULE_3__.createReplace)(config),
    profiles: (0,_profiles_index_js__WEBPACK_IMPORTED_MODULE_0__.createProfiles)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/profiles/apply.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/profiles/apply.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createApply": function() { return /* binding */ createApply; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/config/profiles').API<HTTPClientExtraOptions>} ConfigProfilesAPI
 */

const createApply = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {ConfigProfilesAPI["apply"]}
   */
  async function apply (profile, options = {}) {
    const res = await api.post('config/profile/apply', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: profile,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return {
      original: data.OldCfg, updated: data.NewCfg
    }
  }

  return apply
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/profiles/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/profiles/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProfiles": function() { return /* binding */ createProfiles; }
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apply.js */ "./node_modules/ipfs-http-client/src/config/profiles/apply.js");
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./list.js */ "./node_modules/ipfs-http-client/src/config/profiles/list.js");



/**
 * @param {import('../../types').Options} config
 */
function createProfiles (config) {
  return {
    apply: (0,_apply_js__WEBPACK_IMPORTED_MODULE_0__.createApply)(config),
    list: (0,_list_js__WEBPACK_IMPORTED_MODULE_1__.createList)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/profiles/list.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/profiles/list.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createList": function() { return /* binding */ createList; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/config/profiles').API<HTTPClientExtraOptions>} ConfigProfilesAPI
 */

const createList = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ConfigProfilesAPI["list"]}
   */
  async function list (options = {}) {
    const res = await api.post('config/profile/list', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    const data = await res.json()

    return data.map((/** @type {Record<string, any>} */ profile) => (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(profile))
  }
  return list
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/replace.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/replace.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createReplace": function() { return /* binding */ createReplace; }
/* harmony export */ });
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ "uint8arrays/from-string");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");






/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI
 */

const createReplace = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {ConfigAPI["replace"]}
   */
  const replace = async (config, options = {}) => {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal)

    const res = await api.post('config/replace', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)(options),
      ...(
        await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)([(0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(JSON.stringify(config))], controller, options.headers)
      )
    })

    await res.text()
  }

  return replace
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/config/set.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/config/set.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSet": function() { return /* binding */ createSet; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI
 */

const createSet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {ConfigAPI["set"]}
   */
  const set = async (key, value, options = {}) => {
    if (typeof key !== 'string') {
      throw new Error('Invalid key type')
    }

    const params = {
      ...options,
      ...encodeParam(key, value)
    }

    const res = await api.post('config', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(params),
      headers: options.headers
    })

    await res.text()
  }

  return set
})

/**
 * @param {*} key
 * @param {*} value
 */
const encodeParam = (key, value) => {
  switch (typeof value) {
    case 'boolean':
      return { arg: [key, value.toString()], bool: true }
    case 'string':
      return { arg: [key, value] }
    default:
      return { arg: [key, JSON.stringify(value)], json: true }
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dag/export.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dag/export.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createExport": function() { return /* binding */ createExport; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI
 */

const createExport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DAGAPI["export"]}
   */
  async function * dagExport (root, options = {}) {
    const res = await api.post('dag/export', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: root.toString()
      }),
      headers: options.headers
    })

    yield * res.iterator()
  }

  return dagExport
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dag/get.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dag/get.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": function() { return /* binding */ createGet; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_resolve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/resolve.js */ "./node_modules/ipfs-http-client/src/lib/resolve.js");
/* harmony import */ var it_first__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-first */ "it-first");
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-last */ "it-last");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var _block_get_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../block/get.js */ "./node_modules/ipfs-http-client/src/block/get.js");







/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI
 */

/**
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
 * @param {import('../types').Options} options
 */
const createGet = (codecs, options) => {
  const fn = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)((api, opts) => {
    const getBlock = (0,_block_get_js__WEBPACK_IMPORTED_MODULE_5__.createGet)(opts)

    /**
     * @type {DAGAPI["get"]}
     */
    const get = async (cid, options = {}) => {
      if (options.path) {
        const entry = options.localResolve
          ? await it_first__WEBPACK_IMPORTED_MODULE_2__((0,_lib_resolve_js__WEBPACK_IMPORTED_MODULE_1__.resolve)(cid, options.path, codecs, getBlock, options))
          : await it_last__WEBPACK_IMPORTED_MODULE_3__((0,_lib_resolve_js__WEBPACK_IMPORTED_MODULE_1__.resolve)(cid, options.path, codecs, getBlock, options))
        /** @type {import('ipfs-core-types/src/dag').GetResult | undefined} - first and last will return undefined when empty */
        const result = (entry)

        if (!result) {
          throw err_code__WEBPACK_IMPORTED_MODULE_4__(new Error('Not found'), 'ERR_NOT_FOUND')
        }

        return result
      }

      const codec = await codecs.getCodec(cid.code)
      const block = await getBlock(cid, options)
      const node = codec.decode(block)

      return {
        value: node,
        remainderPath: ''
      }
    }

    return get
  })

  return fn(options)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dag/import.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dag/import.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createImport": function() { return /* binding */ createImport; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");






/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI
 */

const createImport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DAGAPI["import"]}
   */
  async function * dagImport (source, options = {}) {
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_2__.abortSignal)(controller.signal, options.signal)
    const { headers, body } = await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__.multipartRequest)(source, controller, options.headers)

    const res = await api.post('dag/import', {
      signal,
      headers,
      body,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({ 'pin-roots': options.pinRoots })
    })

    for await (const { Root } of res.ndjson()) {
      if (Root !== undefined) {
        const { Cid: { '/': Cid }, PinErrorMsg } = Root

        yield {
          root: {
            cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_4__.CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        }
      }
    }
  }

  return dagImport
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dag/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dag/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDag": function() { return /* binding */ createDag; }
/* harmony export */ });
/* harmony import */ var _export_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./export.js */ "./node_modules/ipfs-http-client/src/dag/export.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ "./node_modules/ipfs-http-client/src/dag/get.js");
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./import.js */ "./node_modules/ipfs-http-client/src/dag/import.js");
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./put.js */ "./node_modules/ipfs-http-client/src/dag/put.js");
/* harmony import */ var _resolve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolve.js */ "./node_modules/ipfs-http-client/src/dag/resolve.js");






/**
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
 * @param {import('../types').Options} config
 */
function createDag (codecs, config) {
  return {
    export: (0,_export_js__WEBPACK_IMPORTED_MODULE_0__.createExport)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_1__.createGet)(codecs, config),
    import: (0,_import_js__WEBPACK_IMPORTED_MODULE_2__.createImport)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_3__.createPut)(codecs, config),
    resolve: (0,_resolve_js__WEBPACK_IMPORTED_MODULE_4__.createResolve)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dag/put.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dag/put.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": function() { return /* binding */ createPut; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");






/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI
 */

/**
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
 * @param {import('../types').Options} options
 */
const createPut = (codecs, options) => {
  const fn = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)((api) => {
    /**
     * @type {DAGAPI["put"]}
     */
    const put = async (dagNode, options = {}) => {
      const settings = {
        storeCodec: 'dag-cbor',
        hashAlg: 'sha2-256',
        ...options
      }

      let serialized

      if (settings.inputCodec) {
        // if you supply an inputCodec, we assume you're passing in a raw, encoded
        // block using that codec, so we'll just pass that on to the server and let
        // it deal with the decode/encode/store cycle
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error('Can only inputCodec on raw bytes that can be decoded')
        }
        serialized = dagNode
      } else {
        // if you don't supply an inputCodec, we assume you've passed in a JavaScript
        // object you want to have encoded using storeCodec, so we'll prepare it for
        // you if we have the codec
        const storeCodec = await codecs.getCodec(settings.storeCodec)
        serialized = storeCodec.encode(dagNode)
        // now we have a serialized form, the server should be told to receive it
        // in that format
        settings.inputCodec = settings.storeCodec
      }

      // allow aborting requests on body errors
      const controller = new AbortController()
      const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, settings.signal)

      const res = await api.post('dag/put', {
        timeout: settings.timeout,
        signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)(settings),
        ...(
          await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__.multipartRequest)([serialized], controller, settings.headers)
        )
      })
      const data = await res.json()

      return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Cid['/'])
    }

    return put
  })

  return fn(options)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dag/resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dag/resolve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createResolve": function() { return /* binding */ createResolve; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI
 */

const createResolve = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {DAGAPI["resolve"]}
   */
  const resolve = async (ipfsPath, options = {}) => {
    const res = await api.post('dag/resolve', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\/[/]+/g, '/') : ''}`,
        ...options
      }),
      headers: options.headers
    })

    const data = await res.json()

    return { cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Cid['/']), remainderPath: data.RemPath }
  }

  return resolve
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/find-peer.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/find-peer.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFindPeer": function() { return /* binding */ createFindPeer; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _map_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-event.js */ "./node_modules/ipfs-http-client/src/dht/map-event.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI
 */

const createFindPeer = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DHTAPI["findPeer"]}
   */
  async function * findPeer (peerId, options = {}) {
    const res = await api.post('dht/findpeer', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    })

    for await (const event of res.ndjson()) {
      yield (0,_map_event_js__WEBPACK_IMPORTED_MODULE_2__.mapEvent)(event)
    }
  }

  return findPeer
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/find-provs.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/find-provs.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFindProvs": function() { return /* binding */ createFindProvs; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _map_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-event.js */ "./node_modules/ipfs-http-client/src/dht/map-event.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI
 */

const createFindProvs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DHTAPI["findProvs"]}
   */
  async function * findProvs (cid, options = {}) {
    const res = await api.post('dht/findprovs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    })

    for await (const event of res.ndjson()) {
      yield (0,_map_event_js__WEBPACK_IMPORTED_MODULE_2__.mapEvent)(event)
    }
  }

  return findProvs
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/get.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/get.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": function() { return /* binding */ createGet; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _map_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-event.js */ "./node_modules/ipfs-http-client/src/dht/map-event.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/to-string */ "uint8arrays/to-string");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI
 */

const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DHTAPI["get"]}
   */
  async function * get (key, options = {}) {
    const res = await api.post('dht/get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        // arg: base36.encode(key),
        arg: key instanceof Uint8Array ? (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    })

    for await (const event of res.ndjson()) {
      yield (0,_map_event_js__WEBPACK_IMPORTED_MODULE_2__.mapEvent)(event)
    }
  }

  return get
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDht": function() { return /* binding */ createDht; }
/* harmony export */ });
/* harmony import */ var _find_peer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find-peer.js */ "./node_modules/ipfs-http-client/src/dht/find-peer.js");
/* harmony import */ var _find_provs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./find-provs.js */ "./node_modules/ipfs-http-client/src/dht/find-provs.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get.js */ "./node_modules/ipfs-http-client/src/dht/get.js");
/* harmony import */ var _provide_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provide.js */ "./node_modules/ipfs-http-client/src/dht/provide.js");
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./put.js */ "./node_modules/ipfs-http-client/src/dht/put.js");
/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./query.js */ "./node_modules/ipfs-http-client/src/dht/query.js");







/**
 * @param {import('../types').Options} config
 */
function createDht (config) {
  return {
    findPeer: (0,_find_peer_js__WEBPACK_IMPORTED_MODULE_0__.createFindPeer)(config),
    findProvs: (0,_find_provs_js__WEBPACK_IMPORTED_MODULE_1__.createFindProvs)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_2__.createGet)(config),
    provide: (0,_provide_js__WEBPACK_IMPORTED_MODULE_3__.createProvide)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_4__.createPut)(config),
    query: (0,_query_js__WEBPACK_IMPORTED_MODULE_5__.createQuery)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/map-event.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/map-event.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapEvent": function() { return /* binding */ mapEvent; }
/* harmony export */ });
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ "uint8arrays/from-string");
/* harmony import */ var _response_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./response-types.js */ "./node_modules/ipfs-http-client/src/dht/response-types.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-id */ "./node_modules/@libp2p/peer-id/dist/src/index.js");





/**
 * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId
 * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr
 */

/**
 * @param {{Type: number, ID: string, Extra: string, Responses: {ID: string, Addrs: string[]}[]}} event
 * @returns {import('ipfs-core-types/src/dht').QueryEvent}
 */
const mapEvent = (event) => {
  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.SendingQuery) {
    return {
      name: 'SENDING_QUERY',
      type: event.Type
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.PeerResponse) {
    return {
      from: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(event.ID),
      name: 'PEER_RESPONSE',
      type: event.Type,
      // TODO: how to infer this from the go-ipfs response
      messageType: 0,
      // TODO: how to infer this from the go-ipfs response
      messageName: 'PUT_VALUE',
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(ID), multiaddrs: Addrs.map(addr => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(ID), multiaddrs: Addrs.map(addr => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(addr)), protocols: [] }))
      // TODO: how to infer this from the go-ipfs response
      // record: ???
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.FinalPeer) {
    // dht.query ends with a FinalPeer event with no Responses
    /** @type {import('@libp2p/interface-peer-info').PeerInfo} */
    let peer = {
      // @ts-expect-error go-ipfs does not return this
      id: event.ID ?? (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(event.ID),
      /** @type {Multiaddr[]} */
      multiaddrs: [],
      protocols: []
    }

    if (event.Responses && event.Responses.length) {
      // dht.findPeer has the result in the Responses field
      peer = {
        id: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map(addr => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(addr)),
        protocols: []
      }
    }

    return {
      name: 'FINAL_PEER',
      type: event.Type,
      peer
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.QueryError) {
    return {
      name: 'QUERY_ERROR',
      type: event.Type,
      error: new Error(event.Extra)
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.Provider) {
    return {
      name: 'PROVIDER',
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(ID), multiaddrs: Addrs.map(addr => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_2__.multiaddr)(addr)), protocols: [] }))
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.Value) {
    return {
      name: 'VALUE',
      type: event.Type,
      value: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(event.Extra, 'base64pad')
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.AddingPeer) {
    const peers = event.Responses.map(({ ID }) => (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(ID))

    if (!peers.length) {
      throw new Error('No peer found')
    }

    return {
      name: 'ADDING_PEER',
      type: event.Type,
      peer: peers[0]
    }
  }

  if (event.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_1__.DialingPeer) {
    return {
      name: 'DIALING_PEER',
      type: event.Type,
      peer: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(event.ID)
    }
  }

  throw new Error('Unknown DHT event type')
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/provide.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/provide.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProvide": function() { return /* binding */ createProvide; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _map_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-event.js */ "./node_modules/ipfs-http-client/src/dht/map-event.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI
 * @typedef {import('multiformats/cid').CID} CID
 */

const createProvide = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DHTAPI["provide"]}
   */
  async function * provide (cids, options = { recursive: false }) {
    /** @type {CID[]} */
    const cidArr = Array.isArray(cids) ? cids : [cids]

    const res = await api.post('dht/provide', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: cidArr.map(cid => cid.toString()),
        ...options
      }),
      headers: options.headers
    })

    for await (const event of res.ndjson()) {
      yield (0,_map_event_js__WEBPACK_IMPORTED_MODULE_2__.mapEvent)(event)
    }
  }

  return provide
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/put.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/put.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": function() { return /* binding */ createPut; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uint8arrays/to-string */ "uint8arrays/to-string");
/* harmony import */ var _map_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./map-event.js */ "./node_modules/ipfs-http-client/src/dht/map-event.js");







/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI
 */

const createPut = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DHTAPI["put"]}
   */
  async function * put (key, value, options = {}) {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_3__.abortSignal)(controller.signal, options.signal)

    const res = await api.post('dht/put', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: key instanceof Uint8Array ? (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_4__.toString)(key) : key.toString(),
        ...options
      }),
      ...(
        await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__.multipartRequest)([value], controller, options.headers)
      )
    })

    for await (const event of res.ndjson()) {
      yield (0,_map_event_js__WEBPACK_IMPORTED_MODULE_5__.mapEvent)(event)
    }
  }

  return put
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/query.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/query.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createQuery": function() { return /* binding */ createQuery; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _map_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-event.js */ "./node_modules/ipfs-http-client/src/dht/map-event.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI
 */

const createQuery = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DHTAPI["query"]}
   */
  async function * query (peerId, options = {}) {
    const res = await api.post('dht/query', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    })

    for await (const event of res.ndjson()) {
      yield (0,_map_event_js__WEBPACK_IMPORTED_MODULE_2__.mapEvent)(event)
    }
  }

  return query
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dht/response-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dht/response-types.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SendingQuery": function() { return /* binding */ SendingQuery; },
/* harmony export */   "PeerResponse": function() { return /* binding */ PeerResponse; },
/* harmony export */   "FinalPeer": function() { return /* binding */ FinalPeer; },
/* harmony export */   "QueryError": function() { return /* binding */ QueryError; },
/* harmony export */   "Provider": function() { return /* binding */ Provider; },
/* harmony export */   "Value": function() { return /* binding */ Value; },
/* harmony export */   "AddingPeer": function() { return /* binding */ AddingPeer; },
/* harmony export */   "DialingPeer": function() { return /* binding */ DialingPeer; }
/* harmony export */ });

// Response types are defined here =
// https://github.com/libp2p/go-libp2p-core/blob/6e566d10f4a5447317a66d64c7459954b969bdab/routing/query.go#L15-L24
const SendingQuery = 0
const PeerResponse = 1
const FinalPeer = 2
const QueryError = 3
const Provider = 4
const Value = 5
const AddingPeer = 6
const DialingPeer = 7


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/diag/cmds.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/diag/cmds.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCmds": function() { return /* binding */ createCmds; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/diag').API<HTTPClientExtraOptions>} DiagAPI
 */

const createCmds = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DiagAPI["cmds"]}
   */
  async function cmds (options = {}) {
    const res = await api.post('diag/cmds', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    return res.json()
  }
  return cmds
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/diag/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/diag/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDiag": function() { return /* binding */ createDiag; }
/* harmony export */ });
/* harmony import */ var _cmds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cmds.js */ "./node_modules/ipfs-http-client/src/diag/cmds.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./net.js */ "./node_modules/ipfs-http-client/src/diag/net.js");
/* harmony import */ var _sys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sys.js */ "./node_modules/ipfs-http-client/src/diag/sys.js");




/**
 * @param {import('../types').Options} config
 */
function createDiag (config) {
  return {
    cmds: (0,_cmds_js__WEBPACK_IMPORTED_MODULE_0__.createCmds)(config),
    net: (0,_net_js__WEBPACK_IMPORTED_MODULE_1__.createNet)(config),
    sys: (0,_sys_js__WEBPACK_IMPORTED_MODULE_2__.createSys)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/diag/net.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/diag/net.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createNet": function() { return /* binding */ createNet; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/diag').API<HTTPClientExtraOptions>} DiagAPI
 */

const createNet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DiagAPI["net"]}
   */
  async function net (options = {}) {
    const res = await api.post('diag/net', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })
    return res.json()
  }
  return net
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/diag/sys.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/diag/sys.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSys": function() { return /* binding */ createSys; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/diag').API<HTTPClientExtraOptions>} DiagAPI
 */

const createSys = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {DiagAPI["sys"]}
   */
  async function sys (options = {}) {
    const res = await api.post('diag/sys', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    return res.json()
  }
  return sys
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/dns.js":
/*!**************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/dns.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDns": function() { return /* binding */ createDns; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createDns = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RootAPI["dns"]}
   */
  const dns = async (domain, options = {}) => {
    const res = await api.post('dns', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: domain,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return data.Path
  }

  return dns
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/chmod.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/chmod.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createChmod": function() { return /* binding */ createChmod; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createChmod = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {FilesAPI["chmod"]}
   */
  async function chmod (path, mode, options = {}) {
    const res = await api.post('files/chmod', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        mode,
        ...options
      }),
      headers: options.headers
    })

    await res.text()
  }
  return chmod
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/cp.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/cp.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCp": function() { return /* binding */ createCp; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createCp = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {FilesAPI["cp"]}
   */
  async function cp (sources, destination, options = {}) {
    /** @type {import('ipfs-core-types/src/utils').IPFSPath[]} */
    const sourceArr = Array.isArray(sources) ? sources : [sources]

    const res = await api.post('files/cp', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: sourceArr.concat(destination).map(src => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(src) ? `/ipfs/${src}` : src),
        ...options
      }),
      headers: options.headers
    })

    await res.text()
  }
  return cp
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/flush.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/flush.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFlush": function() { return /* binding */ createFlush; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createFlush = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {FilesAPI["flush"]}
   */
  async function flush (path, options = {}) {
    if (!path || typeof path !== 'string') {
      throw new Error('ipfs.files.flush requires a path')
    }

    const res = await api.post('files/flush', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Cid)
  }
  return flush
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFiles": function() { return /* binding */ createFiles; }
/* harmony export */ });
/* harmony import */ var _chmod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chmod.js */ "./node_modules/ipfs-http-client/src/files/chmod.js");
/* harmony import */ var _cp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp.js */ "./node_modules/ipfs-http-client/src/files/cp.js");
/* harmony import */ var _flush_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flush.js */ "./node_modules/ipfs-http-client/src/files/flush.js");
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/files/ls.js");
/* harmony import */ var _mkdir_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mkdir.js */ "./node_modules/ipfs-http-client/src/files/mkdir.js");
/* harmony import */ var _mv_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mv.js */ "./node_modules/ipfs-http-client/src/files/mv.js");
/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./read.js */ "./node_modules/ipfs-http-client/src/files/read.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/files/rm.js");
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stat.js */ "./node_modules/ipfs-http-client/src/files/stat.js");
/* harmony import */ var _touch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./touch.js */ "./node_modules/ipfs-http-client/src/files/touch.js");
/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./write.js */ "./node_modules/ipfs-http-client/src/files/write.js");












/**
 * @param {import('../types').Options} config
 */
function createFiles (config) {
  return {
    chmod: (0,_chmod_js__WEBPACK_IMPORTED_MODULE_0__.createChmod)(config),
    cp: (0,_cp_js__WEBPACK_IMPORTED_MODULE_1__.createCp)(config),
    flush: (0,_flush_js__WEBPACK_IMPORTED_MODULE_2__.createFlush)(config),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_3__.createLs)(config),
    mkdir: (0,_mkdir_js__WEBPACK_IMPORTED_MODULE_4__.createMkdir)(config),
    mv: (0,_mv_js__WEBPACK_IMPORTED_MODULE_5__.createMv)(config),
    read: (0,_read_js__WEBPACK_IMPORTED_MODULE_6__.createRead)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_7__.createRm)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_8__.createStat)(config),
    touch: (0,_touch_js__WEBPACK_IMPORTED_MODULE_9__.createTouch)(config),
    write: (0,_write_js__WEBPACK_IMPORTED_MODULE_10__.createWrite)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/ls.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/ls.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel-with-metadata.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */
const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {FilesAPI["ls"]}
   */
  async function * ls (path, options = {}) {
    if (!path) {
      throw new Error('ipfs.files.ls requires a path')
    }

    const res = await api.post('files/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(path) ? `/ipfs/${path}` : path,
        // default long to true, diverges from go-ipfs where its false by default
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    })

    for await (const result of res.ndjson()) {
      // go-ipfs does not yet support the "stream" option
      if ('Entries' in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface((0,_lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamelWithMetadata)(entry))
        }
      } else {
        yield toCoreInterface((0,_lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamelWithMetadata)(result))
      }
    }
  }
  return ls
})

/**
 * @param {*} entry
 */
function toCoreInterface (entry) {
  if (entry.hash) {
    entry.cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(entry.hash)
  }

  delete entry.hash

  entry.type = entry.type === 1 ? 'directory' : 'file'

  return entry
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/mkdir.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/mkdir.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMkdir": function() { return /* binding */ createMkdir; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createMkdir = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {FilesAPI["mkdir"]}
   */
  async function mkdir (path, options = {}) {
    const res = await api.post('files/mkdir', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    })

    await res.text()
  }
  return mkdir
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/mv.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/mv.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMv": function() { return /* binding */ createMv; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createMv = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {FilesAPI["mv"]}
   */
  async function mv (sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources]
    }

    const res = await api.post('files/mv', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    })
    await res.text()
  }

  return mv
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/read.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/read.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRead": function() { return /* binding */ createRead; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var stream_to_it_source_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream-to-it/source.js */ "stream-to-it/source.js");


// @ts-expect-error no types


/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createRead = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {FilesAPI["read"]}
   */
  async function * read (path, options = {}) {
    const res = await api.post('files/read', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        count: options.length,
        ...options
      }),
      headers: options.headers
    })

    yield * stream_to_it_source_js__WEBPACK_IMPORTED_MODULE_2__(res.body)
  }
  return read
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/rm.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/rm.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-utils/src/http.js */ "ipfs-utils/src/http.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {FilesAPI["rm"]}
   */
  async function rm (path, options = {}) {
    const res = await api.post('files/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    })

    const body = await res.text()
    // we don't expect text body to be ever present
    // (if so, it means an error such as https://github.com/ipfs/go-ipfs/issues/8606)
    if (body !== '') {
      /** @type {Error} */
      const error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_2__.HTTPError(res)
      error.message = body
      throw error
    }
  }
  return rm
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/stat.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/stat.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": function() { return /* binding */ createStat; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel-with-metadata.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {FilesAPI["stat"]}
   */
  async function stat (path, options = {}) {
    const res = await api.post('files/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    data.WithLocality = data.WithLocality || false
    return toCoreInterface((0,_lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamelWithMetadata)(data))
  }
  return stat
})

/**
 * @param {*} entry
 */
function toCoreInterface (entry) {
  entry.cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(entry.hash)
  delete entry.hash
  return entry
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/touch.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/touch.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTouch": function() { return /* binding */ createTouch; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createTouch = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {FilesAPI["touch"]}
   */
  async function touch (path, options = {}) {
    const res = await api.post('files/touch', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    })

    await res.text()
  }
  return touch
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/files/write.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/files/write.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWrite": function() { return /* binding */ createWrite; }
/* harmony export */ });
/* harmony import */ var _lib_mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/mode-to-string.js */ "./node_modules/ipfs-http-client/src/lib/mode-to-string.js");
/* harmony import */ var _lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/parse-mtime.js */ "./node_modules/ipfs-http-client/src/lib/parse-mtime.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");







/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI
 */

const createWrite = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {FilesAPI["write"]}
   */
  async function write (path, input, options = {}) {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__.abortSignal)(controller.signal, options.signal)

    const res = await api.post('files/write', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__.toUrlSearchParams)({
        arg: path,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...(
        await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__.multipartRequest)([{
          content: input,
          path: 'arg',
          mode: (0,_lib_mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__.modeToString)(options.mode),
          mtime: (0,_lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__.parseMtime)(options.mtime)
        }], controller, options.headers)
      )
    })

    await res.text()
  }
  return write
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/get-endpoint-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/get-endpoint-config.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGetEndpointConfig": function() { return /* binding */ createGetEndpointConfig; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");


const createGetEndpointConfig = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  return () => {
    const url = new URL(api.opts.base || '')
    return {
      host: url.hostname,
      port: url.port,
      protocol: url.protocol,
      pathname: url.pathname,
      'api-path': url.pathname
    }
  }
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/get.js":
/*!**************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/get.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": function() { return /* binding */ createGet; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {RootAPI["get"]}
   */
  async function * get (path, options = {}) {
    /** @type {Record<string, any>} */
    const opts = {
      arg: `${path instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(path) : path}`,
      ...options
    }

    if (opts.compressionLevel) {
      opts['compression-level'] = opts.compressionLevel
      delete opts.compressionLevel
    }

    const res = await api.post('get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(opts),
      headers: options.headers
    })

    yield * res.iterator()
  }

  return get
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/id.js":
/*!*************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/id.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createId": function() { return /* binding */ createId; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/peer-id */ "./node_modules/@libp2p/peer-id/dist/src/index.js");






/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createId = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {RootAPI["id"]}
   */
  async function id (options = {}) {
    const res = await api.post('id', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: options.peerId ? options.peerId.toString() : undefined,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    const output = {
      ...(0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data)
    }

    output.id = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_4__.peerIdFromString)(output.id)

    if (output.addresses) {
      output.addresses = output.addresses.map((/** @type {string} */ ma) => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_1__.multiaddr)(ma))
    }

    // @ts-expect-error server output is not typed
    return output
  }
  return id
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3___namespace_cache;
var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4___namespace_cache;
var _ipld_dag_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": function() { return /* binding */ create; },
/* harmony export */   "CID": function() { return /* reexport safe */ multiformats_cid__WEBPACK_IMPORTED_MODULE_44__.CID; },
/* harmony export */   "multiaddr": function() { return /* reexport safe */ _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_45__.multiaddr; },
/* harmony export */   "urlSource": function() { return /* reexport default export from named module */ ipfs_utils_src_files_url_source_js__WEBPACK_IMPORTED_MODULE_46__; },
/* harmony export */   "globSource": function() { return /* binding */ globSource; }
/* harmony export */ });
/* harmony import */ var ipfs_core_utils_multibases__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-core-utils/multibases */ "./node_modules/ipfs-core-utils/src/multibases.js");
/* harmony import */ var ipfs_core_utils_multicodecs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multicodecs */ "./node_modules/ipfs-core-utils/src/multicodecs.js");
/* harmony import */ var ipfs_core_utils_multihashes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multihashes */ "./node_modules/ipfs-core-utils/src/multihashes.js");
/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ipld/dag-pb */ "@ipld/dag-pb");
/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ipld/dag-cbor */ "@ipld/dag-cbor");
/* harmony import */ var _ipld_dag_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ipld/dag-json */ "@ipld/dag-json");
/* harmony import */ var dag_jose__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! dag-jose */ "./node_modules/dag-jose/lib/index.js");
/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! multiformats/hashes/identity */ "multiformats/hashes/identity");
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! multiformats/basics */ "multiformats/basics");
/* harmony import */ var _bitswap_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bitswap/index.js */ "./node_modules/ipfs-http-client/src/bitswap/index.js");
/* harmony import */ var _block_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./block/index.js */ "./node_modules/ipfs-http-client/src/block/index.js");
/* harmony import */ var _bootstrap_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./bootstrap/index.js */ "./node_modules/ipfs-http-client/src/bootstrap/index.js");
/* harmony import */ var _config_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./config/index.js */ "./node_modules/ipfs-http-client/src/config/index.js");
/* harmony import */ var _dag_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dag/index.js */ "./node_modules/ipfs-http-client/src/dag/index.js");
/* harmony import */ var _dht_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./dht/index.js */ "./node_modules/ipfs-http-client/src/dht/index.js");
/* harmony import */ var _diag_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./diag/index.js */ "./node_modules/ipfs-http-client/src/diag/index.js");
/* harmony import */ var _files_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./files/index.js */ "./node_modules/ipfs-http-client/src/files/index.js");
/* harmony import */ var _key_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./key/index.js */ "./node_modules/ipfs-http-client/src/key/index.js");
/* harmony import */ var _log_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./log/index.js */ "./node_modules/ipfs-http-client/src/log/index.js");
/* harmony import */ var _name_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./name/index.js */ "./node_modules/ipfs-http-client/src/name/index.js");
/* harmony import */ var _object_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./object/index.js */ "./node_modules/ipfs-http-client/src/object/index.js");
/* harmony import */ var _pin_index_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./pin/index.js */ "./node_modules/ipfs-http-client/src/pin/index.js");
/* harmony import */ var _pubsub_index_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./pubsub/index.js */ "./node_modules/ipfs-http-client/src/pubsub/index.js");
/* harmony import */ var _refs_index_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./refs/index.js */ "./node_modules/ipfs-http-client/src/refs/index.js");
/* harmony import */ var _repo_index_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./repo/index.js */ "./node_modules/ipfs-http-client/src/repo/index.js");
/* harmony import */ var _stats_index_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./stats/index.js */ "./node_modules/ipfs-http-client/src/stats/index.js");
/* harmony import */ var _swarm_index_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./swarm/index.js */ "./node_modules/ipfs-http-client/src/swarm/index.js");
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./add.js */ "./node_modules/ipfs-http-client/src/add.js");
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./add-all.js */ "./node_modules/ipfs-http-client/src/add-all.js");
/* harmony import */ var _cat_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./cat.js */ "./node_modules/ipfs-http-client/src/cat.js");
/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./commands.js */ "./node_modules/ipfs-http-client/src/commands.js");
/* harmony import */ var _dns_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./dns.js */ "./node_modules/ipfs-http-client/src/dns.js");
/* harmony import */ var _get_endpoint_config_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./get-endpoint-config.js */ "./node_modules/ipfs-http-client/src/get-endpoint-config.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./get.js */ "./node_modules/ipfs-http-client/src/get.js");
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./id.js */ "./node_modules/ipfs-http-client/src/id.js");
/* harmony import */ var _is_online_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./is-online.js */ "./node_modules/ipfs-http-client/src/is-online.js");
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/ls.js");
/* harmony import */ var _mount_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./mount.js */ "./node_modules/ipfs-http-client/src/mount.js");
/* harmony import */ var _ping_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./ping.js */ "./node_modules/ipfs-http-client/src/ping.js");
/* harmony import */ var _resolve_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./resolve.js */ "./node_modules/ipfs-http-client/src/resolve.js");
/* harmony import */ var _start_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./start.js */ "./node_modules/ipfs-http-client/src/start.js");
/* harmony import */ var _stop_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./stop.js */ "./node_modules/ipfs-http-client/src/stop.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./version.js */ "./node_modules/ipfs-http-client/src/version.js");
/* harmony import */ var ipfs_utils_src_files_glob_source_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ipfs-utils/src/files/glob-source.js */ "ipfs-utils/src/files/glob-source.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var ipfs_utils_src_files_url_source_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ipfs-utils/src/files/url-source.js */ "ipfs-utils/src/files/url-source.js");
/* eslint-env browser */














































/**
 * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec
 * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 * @typedef {import('./types').Options} Options
 * @typedef {import('./types').LoadBaseFn} LoadBaseFn
 * @typedef {import('./types').LoadCodecFn} LoadCodecFn
 * @typedef {import('./types').LoadHasherFn} LoadHasherFn
 * @typedef {import('./types').IPLDOptions} IPLDOptions
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('./types').EndpointConfig} EndpointConfig
 * @typedef {import('./types').IPFSHTTPClient} IPFSHTTPClient
 */

/**
 * @param {Options} options
 */
function create (options = {}) {
  /**
   * @type {BlockCodec}
   */
  const id = {
    name: multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_7__.identity.name,
    code: multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_7__.identity.code,
    encode: (id) => id,
    decode: (id) => id
  }

  /** @type {MultibaseCodec[]} */
  const multibaseCodecs = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_8__.bases);

  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach(base => multibaseCodecs.push(base))

  const multibases = new ipfs_core_utils_multibases__WEBPACK_IMPORTED_MODULE_0__.Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  })

  /** @type {BlockCodec[]} */
  const blockCodecs = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_8__.codecs);

  [/*#__PURE__*/ (_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3__, 2))), /*#__PURE__*/ (_ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (_ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(_ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__, 2))), /*#__PURE__*/ (_ipld_dag_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache || (_ipld_dag_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache = __webpack_require__.t(_ipld_dag_json__WEBPACK_IMPORTED_MODULE_5__, 2))), dag_jose__WEBPACK_IMPORTED_MODULE_6__, id].concat((options.ipld && options.ipld.codecs) || []).forEach(codec => blockCodecs.push(codec))

  const multicodecs = new ipfs_core_utils_multicodecs__WEBPACK_IMPORTED_MODULE_1__.Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  })

  /** @type {MultihashHasher[]} */
  const multihashHashers = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_8__.hashes);

  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach(hasher => multihashHashers.push(hasher))

  const multihashes = new ipfs_core_utils_multihashes__WEBPACK_IMPORTED_MODULE_2__.Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  })

  /** @type {IPFSHTTPClient} */
  const client = {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_27__.createAdd)(options),
    addAll: (0,_add_all_js__WEBPACK_IMPORTED_MODULE_28__.createAddAll)(options),
    bitswap: (0,_bitswap_index_js__WEBPACK_IMPORTED_MODULE_9__.createBitswap)(options),
    block: (0,_block_index_js__WEBPACK_IMPORTED_MODULE_10__.createBlock)(options),
    bootstrap: (0,_bootstrap_index_js__WEBPACK_IMPORTED_MODULE_11__.createBootstrap)(options),
    cat: (0,_cat_js__WEBPACK_IMPORTED_MODULE_29__.createCat)(options),
    commands: (0,_commands_js__WEBPACK_IMPORTED_MODULE_30__.createCommands)(options),
    config: (0,_config_index_js__WEBPACK_IMPORTED_MODULE_12__.createConfig)(options),
    dag: (0,_dag_index_js__WEBPACK_IMPORTED_MODULE_13__.createDag)(multicodecs, options),
    dht: (0,_dht_index_js__WEBPACK_IMPORTED_MODULE_14__.createDht)(options),
    diag: (0,_diag_index_js__WEBPACK_IMPORTED_MODULE_15__.createDiag)(options),
    dns: (0,_dns_js__WEBPACK_IMPORTED_MODULE_31__.createDns)(options),
    files: (0,_files_index_js__WEBPACK_IMPORTED_MODULE_16__.createFiles)(options),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_33__.createGet)(options),
    getEndpointConfig: (0,_get_endpoint_config_js__WEBPACK_IMPORTED_MODULE_32__.createGetEndpointConfig)(options),
    id: (0,_id_js__WEBPACK_IMPORTED_MODULE_34__.createId)(options),
    isOnline: (0,_is_online_js__WEBPACK_IMPORTED_MODULE_35__.createIsOnline)(options),
    key: (0,_key_index_js__WEBPACK_IMPORTED_MODULE_17__.createKey)(options),
    log: (0,_log_index_js__WEBPACK_IMPORTED_MODULE_18__.createLog)(options),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_36__.createLs)(options),
    mount: (0,_mount_js__WEBPACK_IMPORTED_MODULE_37__.createMount)(options),
    name: (0,_name_index_js__WEBPACK_IMPORTED_MODULE_19__.createName)(options),
    object: (0,_object_index_js__WEBPACK_IMPORTED_MODULE_20__.createObject)(multicodecs, options),
    pin: (0,_pin_index_js__WEBPACK_IMPORTED_MODULE_21__.createPin)(options),
    ping: (0,_ping_js__WEBPACK_IMPORTED_MODULE_38__.createPing)(options),
    pubsub: (0,_pubsub_index_js__WEBPACK_IMPORTED_MODULE_22__.createPubsub)(options),
    refs: (0,_refs_index_js__WEBPACK_IMPORTED_MODULE_23__.createRefs)(options),
    repo: (0,_repo_index_js__WEBPACK_IMPORTED_MODULE_24__.createRepo)(options),
    resolve: (0,_resolve_js__WEBPACK_IMPORTED_MODULE_39__.createResolve)(options),
    start: (0,_start_js__WEBPACK_IMPORTED_MODULE_40__.createStart)(options),
    stats: (0,_stats_index_js__WEBPACK_IMPORTED_MODULE_25__.createStats)(options),
    stop: (0,_stop_js__WEBPACK_IMPORTED_MODULE_41__.createStop)(options),
    swarm: (0,_swarm_index_js__WEBPACK_IMPORTED_MODULE_26__.createSwarm)(options),
    version: (0,_version_js__WEBPACK_IMPORTED_MODULE_42__.createVersion)(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  }

  return client
}




const globSource = ipfs_utils_src_files_glob_source_js__WEBPACK_IMPORTED_MODULE_43__


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/is-online.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/is-online.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createIsOnline": function() { return /* binding */ createIsOnline; }
/* harmony export */ });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./node_modules/ipfs-http-client/src/id.js");


/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

/**
 * @param {import('./types').Options} options
 */
const createIsOnline = options => {
  const id = (0,_id_js__WEBPACK_IMPORTED_MODULE_0__.createId)(options)

  /**
   * @type {RootAPI["isOnline"]}
   */
  async function isOnline (options = {}) {
    const res = await id(options)

    return Boolean(res && res.addresses && res.addresses.length)
  }
  return isOnline
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/export.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/export.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createExport": function() { return /* binding */ createExport; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ "err-code");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createExport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {KeyAPI["export"]}
   */
  const exportKey = async (name, password, options = {}) => {
    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED')
  }

  return exportKey
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/gen.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/gen.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGen": function() { return /* binding */ createGen; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createGen = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {KeyAPI["gen"]}
   */
  async function gen (name, options = { type: 'Ed25519' }) {
    const res = await api.post('key/gen', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data)
  }
  return gen
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/import.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/import.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createImport": function() { return /* binding */ createImport; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createImport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {KeyAPI["import"]}
   */
  async function importKey (name, pem, password, options = {}) {
    const res = await api.post('key/import', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data)
  }
  return importKey
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createKey": function() { return /* binding */ createKey; }
/* harmony export */ });
/* harmony import */ var _export_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./export.js */ "./node_modules/ipfs-http-client/src/key/export.js");
/* harmony import */ var _gen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gen.js */ "./node_modules/ipfs-http-client/src/key/gen.js");
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./import.js */ "./node_modules/ipfs-http-client/src/key/import.js");
/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ "./node_modules/ipfs-http-client/src/key/info.js");
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./list.js */ "./node_modules/ipfs-http-client/src/key/list.js");
/* harmony import */ var _rename_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rename.js */ "./node_modules/ipfs-http-client/src/key/rename.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/key/rm.js");








/**
 * @param {import('../types').Options} config
 */
function createKey (config) {
  return {
    export: (0,_export_js__WEBPACK_IMPORTED_MODULE_0__.createExport)(config),
    gen: (0,_gen_js__WEBPACK_IMPORTED_MODULE_1__.createGen)(config),
    import: (0,_import_js__WEBPACK_IMPORTED_MODULE_2__.createImport)(config),
    info: (0,_info_js__WEBPACK_IMPORTED_MODULE_3__.createInfo)(config),
    list: (0,_list_js__WEBPACK_IMPORTED_MODULE_4__.createList)(config),
    rename: (0,_rename_js__WEBPACK_IMPORTED_MODULE_5__.createRename)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_6__.createRm)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/info.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/info.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createInfo": function() { return /* binding */ createInfo; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ "err-code");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createInfo = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {KeyAPI["info"]}
   */
  const info = async (name, options = {}) => {
    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED')
  }

  return info
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/list.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/list.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createList": function() { return /* binding */ createList; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createList = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {KeyAPI["list"]}
   */
  async function list (options = {}) {
    const res = await api.post('key/list', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })
    const data = await res.json()

    return (data.Keys || []).map((/** @type {any} **/ k) => (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(k))
  }
  return list
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/rename.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/rename.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRename": function() { return /* binding */ createRename; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createRename = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {KeyAPI["rename"]}
   */
  async function rename (oldName, newName, options = {}) {
    const res = await api.post('key/rename', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    })

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json())
  }
  return rename
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/key/rm.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/key/rm.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI
 */

const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {KeyAPI["rm"]}
   */
  async function rm (name, options = {}) {
    const res = await api.post('key/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data.Keys[0])
  }
  return rm
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/abort-signal.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/abort-signal.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abortSignal": function() { return /* binding */ abortSignal; }
/* harmony export */ });
/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! any-signal */ "any-signal");


/**
 * @param {any[]} signals
 * @returns {AbortSignal[]}
 */
function filter (signals) {
  return signals.filter(Boolean)
}

/**
 * @param  {...AbortSignal|undefined} signals
 */
function abortSignal (...signals) {
  return (0,any_signal__WEBPACK_IMPORTED_MODULE_0__.anySignal)(filter(signals))
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/configure.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/configure.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "configure": function() { return /* binding */ configure; }
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/ipfs-http-client/src/lib/core.js");

/* eslint-env browser */



// Set default configuration and call create function with them
/**
 * @typedef { import("../types").Options } Options
 */

/**
 * @template T
 * @typedef {(client: Client, clientOptions: Options) => T} Fn
 */

/**
 * @template T
 * @typedef {(clientOptions: Options) => T} Factory
 */

/**
 * @template T
 * @param {Fn<T>} fn
 * @returns {Factory<T>}
 */
const configure = (fn) => {
  return (options) => {
    return fn(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Client(options), options)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/core.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/core.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "errorHandler": function() { return /* binding */ errorHandler; },
/* harmony export */   "Client": function() { return /* binding */ Client; },
/* harmony export */   "HTTPError": function() { return /* binding */ HTTPError; }
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-utils/src/env.js */ "ipfs-utils/src/env.js");
/* harmony import */ var parse_duration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parse-duration */ "parse-duration");
/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/logger */ "./node_modules/@libp2p/logger/dist/src/index.js");
/* harmony import */ var ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-utils/src/http.js */ "ipfs-utils/src/http.js");
/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! merge-options */ "merge-options");
/* harmony import */ var ipfs_core_utils_to_url_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ipfs-core-utils/to-url-string */ "./node_modules/ipfs-core-utils/src/to-url-string.js");
/* harmony import */ var ipfs_core_utils_agent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ipfs-core-utils/agent */ "./node_modules/ipfs-core-utils/src/agent.js");

/* eslint-env browser */










const log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_3__.logger)('ipfs-http-client:lib:error-handler')
const merge = merge_options__WEBPACK_IMPORTED_MODULE_5__.bind({ ignoreUndefined: true })

const DEFAULT_PROTOCOL = ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser || ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isWebWorker ? location.protocol : 'http'
const DEFAULT_HOST = ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser || ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isWebWorker ? location.hostname : 'localhost'
const DEFAULT_PORT = ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser || ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isWebWorker ? location.port : '5001'

/**
 * @typedef {import('ipfs-utils/src/types').HTTPOptions} HTTPOptions
 * @typedef {import('../types').Options} Options
 * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr
 */

/**
 * @param {Options|URL|Multiaddr|string} [options]
 * @returns {Options}
 */
const normalizeOptions = (options = {}) => {
  let url
  /** @type {Options} */
  let opts = {}
  let agent

  if (typeof options === 'string' || (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.isMultiaddr)(options)) {
    url = new URL((0,ipfs_core_utils_to_url_string__WEBPACK_IMPORTED_MODULE_6__.toUrlString)(options))
  } else if (options instanceof URL) {
    url = options
  } else if (typeof options.url === 'string' || (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.isMultiaddr)(options.url)) {
    url = new URL((0,ipfs_core_utils_to_url_string__WEBPACK_IMPORTED_MODULE_6__.toUrlString)(options.url))
    opts = options
  } else if (options.url instanceof URL) {
    url = options.url
    opts = options
  } else {
    opts = options || {}

    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(':', '')
    const host = (opts.host || DEFAULT_HOST).split(':')[0]
    const port = (opts.port || DEFAULT_PORT)

    url = new URL(`${protocol}://${host}:${port}`)
  }

  if (opts.apiPath) {
    url.pathname = opts.apiPath
  } else if (url.pathname === '/' || url.pathname === undefined) {
    url.pathname = 'api/v0'
  }

  if (ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isNode) {
    const Agent = (0,ipfs_core_utils_agent__WEBPACK_IMPORTED_MODULE_7__.default)(url)

    agent = opts.agent || new Agent({
      keepAlive: true,
      // Similar to browsers which limit connections to six per host
      maxSockets: 6
    })
  }

  return {
    ...opts,
    host: url.host,
    protocol: url.protocol.replace(':', ''),
    port: Number(url.port),
    apiPath: url.pathname,
    url,
    agent
  }
}

/**
 * @param {Response} response
 */
const errorHandler = async (response) => {
  let msg

  try {
    if ((response.headers.get('Content-Type') || '').startsWith('application/json')) {
      const data = await response.json()
      log(data)
      msg = data.Message || data.message
    } else {
      msg = await response.text()
    }
  } catch (/** @type {any} */ err) {
    log('Failed to parse error response', err)
    // Failed to extract/parse error message from response
    msg = err.message
  }

  /** @type {Error} */
  let error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.HTTPError(response)

  if (msg) {
    // This is what rs-ipfs returns where there's a timeout
    if (msg.includes('deadline has elapsed')) {
      error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError()
    }

    // This is what go-ipfs returns where there's a timeout
    if (msg && msg.includes('context deadline exceeded')) {
      error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError()
    }
  }

  // This also gets returned
  if (msg && msg.includes('request timed out')) {
    error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError()
  }

  // If we managed to extract a message from the response, use it
  if (msg) {
    error.message = msg
  }

  throw error
}

const KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g

/**
 * @param {string} str
 */
const kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function (match) {
    return '-' + match.toLowerCase()
  })
}

/**
 * @param {string | number} value
 */
const parseTimeout = (value) => {
  return typeof value === 'string' ? parse_duration__WEBPACK_IMPORTED_MODULE_2__(value) : value
}

class Client extends ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__ {
  /**
   * @param {Options|URL|Multiaddr|string} [options]
   */
  constructor (options = {}) {
    const opts = normalizeOptions(options)

    super({
      timeout: parseTimeout(opts.timeout || 0) || undefined,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams()

        for (const [key, value] of search) {
          if (
            value !== 'undefined' &&
            value !== 'null' &&
            key !== 'signal'
          ) {
            out.append(kebabCase(key), value)
          }

          // @ts-expect-error server timeouts are strings
          if (key === 'timeout' && !isNaN(value)) {
            out.append(kebabCase(key), value)
          }
        }

        return out
      },
      // @ts-expect-error this can be a https agent or a http agent
      agent: opts.agent
    })

    // @ts-expect-error - cannot delete no-optional fields
    delete this.get
    // @ts-expect-error - cannot delete no-optional fields
    delete this.put
    // @ts-expect-error - cannot delete no-optional fields
    delete this.delete
    // @ts-expect-error - cannot delete no-optional fields
    delete this.options

    const fetch = this.fetch

    /**
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     */
    this.fetch = (resource, options = {}) => {
      if (typeof resource === 'string' && !resource.startsWith('/')) {
        resource = `${opts.url}/${resource}`
      }

      return fetch.call(this, resource, merge(options, {
        method: 'POST'
      }))
    }
  }
}

const HTTPError = ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.HTTPError


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rpcArrayToTextArray": function() { return /* binding */ rpcArrayToTextArray; },
/* harmony export */   "rpcToText": function() { return /* binding */ rpcToText; },
/* harmony export */   "rpcToBytes": function() { return /* binding */ rpcToBytes; },
/* harmony export */   "rpcToBigInt": function() { return /* binding */ rpcToBigInt; },
/* harmony export */   "textToUrlSafeRpc": function() { return /* binding */ textToUrlSafeRpc; }
/* harmony export */ });
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ "uint8arrays/from-string");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ "uint8arrays/to-string");
/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base64 */ "multiformats/bases/base64");




/* HTTP RPC:
 * - wraps binary data in multibase. base64url is used to avoid issues
 *   when a binary data is passed as search param in URL.
 *   Historical context: https://github.com/ipfs/go-ipfs/issues/7939
 *   Multibase wrapping introduced in: https://github.com/ipfs/go-ipfs/pull/8183
 */

/**
 * @param {Array<string>} strings
 * @returns {Array<string>} strings
 */
const rpcArrayToTextArray = strings => {
  if (Array.isArray(strings)) {
    return strings.map(rpcToText)
  }
  return strings
}

/**
 * @param {string} mb
 * @returns {string}
 */
const rpcToText = mb => (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(rpcToBytes(mb))

/**
 * @param {string} mb
 * @returns {Uint8Array}
 */
const rpcToBytes = mb => multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_2__.base64url.decode(mb)

/**
 * @param {string} mb
 * @returns {bigint}
 */
const rpcToBigInt = mb => BigInt(`0x${(0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_2__.base64url.decode(mb), 'base16')}`)

/**
 * @param {string} text
 * @returns {string}
 */
const textToUrlSafeRpc = text => multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_2__.base64url.encode((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(text))




/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/mode-to-string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/mode-to-string.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "modeToString": function() { return /* binding */ modeToString; }
/* harmony export */ });

/**
 * @param {number | string | undefined} mode
 */
function modeToString (mode) {
  if (mode == null) {
    return undefined
  }

  if (typeof mode === 'string') {
    return mode
  }

  return mode.toString(8).padStart(4, '0')
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "objectToCamelWithMetadata": function() { return /* binding */ objectToCamelWithMetadata; }
/* harmony export */ });
/* harmony import */ var _object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");


/**
 * @param {Record<string, any>} entry
 */
function objectToCamelWithMetadata (entry) {
  const file = (0,_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(entry)

  if (Object.prototype.hasOwnProperty.call(file, 'mode')) {
    file.mode = parseInt(file.mode, 8)
  }

  if (Object.prototype.hasOwnProperty.call(file, 'mtime')) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    }

    delete file.mtimeNsecs
  }

  return file
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js":
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/object-to-camel.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "objectToCamel": function() { return /* binding */ objectToCamel; }
/* harmony export */ });

/**
 * Convert object properties to camel case.
 * NOT recursive!
 * e.g.
 * AgentVersion => agentVersion
 * ID => id
 *
 * @param {Record<string, any>} obj
 */
function objectToCamel (obj) {
  if (obj == null) {
    return obj
  }

  const caps = /^[A-Z]+$/

  /** @type {Record<string, any>} */
  const output = {}

  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) { // all caps
      camelObj[k.toLowerCase()] = obj[k]
    } else if (caps.test(k[0])) { // pascal
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k]
    } else {
      camelObj[k] = obj[k]
    }
    return camelObj
  }, output)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/parse-mtime.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/parse-mtime.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseMtime": function() { return /* binding */ parseMtime; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");


/**
 * @param {any} input
 */
function parseMtime (input) {
  if (input == null) {
    return undefined
  }

  /** @type {{ secs: number, nsecs?: number } | undefined} */
  let mtime

  // { secs, nsecs }
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    }
  }

  // UnixFS TimeSpec
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    }
  }

  // process.hrtime()
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    }
  }

  // Javascript Date
  if (input instanceof Date) {
    const ms = input.getTime()
    const secs = Math.floor(ms / 1000)

    mtime = {
      secs: secs,
      nsecs: (ms - (secs * 1000)) * 1000
    }
  }

  /*
  TODO: https://github.com/ipfs/aegir/issues/487

  // process.hrtime.bigint()
  if (input instanceof BigInt) {
    const secs = input / BigInt(1e9)
    const nsecs = input - (secs * BigInt(1e9))

    mtime = {
      secs: parseInt(secs.toString()),
      nsecs: parseInt(nsecs.toString())
    }
  }
  */

  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
    return undefined
  }

  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS')
  }

  return mtime
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/resolve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolve": function() { return /* binding */ resolve; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ "err-code");



/**
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */

/**
 * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.
 *
 * @param {CID} cid - the CID where the resolving starts
 * @param {string} path - the path that should be resolved
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
 * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock
 * @param {AbortOptions} [options]
 */
async function * resolve (cid, path, codecs, getBlock, options) {
  /**
   * @param {CID} cid
   */
  const load = async (cid) => {
    const codec = await codecs.getCodec(cid.code)
    const block = await getBlock(cid, options)

    return codec.decode(block)
  }

  const parts = path.split('/').filter(Boolean)
  let value = await load(cid)
  let lastCid = cid

  // End iteration if there isn't a CID to follow any more
  while (parts.length) {
    const key = parts.shift()

    if (!key) {
      throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error(`Could not resolve path "${path}"`), 'ERR_INVALID_PATH')
    }

    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key]

      yield {
        value,
        remainderPath: parts.join('/')
      }
    } else {
      throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error(`no link named "${key}" under ${lastCid}`), 'ERR_NO_LINK')
    }

    const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(value)

    if (cid) {
      lastCid = cid
      value = await load(value)
    }
  }

  yield {
    value,
    remainderPath: ''
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/lib/to-url-search-params.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toUrlSearchParams": function() { return /* binding */ toUrlSearchParams; }
/* harmony export */ });
/* harmony import */ var _mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode-to-string.js */ "./node_modules/ipfs-http-client/src/lib/mode-to-string.js");
/* harmony import */ var _lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/parse-mtime.js */ "./node_modules/ipfs-http-client/src/lib/parse-mtime.js");



/**
 * @param {*} params
 * @returns {URLSearchParams}
 */
function toUrlSearchParams ({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    }
  }

  if (hashAlg) {
    options.hash = hashAlg
  }

  if (mtime != null) {
    mtime = (0,_lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__.parseMtime)(mtime)

    options.mtime = mtime.secs
    options.mtimeNsecs = mtime.nsecs
  }

  if (mode != null) {
    options.mode = (0,_mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__.modeToString)(mode)
  }

  if (options.timeout && !isNaN(options.timeout)) {
    // server API expects timeouts as strings
    options.timeout = `${options.timeout}ms`
  }

  if (arg === undefined || arg === null) {
    arg = []
  } else if (!Array.isArray(arg)) {
    arg = [arg]
  }

  const urlSearchParams = new URLSearchParams(options)

  arg.forEach((/** @type {any} */ arg) => urlSearchParams.append('arg', arg))

  return urlSearchParams
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/log/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/log/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLog": function() { return /* binding */ createLog; }
/* harmony export */ });
/* harmony import */ var _level_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./level.js */ "./node_modules/ipfs-http-client/src/log/level.js");
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/log/ls.js");
/* harmony import */ var _tail_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tail.js */ "./node_modules/ipfs-http-client/src/log/tail.js");




/**
 * @param {import('../types').Options} config
 */
function createLog (config) {
  return {
    level: (0,_level_js__WEBPACK_IMPORTED_MODULE_0__.createLevel)(config),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_1__.createLs)(config),
    tail: (0,_tail_js__WEBPACK_IMPORTED_MODULE_2__.createTail)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/log/level.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/log/level.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLevel": function() { return /* binding */ createLevel; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/log').API<HTTPClientExtraOptions>} LogAPI
 */

const createLevel = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {LogAPI["level"]}
   */
  async function level (subsystem, level, options = {}) {
    const res = await api.post('log/level', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          subsystem,
          level
        ],
        ...options
      }),
      headers: options.headers
    })

    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json())
  }
  return level
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/log/ls.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/log/ls.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/log').API<HTTPClientExtraOptions>} LogAPI
 */

const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {LogAPI["ls"]}
   */
  async function ls (options = {}) {
    const res = await api.post('log/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    const data = await res.json()
    return data.Strings
  }
  return ls
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/log/tail.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/log/tail.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTail": function() { return /* binding */ createTail; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/log').API<HTTPClientExtraOptions>} LogAPI
 */

const createTail = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {LogAPI["tail"]}
   */
  async function * tail (options = {}) {
    const res = await api.post('log/tail', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    yield * res.ndjson()
  }
  return tail
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/ls.js":
/*!*************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/ls.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _files_stat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./files/stat.js */ "./node_modules/ipfs-http-client/src/files/stat.js");





/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)((api, opts) => {
  /**
   * @type {RootAPI["ls"]}
   */
  async function * ls (path, options = {}) {
    const pathStr = `${path instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(path) : path}`

    /**
     * @param {*} link
     */
    async function mapLink (link) {
      let hash = link.Hash

      if (hash.includes('/')) {
        // the hash is a path, but we need the CID
        const ipfsPath = hash.startsWith('/ipfs/') ? hash : `/ipfs/${hash}`
        const stats = await (0,_files_stat_js__WEBPACK_IMPORTED_MODULE_3__.createStat)(opts)(ipfsPath)

        hash = stats.cid
      } else {
        hash = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(hash)
      }

      /** @type {import('ipfs-core-types/src/root').IPFSEntry} */
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ''),
        size: link.Size,
        cid: hash,
        type: typeOf(link)
      }

      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8)
      }

      if (link.Mtime !== undefined && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        }

        if (link.MtimeNsecs !== undefined && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs
        }
      }

      return entry
    }

    const res = await api.post('ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    })

    for await (let result of res.ndjson()) {
      result = result.Objects

      if (!result) {
        throw new Error('expected .Objects in results')
      }

      result = result[0]
      if (!result) {
        throw new Error('expected one array in results.Objects')
      }

      const links = result.Links
      if (!Array.isArray(links)) {
        throw new Error('expected one array in results.Objects[0].Links')
      }

      if (!links.length) {
        // no links, this is a file, yield a single result
        yield mapLink(result)

        return
      }

      yield * links.map(mapLink)
    }
  }
  return ls
})

/**
 * @param {any} link
 */
function typeOf (link) {
  switch (link.Type) {
    case 1:
    case 5:
      return 'dir'
    case 2:
      return 'file'
    default:
      return 'file'
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/mount.js":
/*!****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/mount.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMount": function() { return /* binding */ createMount; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createMount = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {RootAPI["mount"]}
   */
  async function mount (options = {}) {
    const res = await api.post('dns', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json())
  }
  return mount
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createName": function() { return /* binding */ createName; }
/* harmony export */ });
/* harmony import */ var _publish_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./publish.js */ "./node_modules/ipfs-http-client/src/name/publish.js");
/* harmony import */ var _resolve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve.js */ "./node_modules/ipfs-http-client/src/name/resolve.js");
/* harmony import */ var _pubsub_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pubsub/index.js */ "./node_modules/ipfs-http-client/src/name/pubsub/index.js");




/**
 * @param {import('../types').Options} config
 */
function createName (config) {
  return {
    publish: (0,_publish_js__WEBPACK_IMPORTED_MODULE_0__.createPublish)(config),
    resolve: (0,_resolve_js__WEBPACK_IMPORTED_MODULE_1__.createResolve)(config),
    pubsub: (0,_pubsub_index_js__WEBPACK_IMPORTED_MODULE_2__.createPubsub)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/publish.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/publish.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPublish": function() { return /* binding */ createPublish; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/name').API<HTTPClientExtraOptions>} NameAPI
 */

const createPublish = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {NameAPI["publish"]}
   */
  async function publish (path, options = {}) {
    const res = await api.post('name/publish', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${path}`,
        ...options
      }),
      headers: options.headers
    })

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json())
  }
  return publish
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/pubsub/cancel.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/pubsub/cancel.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCancel": function() { return /* binding */ createCancel; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/name/pubsub').API<HTTPClientExtraOptions>} NamePubsubAPI
 */

const createCancel = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {NamePubsubAPI["cancel"]}
   */
  async function cancel (name, options = {}) {
    const res = await api.post('name/pubsub/cancel', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        ...options
      }),
      headers: options.headers
    })

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json())
  }
  return cancel
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/pubsub/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/pubsub/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPubsub": function() { return /* binding */ createPubsub; }
/* harmony export */ });
/* harmony import */ var _cancel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cancel.js */ "./node_modules/ipfs-http-client/src/name/pubsub/cancel.js");
/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state.js */ "./node_modules/ipfs-http-client/src/name/pubsub/state.js");
/* harmony import */ var _subs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subs.js */ "./node_modules/ipfs-http-client/src/name/pubsub/subs.js");




/**
 * @param {import('../../types').Options} config
 */
function createPubsub (config) {
  return {
    cancel: (0,_cancel_js__WEBPACK_IMPORTED_MODULE_0__.createCancel)(config),
    state: (0,_state_js__WEBPACK_IMPORTED_MODULE_1__.createState)(config),
    subs: (0,_subs_js__WEBPACK_IMPORTED_MODULE_2__.createSubs)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/pubsub/state.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/pubsub/state.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createState": function() { return /* binding */ createState; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/name/pubsub').API<HTTPClientExtraOptions>} NamePubsubAPI
 */

const createState = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {NamePubsubAPI["state"]}
   */
  async function state (options = {}) {
    const res = await api.post('name/pubsub/state', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    // @ts-expect-error server output is not typed
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json())
  }
  return state
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/pubsub/subs.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/pubsub/subs.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSubs": function() { return /* binding */ createSubs; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/name/pubsub').API<HTTPClientExtraOptions>} NamePubsubAPI
 */

const createSubs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {NamePubsubAPI["subs"]}
   */
  async function subs (options = {}) {
    const res = await api.post('name/pubsub/subs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })
    const data = await res.json()

    return data.Strings || []
  }
  return subs
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/name/resolve.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/name/resolve.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createResolve": function() { return /* binding */ createResolve; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/name').API<HTTPClientExtraOptions>} NameAPI
 */

const createResolve = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {NameAPI["resolve"]}
   */
  async function * resolve (path, options = {}) {
    const res = await api.post('name/resolve', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        stream: true,
        ...options
      }),
      headers: options.headers
    })

    for await (const result of res.ndjson()) {
      yield result.Path
    }
  }
  return resolve
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/data.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/data.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI
 */

const createData = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectAPI["data"]}
   */
  async function data (cid, options = {}) {
    const res = await api.post('object/data', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${cid instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.arrayBuffer()

    return new Uint8Array(data, 0, data.byteLength)
  }
  return data
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/get.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/get.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": function() { return /* binding */ createGet; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ "uint8arrays/from-string");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI
 */

const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectAPI["get"]}
   */
  async function get (cid, options = {}) {
    const res = await api.post('object/get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${cid instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(cid) : cid}`,
        dataEncoding: 'base64',
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return {
      Data: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)(data.Data, 'base64pad'),
      Links: (data.Links || []).map((/** @type {any} */ link) => ({
        Name: link.Name,
        Hash: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(link.Hash),
        Tsize: link.Size
      }))
    }
  }
  return get
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createObject": function() { return /* binding */ createObject; }
/* harmony export */ });
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ "./node_modules/ipfs-http-client/src/object/data.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ "./node_modules/ipfs-http-client/src/object/get.js");
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./links.js */ "./node_modules/ipfs-http-client/src/object/links.js");
/* harmony import */ var _new_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./new.js */ "./node_modules/ipfs-http-client/src/object/new.js");
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./put.js */ "./node_modules/ipfs-http-client/src/object/put.js");
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stat.js */ "./node_modules/ipfs-http-client/src/object/stat.js");
/* harmony import */ var _patch_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./patch/index.js */ "./node_modules/ipfs-http-client/src/object/patch/index.js");








/**
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
 * @param {import('../types').Options} config
 */
function createObject (codecs, config) {
  return {
    data: (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.createData)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_1__.createGet)(config),
    links: (0,_links_js__WEBPACK_IMPORTED_MODULE_2__.createLinks)(config),
    new: (0,_new_js__WEBPACK_IMPORTED_MODULE_3__.createNew)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_4__.createPut)(codecs, config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_5__.createStat)(config),
    patch: (0,_patch_index_js__WEBPACK_IMPORTED_MODULE_6__.createPatch)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/links.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/links.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLinks": function() { return /* binding */ createLinks; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI
 */

const createLinks = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectAPI["links"]}
   */
  async function links (cid, options = {}) {
    const res = await api.post('object/links', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${cid instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    })
    const data = await res.json()

    return (data.Links || []).map((/** @type {any} */ l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(l.Hash)
    }))
  }
  return links
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/new.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/new.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createNew": function() { return /* binding */ createNew; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI
 */

const createNew = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectAPI["new"]}
   */
  async function newObject (options = {}) {
    const res = await api.post('object/new', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    })

    const { Hash } = await res.json()

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash)
  }
  return newObject
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/patch/add-link.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/patch/add-link.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddLink": function() { return /* binding */ createAddLink; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI
 */

const createAddLink = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectPatchAPI["addLink"]}
   */
  async function addLink (cid, dLink, options = {}) {
    const res = await api.post('object/patch/add-link', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || '',
          // @ts-expect-error loose types
          (dLink.Hash || dLink.cid || '').toString() || null
        ],
        ...options
      }),
      headers: options.headers
    })

    const { Hash } = await res.json()

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash)
  }

  return addLink
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/patch/append-data.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/patch/append-data.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAppendData": function() { return /* binding */ createAppendData; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");






/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI
 */

const createAppendData = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {ObjectPatchAPI["appendData"]}
   */
  async function appendData (cid, data, options = {}) {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal)

    const res = await api.post('object/patch/append-data', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: `${cid}`,
        ...options
      }),
      ...(
        await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)([data], controller, options.headers)
      )
    })

    const { Hash } = await res.json()

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash)
  }
  return appendData
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/patch/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/patch/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPatch": function() { return /* binding */ createPatch; }
/* harmony export */ });
/* harmony import */ var _add_link_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-link.js */ "./node_modules/ipfs-http-client/src/object/patch/add-link.js");
/* harmony import */ var _append_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./append-data.js */ "./node_modules/ipfs-http-client/src/object/patch/append-data.js");
/* harmony import */ var _rm_link_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rm-link.js */ "./node_modules/ipfs-http-client/src/object/patch/rm-link.js");
/* harmony import */ var _set_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./set-data.js */ "./node_modules/ipfs-http-client/src/object/patch/set-data.js");





/**
 * @param {import('../../types').Options} config
 */
function createPatch (config) {
  return {
    addLink: (0,_add_link_js__WEBPACK_IMPORTED_MODULE_0__.createAddLink)(config),
    appendData: (0,_append_data_js__WEBPACK_IMPORTED_MODULE_1__.createAppendData)(config),
    rmLink: (0,_rm_link_js__WEBPACK_IMPORTED_MODULE_2__.createRmLink)(config),
    setData: (0,_set_data_js__WEBPACK_IMPORTED_MODULE_3__.createSetData)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/patch/rm-link.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/patch/rm-link.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRmLink": function() { return /* binding */ createRmLink; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI
 */

const createRmLink = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectPatchAPI["rmLink"]}
   */
  async function rmLink (cid, dLink, options = {}) {
    const res = await api.post('object/patch/rm-link', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    })

    const { Hash } = await res.json()

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash)
  }
  return rmLink
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/patch/set-data.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/patch/set-data.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSetData": function() { return /* binding */ createSetData; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");






/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI
 */

const createSetData = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  /**
   * @type {ObjectPatchAPI["setData"]}
   */
  async function setData (cid, data, options = {}) {
    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal)

    const res = await api.post('object/patch/set-data', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...(
        await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)([data], controller, options.headers)
      )
    })

    const { Hash } = await res.json()

    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash)
  }
  return setData
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/put.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/put.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": function() { return /* binding */ createPut; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _dag_put_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dag/put.js */ "./node_modules/ipfs-http-client/src/dag/put.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI
 */

/**
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
 * @param {import('../types').Options} options
 */
const createPut = (codecs, options) => {
  const fn = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)((api) => {
    const dagPut = (0,_dag_put_js__WEBPACK_IMPORTED_MODULE_1__.createPut)(codecs, options)

    /**
     * @type {ObjectAPI["put"]}
     */
    async function put (obj, options = {}) {
      return dagPut(obj, {
        ...options,
        storeCodec: 'dag-pb',
        hashAlg: 'sha2-256',
        version: 1
      })
    }
    return put
  })

  return fn(options)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/object/stat.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/object/stat.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": function() { return /* binding */ createStat; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI
 */

const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {ObjectAPI["stat"]}
   */
  async function stat (cid, options = {}) {
    const res = await api.post('object/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    })

    const output = await res.json()

    return {
      ...output,
      Hash: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(output.Hash)
    }
  }
  return stat
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/add-all.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/add-all.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddAll": function() { return /* binding */ createAddAll; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/pins/normalise-input */ "./node_modules/ipfs-core-utils/src/pins/normalise-input.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI
 */

const createAddAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {PinAPI["addAll"]}
   */
  async function * addAll (source, options = {}) {
    for await (const { path, recursive, metadata } of (0,ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__.normaliseInput)(source)) {
      const res = await api.post('pin/add', {
        signal: options.signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
          ...options,
          arg: path,
          recursive,
          metadata: metadata ? JSON.stringify(metadata) : undefined,
          stream: true
        }),
        headers: options.headers
      })

      for await (const pin of res.ndjson()) {
        if (pin.Pins) { // non-streaming response
          for (const cid of pin.Pins) {
            yield multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid)
          }
          continue
        }

        yield multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(pin)
      }
    }
  }
  return addAll
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/add.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/add.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": function() { return /* binding */ createAdd; }
/* harmony export */ });
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-all.js */ "./node_modules/ipfs-http-client/src/pin/add-all.js");
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ "it-last");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI
 */

/**
 * @param {import('../types').Options} config
 */
function createAdd (config) {
  const all = (0,_add_all_js__WEBPACK_IMPORTED_MODULE_0__.createAddAll)(config)

  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(() => {
    /**
     * @type {PinAPI["add"]}
     */
    async function add (path, options = {}) {
      // @ts-expect-error last can return undefined
      return it_last__WEBPACK_IMPORTED_MODULE_1__(all([{
        path,
        ...options
      }], options))
    }
    return add
  })(config)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPin": function() { return /* binding */ createPin; }
/* harmony export */ });
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-all.js */ "./node_modules/ipfs-http-client/src/pin/add-all.js");
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ "./node_modules/ipfs-http-client/src/pin/add.js");
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/pin/ls.js");
/* harmony import */ var _rm_all_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rm-all.js */ "./node_modules/ipfs-http-client/src/pin/rm-all.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/pin/rm.js");
/* harmony import */ var _remote_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./remote/index.js */ "./node_modules/ipfs-http-client/src/pin/remote/index.js");







/**
 * @param {import('../types').Options} config
 */
function createPin (config) {
  return {
    addAll: (0,_add_all_js__WEBPACK_IMPORTED_MODULE_0__.createAddAll)(config),
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_1__.createAdd)(config),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_2__.createLs)(config),
    rmAll: (0,_rm_all_js__WEBPACK_IMPORTED_MODULE_3__.createRmAll)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_4__.createRm)(config),
    remote: (0,_remote_index_js__WEBPACK_IMPORTED_MODULE_5__.createRemote)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/ls.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/ls.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI
 */

/**
 * @param {string} type
 * @param {string} cid
 * @param {Record<string, string>} metadata
 */
function toPin (type, cid, metadata) {
  /** @type {import('ipfs-core-types/src/pin').LsResult} */
  const pin = {
    type,
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid)
  }

  if (metadata) {
    pin.metadata = metadata
  }

  return pin
}

const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {PinAPI["ls"]}
   */
  async function * ls (options = {}) {
    /** @type {any[]} */
    let paths = []

    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths]
    }

    const res = await api.post('pin/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        ...options,
        arg: paths.map(path => `${path}`),
        stream: true
      }),
      headers: options.headers
    })

    for await (const pin of res.ndjson()) {
      if (pin.Keys) { // non-streaming response
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata)
        }
        return
      }

      yield toPin(pin.Type, pin.Cid, pin.Metadata)
    }
  }
  return ls
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/add.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/add.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": function() { return /* binding */ createAdd; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-http-client/src/pin/remote/utils.js");


/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI
 */

/**
 * @param {import('../../lib/core').Client} client
 */
function createAdd (client) {
  /**
   * @type {RemotePiningAPI["add"]}
   */
  async function add (cid, { timeout, signal, headers, ...query }) {
    const response = await client.post('pin/remote/add', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeAddParams)({ cid, ...query })
    })

    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.decodePin)(await response.json())
  }

  return add
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRemote": function() { return /* binding */ createRemote; }
/* harmony export */ });
/* harmony import */ var _lib_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/core.js */ "./node_modules/ipfs-http-client/src/lib/core.js");
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ "./node_modules/ipfs-http-client/src/pin/remote/add.js");
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/pin/remote/ls.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/pin/remote/rm.js");
/* harmony import */ var _rm_all_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rm-all.js */ "./node_modules/ipfs-http-client/src/pin/remote/rm-all.js");
/* harmony import */ var _service_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./service/index.js */ "./node_modules/ipfs-http-client/src/pin/remote/service/index.js");







/**
 * @param {import('../../types').Options} config
 */
function createRemote (config) {
  const client = new _lib_core_js__WEBPACK_IMPORTED_MODULE_0__.Client(config)

  return {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_1__.createAdd)(client),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_2__.createLs)(client),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_3__.createRm)(client),
    rmAll: (0,_rm_all_js__WEBPACK_IMPORTED_MODULE_4__.createRmAll)(client),
    service: (0,_service_index_js__WEBPACK_IMPORTED_MODULE_5__.createService)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/ls.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/ls.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-http-client/src/pin/remote/utils.js");


/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI
 */

/**
 * @param {import('../../lib/core').Client} client
 */
function createLs (client) {
  /**
   * @type {RemotePiningAPI["ls"]}
   */
  async function * ls ({ timeout, signal, headers, ...query }) {
    const response = await client.post('pin/remote/ls', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeQuery)(query)
    })

    for await (const pin of response.ndjson()) {
      yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.decodePin)(pin)
    }
  }

  return ls
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/rm-all.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/rm-all.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRmAll": function() { return /* binding */ createRmAll; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-http-client/src/pin/remote/utils.js");


/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI
 */

/**
 * @param {import('../../lib/core').Client} client
 */
function createRmAll (client) {
  /**
   * @type {RemotePiningAPI["rmAll"]}
   */
  async function rmAll ({ timeout, signal, headers, ...query }) {
    await client.post('pin/remote/rm', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeQuery)({
        ...query,
        all: true
      })
    })
  }

  return rmAll
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/rm.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/rm.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-http-client/src/pin/remote/utils.js");


/**
 * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI
 */

/**
 * @param {import('../../lib/core').Client} client
 */
function createRm (client) {
  /**
   * @type {RemotePiningAPI["rm"]}
   */
  async function rm ({ timeout, signal, headers, ...query }) {
    await client.post('pin/remote/rm', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeQuery)({
        ...query,
        all: false
      })
    })
  }

  return rm
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/service/add.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/service/add.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": function() { return /* binding */ createAdd; }
/* harmony export */ });
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-http-client/src/pin/remote/service/utils.js");



/**
 * @typedef {import('../../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote/service').API<HTTPClientExtraOptions>} RemotePiningServiceAPI
 */

/**
 * @param {import('../../../lib/core').Client} client
 */
function createAdd (client) {
  /**
   * @type {RemotePiningServiceAPI["add"]}
   */
  async function add (name, options) {
    const { endpoint, key, headers, timeout, signal } = options

    await client.post('pin/remote/service/add', {
      timeout,
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__.toUrlSearchParams)({
        arg: [name, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.encodeEndpoint)(endpoint), key]
      }),
      headers
    })
  }

  return add
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/service/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/service/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createService": function() { return /* binding */ createService; }
/* harmony export */ });
/* harmony import */ var _lib_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/core.js */ "./node_modules/ipfs-http-client/src/lib/core.js");
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ "./node_modules/ipfs-http-client/src/pin/remote/service/add.js");
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/pin/remote/service/ls.js");
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rm.js */ "./node_modules/ipfs-http-client/src/pin/remote/service/rm.js");





/**
 * @param {import('../../../types').Options} config
 */
function createService (config) {
  const client = new _lib_core_js__WEBPACK_IMPORTED_MODULE_0__.Client(config)

  return {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_1__.createAdd)(client),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_2__.createLs)(client),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_3__.createRm)(client)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/service/ls.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/service/ls.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/ipfs-http-client/src/pin/remote/service/utils.js");



/**
 * @typedef {import('../../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote/service').API<HTTPClientExtraOptions>} RemotePiningServiceAPI
 */

/**
 * @param {import('../../../lib/core').Client} client
 */
function createLs (client) {
  /**
   * @type {RemotePiningServiceAPI["ls"]}
   */
  async function ls (options = {}) {
    // @ts-expect-error cannot derive option type from typedef
    const { stat, headers, timeout, signal } = options

    const response = await client.post('pin/remote/service/ls', {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__.toUrlSearchParams)({ stat }) : undefined
    })

    /** @type {{RemoteServices: object[]}} */
    const { RemoteServices } = await response.json()

    return RemoteServices.map(_utils_js__WEBPACK_IMPORTED_MODULE_1__.decodeRemoteService)
  }

  return ls
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/service/rm.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/service/rm.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");


/**
 * @typedef {import('../../../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin/remote/service').API<HTTPClientExtraOptions>} RemotePiningServiceAPI
 */

/**
 * @param {import('../../../lib/core').Client} client
 */
function createRm (client) {
  /**
   * @type {RemotePiningServiceAPI["rm"]}
   */
  async function rm (name, options = {}) {
    await client.post('pin/remote/service/rm', {
      signal: options.signal,
      headers: options.headers,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__.toUrlSearchParams)({
        arg: name
      })
    })
  }

  return rm
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/service/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/service/utils.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "encodeEndpoint": function() { return /* binding */ encodeEndpoint; },
/* harmony export */   "decodeRemoteService": function() { return /* binding */ decodeRemoteService; },
/* harmony export */   "decodeStat": function() { return /* binding */ decodeStat; }
/* harmony export */ });
/**
 * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinServiceWithStat} RemotePinServiceWithStat
 */

/**
 * @param {URL} url
 */
function encodeEndpoint (url) {
  const href = String(url)
  if (href === 'undefined') {
    throw Error('endpoint is required')
  }
  // Workaround trailing `/` issue in go-ipfs
  // @see https://github.com/ipfs/go-ipfs/issues/7826
  return href[href.length - 1] === '/' ? href.slice(0, -1) : href
}

/**
 * @param {any} json
 * @returns {RemotePinServiceWithStat}
 */
function decodeRemoteService (json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...(json.Stat && { stat: decodeStat(json.Stat) })
  }
}

/**
 * @param {any} json
 * @returns {import('ipfs-core-types/src/pin/remote/service').Stat}
 */
function decodeStat (json) {
  switch (json.Status) {
    case 'valid': {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount
      return {
        status: 'valid',
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      }
    }
    case 'invalid': {
      return { status: 'invalid' }
    }
    default: {
      return { status: json.Status }
    }
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/remote/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/remote/utils.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodePin": function() { return /* binding */ decodePin; },
/* harmony export */   "encodeService": function() { return /* binding */ encodeService; },
/* harmony export */   "encodeCID": function() { return /* binding */ encodeCID; },
/* harmony export */   "encodeQuery": function() { return /* binding */ encodeQuery; },
/* harmony export */   "encodeAddParams": function() { return /* binding */ encodeAddParams; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 * @typedef {import('ipfs-core-types/src/pin/remote').Pin} Pin
 * @typedef {import('ipfs-core-types/src/pin/remote').AddOptions} AddOptions
 * @typedef {import('ipfs-core-types/src/pin/remote').Query} Query
 * @typedef {import('ipfs-core-types/src/pin/remote').Status} Status
 */

/**
 * @param {object} json
 * @param {string} json.Name
 * @param {string} json.Cid
 * @param {Status} json.Status
 * @returns {Pin}
 */
const decodePin = ({ Name: name, Status: status, Cid: cid }) => {
  return {
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid),
    name,
    status
  }
}

/**
 * @param {any} service
 * @returns {string}
 */
const encodeService = (service) => {
  if (typeof service === 'string' && service !== '') {
    return service
  } else {
    throw new TypeError('service name must be passed')
  }
}

/**
 * @param {any} cid
 * @returns {string}
 */
const encodeCID = (cid) => {
  if (multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(cid)) {
    return cid.toString()
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`)
  }
}

/**
 * @param {Query & { all?: boolean }} query
 * @returns {URLSearchParams}
 */
const encodeQuery = ({ service, cid, name, status, all }) => {
  const query = (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
    service: encodeService(service),
    name,
    force: all ? true : undefined
  })

  if (cid) {
    for (const value of cid) {
      query.append('cid', encodeCID(value))
    }
  }

  if (status) {
    for (const value of status) {
      query.append('status', value)
    }
  }

  return query
}

/**
 * @param {AddOptions & {cid:CID}} options
 * @returns {URLSearchParams}
 */
const encodeAddParams = ({ cid, service, background, name, origins }) => {
  const params = (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
    arg: encodeCID(cid),
    service: encodeService(service),
    name,
    background: background ? true : undefined
  })

  if (origins) {
    for (const origin of origins) {
      params.append('origin', origin.toString())
    }
  }

  return params
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/rm-all.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/rm-all.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRmAll": function() { return /* binding */ createRmAll; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/pins/normalise-input */ "./node_modules/ipfs-core-utils/src/pins/normalise-input.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI
 */

const createRmAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {PinAPI["rmAll"]}
   */
  async function * rmAll (source, options = {}) {
    for await (const { path, recursive } of (0,ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__.normaliseInput)(source)) {
      const searchParams = new URLSearchParams(options.searchParams)
      searchParams.append('arg', `${path}`)

      if (recursive != null) searchParams.set('recursive', String(recursive))

      const res = await api.post('pin/rm', {
        signal: options.signal,
        headers: options.headers,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
          ...options,
          arg: `${path}`,
          recursive
        })
      })

      for await (const pin of res.ndjson()) {
        if (pin.Pins) { // non-streaming response
          yield * pin.Pins.map((/** @type {string} */ cid) => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid))
          continue
        }
        yield multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(pin)
      }
    }
  }
  return rmAll
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pin/rm.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pin/rm.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": function() { return /* binding */ createRm; }
/* harmony export */ });
/* harmony import */ var _rm_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rm-all.js */ "./node_modules/ipfs-http-client/src/pin/rm-all.js");
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ "it-last");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI
 */

/**
 * @param {import('../types').Options} config
 */
const createRm = (config) => {
  const all = (0,_rm_all_js__WEBPACK_IMPORTED_MODULE_0__.createRmAll)(config)

  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(() => {
    /**
     * @type {PinAPI["rm"]}
     */
    async function rm (path, options = {}) {
      // @ts-expect-error last can return undefined
      return it_last__WEBPACK_IMPORTED_MODULE_1__(all([{
        path,
        ...options
      }], options))
    }
    return rm
  })(config)
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/ping.js":
/*!***************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/ping.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPing": function() { return /* binding */ createPing; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createPing = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {RootAPI["ping"]}
   */
  async function * ping (peerId, options = {}) {
    const res = await api.post('ping', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel
    })

    yield * res.ndjson()
  }
  return ping
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPubsub": function() { return /* binding */ createPubsub; }
/* harmony export */ });
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ls.js */ "./node_modules/ipfs-http-client/src/pubsub/ls.js");
/* harmony import */ var _peers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./peers.js */ "./node_modules/ipfs-http-client/src/pubsub/peers.js");
/* harmony import */ var _publish_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./publish.js */ "./node_modules/ipfs-http-client/src/pubsub/publish.js");
/* harmony import */ var _subscribe_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./subscribe.js */ "./node_modules/ipfs-http-client/src/pubsub/subscribe.js");
/* harmony import */ var _unsubscribe_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unsubscribe.js */ "./node_modules/ipfs-http-client/src/pubsub/unsubscribe.js");
/* harmony import */ var _subscription_tracker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./subscription-tracker.js */ "./node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js");







/**
 * @param {import('../types').Options} config
 */
function createPubsub (config) {
  const subscriptionTracker = new _subscription_tracker_js__WEBPACK_IMPORTED_MODULE_5__.SubscriptionTracker()

  return {
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_0__.createLs)(config),
    peers: (0,_peers_js__WEBPACK_IMPORTED_MODULE_1__.createPeers)(config),
    publish: (0,_publish_js__WEBPACK_IMPORTED_MODULE_2__.createPublish)(config),
    subscribe: (0,_subscribe_js__WEBPACK_IMPORTED_MODULE_3__.createSubscribe)(config, subscriptionTracker),
    unsubscribe: (0,_unsubscribe_js__WEBPACK_IMPORTED_MODULE_4__.createUnsubscribe)(config, subscriptionTracker)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/ls.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/ls.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": function() { return /* binding */ createLs; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/http-rpc-wire-format.js */ "./node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI
 */

const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {PubsubAPI["ls"]}
   */
  async function ls (options = {}) {
    const { Strings } = await (await api.post('pubsub/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })).json()

    return (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_2__.rpcArrayToTextArray)(Strings) || []
  }
  return ls
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/peers.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/peers.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPeers": function() { return /* binding */ createPeers; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/http-rpc-wire-format.js */ "./node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI
 */

const createPeers = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {PubsubAPI["peers"]}
   */
  async function peers (topic, options = {}) {
    const res = await api.post('pubsub/peers', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_2__.textToUrlSafeRpc)(topic),
        ...options
      }),
      headers: options.headers
    })

    const { Strings } = await res.json()

    return Strings || []
  }
  return peers
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/publish.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/publish.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPublish": function() { return /* binding */ createPublish; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ "./node_modules/ipfs-core-utils/src/multipart-request.js");
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/abort-signal.js */ "./node_modules/ipfs-http-client/src/lib/abort-signal.js");
/* harmony import */ var _lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/http-rpc-wire-format.js */ "./node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js");






/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI
 */

const createPublish = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {PubsubAPI["publish"]}
   */
  async function publish (topic, data, options = {}) {
    const searchParams = (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
      arg: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_4__.textToUrlSafeRpc)(topic),
      ...options
    })

    // allow aborting requests on body errors
    const controller = new AbortController()
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_3__.abortSignal)(controller.signal, options.signal)

    const res = await api.post('pubsub/pub', {
      signal,
      searchParams,
      ...(
        await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__.multipartRequest)([data], controller, options.headers)
      )
    })

    await res.text()
  }
  return publish
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/subscribe.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/subscribe.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSubscribe": function() { return /* binding */ createSubscribe; }
/* harmony export */ });
/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libp2p/logger */ "./node_modules/@libp2p/logger/dist/src/index.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/http-rpc-wire-format.js */ "./node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js");
/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/peer-id */ "./node_modules/@libp2p/peer-id/dist/src/index.js");





const log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_0__.logger)('ipfs-http-client:pubsub:subscribe')

/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('@libp2p/interface-pubsub').Message} Message
 * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn
 * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI
 * @typedef {import('../types').Options} Options
 */

/**
 * @param {Options} options
 * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker
 */
const createSubscribe = (options, subsTracker) => {
  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)((api) => {
    /**
     * @type {PubsubAPI["subscribe"]}
     */
    async function subscribe (topic, handler, options = {}) { // eslint-disable-line require-await
      options.signal = subsTracker.subscribe(topic, handler, options.signal)

      /** @type {(value?: any) => void} */
      let done
      /** @type {(error: Error) => void} */
      let fail

      const result = new Promise((resolve, reject) => {
        done = resolve
        fail = reject
      })

      // In Firefox, the initial call to fetch does not resolve until some data
      // is received. If this doesn't happen within 1 second assume success
      const ffWorkaround = setTimeout(() => done(), 1000)

      // Do this async to not block Firefox
      api.post('pubsub/sub', {
        signal: options.signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
          arg: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.textToUrlSafeRpc)(topic),
          ...options
        }),
        headers: options.headers
      })
        .catch((err) => {
          // Initial subscribe fail, ensure we clean up
          subsTracker.unsubscribe(topic, handler)

          fail(err)
        })
        .then((response) => {
          clearTimeout(ffWorkaround)

          if (!response) {
            // if there was no response, the subscribe failed
            return
          }

          readMessages(response, {
            onMessage: (message) => {
              if (!handler) {
                return
              }

              if (typeof handler === 'function') {
                handler(message)
                return
              }

              if (typeof handler.handleEvent === 'function') {
                handler.handleEvent(message)
              }
            },
            onEnd: () => subsTracker.unsubscribe(topic, handler),
            onError: options.onError
          })

          done()
        })

      return result
    }
    return subscribe
  })(options)
}

/**
 * @param {import('ipfs-utils/src/types').ExtendedResponse} response
 * @param {object} options
 * @param {(message: Message) => void} options.onMessage
 * @param {() => void} options.onEnd
 * @param {ErrorHandlerFn} [options.onError]
 */
async function readMessages (response, { onMessage, onEnd, onError }) {
  onError = onError || log

  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue
        }

        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: 'signed',
            from: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_4__.peerIdFromString)(msg.from),
            data: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToBytes)(msg.data),
            sequenceNumber: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToBigInt)(msg.seqno),
            topic: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToText)(msg.topicIDs[0]),
            key: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToBytes)(msg.key ?? 'u'),
            signature: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToBytes)(msg.signature ?? 'u')
          })
        } else {
          onMessage({
            type: 'unsigned',
            data: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToBytes)(msg.data),
            topic: (0,_lib_http_rpc_wire_format_js__WEBPACK_IMPORTED_MODULE_3__.rpcToText)(msg.topicIDs[0])
          })
        }
      } catch (/** @type {any} */ err) {
        err.message = `Failed to parse pubsub message: ${err.message}`
        onError(err, false, msg) // Not fatal
      }
    }
  } catch (/** @type {any} */ err) {
    if (!isAbortError(err)) {
      onError(err, true) // Fatal
    }
  } finally {
    onEnd()
  }
}

/**
 * @param {Error & {type?:string}} error
 * @returns {boolean}
 */
const isAbortError = error => {
  switch (error.type) {
    case 'aborted':
      return true
    // It is `abort` in Electron instead of `aborted`
    case 'abort':
      return true
    default:
      // FIXME: In testing with Chrome, err.type is undefined (should not be!)
      // Temporarily use the name property instead.
      return error.name === 'AbortError'
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubscriptionTracker": function() { return /* binding */ SubscriptionTracker; }
/* harmony export */ });

/**
 * @typedef {import('@libp2p/interface-pubsub').Message} Message
 * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageHandlerFn
 *
 * @typedef {object} Subscription
 * @property {MessageHandlerFn} handler
 * @property {AbortController} controller
 */

class SubscriptionTracker {
  constructor () {
    /** @type {Map<string, Subscription[]>} */
    this._subs = new Map()
  }

  /**
   * @param {string} topic
   * @param {MessageHandlerFn} handler
   * @param {AbortSignal} [signal]
   */
  subscribe (topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || []

    if (topicSubs.find(s => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`)
    }

    // Create controller so a call to unsubscribe can cancel the request
    const controller = new AbortController()

    this._subs.set(topic, [{ handler, controller }].concat(topicSubs))

    // If there is an external signal, forward the abort event
    if (signal) {
      signal.addEventListener('abort', () => this.unsubscribe(topic, handler))
    }

    return controller.signal
  }

  /**
   * @param {string} topic
   * @param {MessageHandlerFn} [handler]
   */
  unsubscribe (topic, handler) {
    const subs = this._subs.get(topic) || []
    let unsubs

    if (handler) {
      this._subs.set(topic, subs.filter(s => s.handler !== handler))
      unsubs = subs.filter(s => s.handler === handler)
    } else {
      this._subs.set(topic, [])
      unsubs = subs
    }

    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic)
    }

    unsubs.forEach(s => s.controller.abort())
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/pubsub/unsubscribe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/pubsub/unsubscribe.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createUnsubscribe": function() { return /* binding */ createUnsubscribe; }
/* harmony export */ });

/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI
 * @typedef {import('../types').Options} Options
 */

/**
 * @param {Options} options
 * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker
 */
const createUnsubscribe = (options, subsTracker) => {
  /**
   * @type {PubsubAPI["unsubscribe"]}
   */
  async function unsubscribe (topic, handler) {
    subsTracker.unsubscribe(topic, handler)
  }
  return unsubscribe
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/refs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/refs/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRefs": function() { return /* binding */ createRefs; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./local.js */ "./node_modules/ipfs-http-client/src/refs/local.js");






/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/refs').API<HTTPClientExtraOptions>} RefsAPI
 */

const createRefs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)((api, opts) => {
  /**
   * @type {RefsAPI["refs"]}
   */
  const refs = async function * (args, options = {}) {
    /** @type {import('ipfs-core-types/src/utils').IPFSPath[]} */
    const argsArr = Array.isArray(args) ? args : [args]

    const res = await api.post('refs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: argsArr.map(arg => `${arg instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel
    })

    yield * res.ndjson()
  }

  return Object.assign(refs, {
    local: (0,_local_js__WEBPACK_IMPORTED_MODULE_4__.createLocal)(opts)
  })
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/refs/local.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/refs/local.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLocal": function() { return /* binding */ createLocal; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/refs').API<HTTPClientExtraOptions>} RefsAPI
 */

const createLocal = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {RefsAPI["local"]}
   */
  async function * refsLocal (options = {}) {
    const res = await api.post('refs/local', {
      signal: options.signal,
      transform: _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    yield * res.ndjson()
  }
  return refsLocal
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/repo/gc.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/repo/gc.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGc": function() { return /* binding */ createGc; }
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ "multiformats/cid");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/repo').API<HTTPClientExtraOptions>} RepoAPI
 */

const createGc = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {RepoAPI["gc"]}
   */
  async function * gc (options = {}) {
    const res = await api.post('repo/gc', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers,
      transform: (res) => {
        return {
          err: res.Error ? new Error(res.Error) : null,
          cid: (res.Key || {})['/'] ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(res.Key['/']) : null
        }
      }
    })

    yield * res.ndjson()
  }
  return gc
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/repo/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/repo/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRepo": function() { return /* binding */ createRepo; }
/* harmony export */ });
/* harmony import */ var _gc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gc.js */ "./node_modules/ipfs-http-client/src/repo/gc.js");
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stat.js */ "./node_modules/ipfs-http-client/src/repo/stat.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version.js */ "./node_modules/ipfs-http-client/src/repo/version.js");




/**
 * @param {import('../types').Options} config
 */
function createRepo (config) {
  return {
    gc: (0,_gc_js__WEBPACK_IMPORTED_MODULE_0__.createGc)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_1__.createStat)(config),
    version: (0,_version_js__WEBPACK_IMPORTED_MODULE_2__.createVersion)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/repo/stat.js":
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/repo/stat.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": function() { return /* binding */ createStat; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/repo').API<HTTPClientExtraOptions>} RepoAPI
 */

const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RepoAPI["stat"]}
   */
  async function stat (options = {}) {
    const res = await api.post('repo/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })
    const data = await res.json()

    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    }
  }
  return stat
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/repo/version.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/repo/version.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVersion": function() { return /* binding */ createVersion; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/repo').API<HTTPClientExtraOptions>} RepoAPI
 */

const createVersion = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RepoAPI["version"]}
   */
  async function version (options = {}) {
    const res = await (await api.post('repo/version', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })).json()

    return res.Version
  }
  return version
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/resolve.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/resolve.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createResolve": function() { return /* binding */ createResolve; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createResolve = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RootAPI["resolve"]}
   */
  async function resolve (path, options = {}) {
    const res = await api.post('resolve', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    })
    const { Path } = await res.json()
    return Path
  }
  return resolve
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/start.js":
/*!****************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/start.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStart": function() { return /* binding */ createStart; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ "err-code");



/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createStart = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RootAPI["start"]}
   */
  const start = async (options = {}) => {
    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED')
  }

  return start
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/stats/bw.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/stats/bw.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBw": function() { return /* binding */ createBw; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/stats').API<HTTPClientExtraOptions>} StatsAPI
 */

const createBw = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {StatsAPI["bw"]}
   */
  async function * bw (options = {}) {
    const res = await api.post('stats/bw', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    })

    yield * res.ndjson()
  }
  return bw
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/stats/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/stats/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStats": function() { return /* binding */ createStats; }
/* harmony export */ });
/* harmony import */ var _bitswap_stat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bitswap/stat.js */ "./node_modules/ipfs-http-client/src/bitswap/stat.js");
/* harmony import */ var _repo_stat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../repo/stat.js */ "./node_modules/ipfs-http-client/src/repo/stat.js");
/* harmony import */ var _bw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bw.js */ "./node_modules/ipfs-http-client/src/stats/bw.js");




/**
 * @param {import('../types').Options} config
 */
function createStats (config) {
  return {
    bitswap: (0,_bitswap_stat_js__WEBPACK_IMPORTED_MODULE_0__.createStat)(config),
    repo: (0,_repo_stat_js__WEBPACK_IMPORTED_MODULE_1__.createStat)(config),
    bw: (0,_bw_js__WEBPACK_IMPORTED_MODULE_2__.createBw)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/stop.js":
/*!***************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/stop.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStop": function() { return /* binding */ createStop; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createStop = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {RootAPI["stop"]}
   */
  async function stop (options = {}) {
    const res = await api.post('shutdown', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })

    await res.text()
  }
  return stop
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/swarm/addrs.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/swarm/addrs.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddrs": function() { return /* binding */ createAddrs; }
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-id */ "./node_modules/@libp2p/peer-id/dist/src/index.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI
 */

const createAddrs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {SwarmAPI["addrs"]}
   */
  async function addrs (options = {}) {
    const res = await api.post('swarm/addrs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    /** @type {{ Addrs: Record<string, string[]> }} */
    const { Addrs } = await res.json()

    return Object.keys(Addrs).map(id => ({
      id: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(id),
      addrs: (Addrs[id] || []).map(a => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a))
    }))
  }
  return addrs
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/swarm/connect.js":
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/swarm/connect.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createConnect": function() { return /* binding */ createConnect; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI
 */

const createConnect = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {SwarmAPI["connect"]}
   */
  async function connect (addr, options = {}) {
    const res = await api.post('swarm/connect', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    })
    const { Strings } = await res.json()

    return Strings || []
  }
  return connect
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/swarm/disconnect.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/swarm/disconnect.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDisconnect": function() { return /* binding */ createDisconnect; }
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");



/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI
 */

const createDisconnect = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  /**
   * @type {SwarmAPI["disconnect"]}
   */
  async function disconnect (addr, options = {}) {
    const res = await api.post('swarm/disconnect', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    })
    const { Strings } = await res.json()

    return Strings || []
  }
  return disconnect
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/swarm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/swarm/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSwarm": function() { return /* binding */ createSwarm; }
/* harmony export */ });
/* harmony import */ var _addrs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addrs.js */ "./node_modules/ipfs-http-client/src/swarm/addrs.js");
/* harmony import */ var _connect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connect.js */ "./node_modules/ipfs-http-client/src/swarm/connect.js");
/* harmony import */ var _disconnect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./disconnect.js */ "./node_modules/ipfs-http-client/src/swarm/disconnect.js");
/* harmony import */ var _local_addrs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./local-addrs.js */ "./node_modules/ipfs-http-client/src/swarm/local-addrs.js");
/* harmony import */ var _peers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./peers.js */ "./node_modules/ipfs-http-client/src/swarm/peers.js");






/**
 * @param {import('../types').Options} config
 */
function createSwarm (config) {
  return {
    addrs: (0,_addrs_js__WEBPACK_IMPORTED_MODULE_0__.createAddrs)(config),
    connect: (0,_connect_js__WEBPACK_IMPORTED_MODULE_1__.createConnect)(config),
    disconnect: (0,_disconnect_js__WEBPACK_IMPORTED_MODULE_2__.createDisconnect)(config),
    localAddrs: (0,_local_addrs_js__WEBPACK_IMPORTED_MODULE_3__.createLocalAddrs)(config),
    peers: (0,_peers_js__WEBPACK_IMPORTED_MODULE_4__.createPeers)(config)
  }
}


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/swarm/local-addrs.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/swarm/local-addrs.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLocalAddrs": function() { return /* binding */ createLocalAddrs; }
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI
 */

const createLocalAddrs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {SwarmAPI["localAddrs"]}
   */
  async function localAddrs (options = {}) {
    const res = await api.post('swarm/addrs/local', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    /** @type {{ Strings: string[] }} */
    const { Strings } = await res.json()

    return (Strings || []).map(a => (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a))
  }
  return localAddrs
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/swarm/peers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/swarm/peers.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPeers": function() { return /* binding */ createPeers; }
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");
/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-id */ "./node_modules/@libp2p/peer-id/dist/src/index.js");





/**
 * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI
 */

const createPeers = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {SwarmAPI["peers"]}
   */
  async function peers (options = {}) {
    const res = await api.post('swarm/peers', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    /** @type {{ Peers: { Peer: string, Addr: string, Muxer?: string, Latency?: string, Streams?: string[], Direction?: 0 | 1 }[] }} */
    const { Peers } = await res.json()

    return (Peers || []).map(peer => {
      return {
        addr: (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(peer.Addr),
        peer: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_3__.peerIdFromString)(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? undefined : peer.Direction === 0 ? 'inbound' : 'outbound'
      }
    })
  }
  return peers
})


/***/ }),

/***/ "./node_modules/ipfs-http-client/src/version.js":
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/src/version.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVersion": function() { return /* binding */ createVersion; }
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ "./node_modules/ipfs-http-client/src/lib/object-to-camel.js");
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ "./node_modules/ipfs-http-client/src/lib/configure.js");
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ "./node_modules/ipfs-http-client/src/lib/to-url-search-params.js");




/**
 * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions
 * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI
 */

const createVersion = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  /**
   * @type {RootAPI["version"]}
   */
  async function version (options = {}) {
    const res = await api.post('version', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })

    // @ts-expect-error server output is not typed
    return {
      ...(0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json()),
      'ipfs-http-client': '1.0.0'
    }
  }

  return version
})


/***/ }),

/***/ "./node_modules/ipfs-unixfs/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ipfs-unixfs/src/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseMode": function() { return /* binding */ parseMode; },
/* harmony export */   "parseMtime": function() { return /* binding */ parseMtime; },
/* harmony export */   "UnixFS": function() { return /* binding */ UnixFS; }
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ "err-code");
/* harmony import */ var _unixfs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unixfs.js */ "./node_modules/ipfs-unixfs/src/unixfs.js");


const PBData = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data

/**
 * @typedef {import('./types').Mtime} Mtime
 * @typedef {import('./types').MtimeLike} MtimeLike
 */

const types = [
  'raw',
  'directory',
  'file',
  'metadata',
  'symlink',
  'hamt-sharded-directory'
]

const dirTypes = [
  'directory',
  'hamt-sharded-directory'
]

const DEFAULT_FILE_MODE = parseInt('0644', 8)
const DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)

/**
 * @param {string | number | undefined} [mode]
 */
function parseMode (mode) {
  if (mode == null) {
    return undefined
  }

  if (typeof mode === 'number') {
    return mode & 0xFFF
  }

  mode = mode.toString()

  if (mode.substring(0, 1) === '0') {
    // octal string
    return parseInt(mode, 8) & 0xFFF
  }

  // decimal string
  return parseInt(mode, 10) & 0xFFF
}

/**
 * @param {any} input
 */
function parseMtime (input) {
  if (input == null) {
    return undefined
  }

  /** @type {Mtime | undefined} */
  let mtime

  // { secs, nsecs }
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    }
  }

  // UnixFS TimeSpec
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    }
  }

  // process.hrtime()
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    }
  }

  // Javascript Date
  if (input instanceof Date) {
    const ms = input.getTime()
    const secs = Math.floor(ms / 1000)

    mtime = {
      secs: secs,
      nsecs: (ms - (secs * 1000)) * 1000
    }
  }

  /*
  TODO: https://github.com/ipfs/aegir/issues/487

  // process.hrtime.bigint()
  if (input instanceof BigInt) {
    const secs = input / BigInt(1e9)
    const nsecs = input - (secs * BigInt(1e9))

    mtime = {
      secs: parseInt(secs.toString()),
      nsecs: parseInt(nsecs.toString())
    }
  }
  */

  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
    return undefined
  }

  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS')
  }

  return mtime
}

class UnixFS {
  /**
   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
   *
   * @param {Uint8Array} marshaled
   */
  static unmarshal (marshaled) {
    const message = PBData.decode(marshaled)
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    })

    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime
        ? {
            secs: decoded.mtime.Seconds,
            nsecs: decoded.mtime.FractionalNanoseconds
          }
        : undefined
    })

    // make sure we honour the original mode
    data._originalMode = decoded.mode || 0

    return data
  }

  /**
   * @param {object} [options]
   * @param {string} [options.type='file']
   * @param {Uint8Array} [options.data]
   * @param {number[]} [options.blockSizes]
   * @param {number} [options.hashType]
   * @param {number} [options.fanout]
   * @param {MtimeLike | null} [options.mtime]
   * @param {number | string} [options.mode]
   */
  constructor (options = {
    type: 'file'
  }) {
    const {
      type,
      data,
      blockSizes,
      hashType,
      fanout,
      mtime,
      mode
    } = options

    if (type && !types.includes(type)) {
      throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')
    }

    this.type = type || 'file'
    this.data = data
    this.hashType = hashType
    this.fanout = fanout

    /** @type {number[]} */
    this.blockSizes = blockSizes || []
    this._originalMode = 0
    this.mode = parseMode(mode)

    if (mtime) {
      this.mtime = parseMtime(mtime)

      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0
      }
    }
  }

  /**
   * @param {number | undefined} mode
   */
  set mode (mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE

    const parsedMode = parseMode(mode)

    if (parsedMode !== undefined) {
      this._mode = parsedMode
    }
  }

  /**
   * @returns {number | undefined}
   */
  get mode () {
    return this._mode
  }

  isDirectory () {
    return Boolean(this.type && dirTypes.includes(this.type))
  }

  /**
   * @param {number} size
   */
  addBlockSize (size) {
    this.blockSizes.push(size)
  }

  /**
   * @param {number} index
   */
  removeBlockSize (index) {
    this.blockSizes.splice(index, 1)
  }

  /**
   * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else
   */
  fileSize () {
    if (this.isDirectory()) {
      // dirs don't have file size
      return 0
    }

    let sum = 0
    this.blockSizes.forEach((size) => {
      sum += size
    })

    if (this.data) {
      sum += this.data.length
    }

    return sum
  }

  /**
   * encode to protobuf Uint8Array
   */
  marshal () {
    let type

    switch (this.type) {
      case 'raw': type = PBData.DataType.Raw; break
      case 'directory': type = PBData.DataType.Directory; break
      case 'file': type = PBData.DataType.File; break
      case 'metadata': type = PBData.DataType.Metadata; break
      case 'symlink': type = PBData.DataType.Symlink; break
      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break
      default:
        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')
    }

    let data = this.data

    if (!this.data || !this.data.length) {
      data = undefined
    }

    let mode

    if (this.mode != null) {
      mode = (this._originalMode & 0xFFFFF000) | (parseMode(this.mode) || 0)

      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = undefined
      }

      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = undefined
      }
    }

    let mtime

    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime)

      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        }

        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds
        }
      }
    }

    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? undefined : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    }

    return PBData.encode(pbData).finish()
  }
}




/***/ }),

/***/ "./node_modules/ipfs-unixfs/src/unixfs.js":
/*!************************************************!*\
  !*** ./node_modules/ipfs-unixfs/src/unixfs.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Data": function() { return /* binding */ Data; },
/* harmony export */   "UnixTime": function() { return /* binding */ UnixTime; },
/* harmony export */   "Metadata": function() { return /* binding */ Metadata; },
/* harmony export */   "default": function() { return /* binding */ $root; }
/* harmony export */ });
/* harmony import */ var protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal.js */ "protobufjs/minimal.js");
/*eslint-disable*/


// Common aliases
const $Reader = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.Reader, $Writer = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.Writer, $util = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util;

// Exported root namespace
const $root = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.roots["ipfs-unixfs"] || (protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.roots["ipfs-unixfs"] = {});

const Data = $root.Data = (() => {

    /**
     * Properties of a Data.
     * @exports IData
     * @interface IData
     * @property {Data.DataType} Type Data Type
     * @property {Uint8Array|null} [Data] Data Data
     * @property {number|null} [filesize] Data filesize
     * @property {Array.<number>|null} [blocksizes] Data blocksizes
     * @property {number|null} [hashType] Data hashType
     * @property {number|null} [fanout] Data fanout
     * @property {number|null} [mode] Data mode
     * @property {IUnixTime|null} [mtime] Data mtime
     */

    /**
     * Constructs a new Data.
     * @exports Data
     * @classdesc Represents a Data.
     * @implements IData
     * @constructor
     * @param {IData=} [p] Properties to set
     */
    function Data(p) {
        this.blocksizes = [];
        if (p)
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                    this[ks[i]] = p[ks[i]];
    }

    /**
     * Data Type.
     * @member {Data.DataType} Type
     * @memberof Data
     * @instance
     */
    Data.prototype.Type = 0;

    /**
     * Data Data.
     * @member {Uint8Array} Data
     * @memberof Data
     * @instance
     */
    Data.prototype.Data = $util.newBuffer([]);

    /**
     * Data filesize.
     * @member {number} filesize
     * @memberof Data
     * @instance
     */
    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Data blocksizes.
     * @member {Array.<number>} blocksizes
     * @memberof Data
     * @instance
     */
    Data.prototype.blocksizes = $util.emptyArray;

    /**
     * Data hashType.
     * @member {number} hashType
     * @memberof Data
     * @instance
     */
    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Data fanout.
     * @member {number} fanout
     * @memberof Data
     * @instance
     */
    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Data mode.
     * @member {number} mode
     * @memberof Data
     * @instance
     */
    Data.prototype.mode = 0;

    /**
     * Data mtime.
     * @member {IUnixTime|null|undefined} mtime
     * @memberof Data
     * @instance
     */
    Data.prototype.mtime = null;

    /**
     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.
     * @function encode
     * @memberof Data
     * @static
     * @param {IData} m Data message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Data.encode = function encode(m, w) {
        if (!w)
            w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
            w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
            w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
            for (var i = 0; i < m.blocksizes.length; ++i)
                w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
            w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
            w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
            w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
            $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
    };

    /**
     * Decodes a Data message from the specified reader or buffer.
     * @function decode
     * @memberof Data
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Data} Data
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Data.decode = function decode(r, l) {
        if (!(r instanceof $Reader))
            r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
        while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
            case 1:
                m.Type = r.int32();
                break;
            case 2:
                m.Data = r.bytes();
                break;
            case 3:
                m.filesize = r.uint64();
                break;
            case 4:
                if (!(m.blocksizes && m.blocksizes.length))
                    m.blocksizes = [];
                if ((t & 7) === 2) {
                    var c2 = r.uint32() + r.pos;
                    while (r.pos < c2)
                        m.blocksizes.push(r.uint64());
                } else
                    m.blocksizes.push(r.uint64());
                break;
            case 5:
                m.hashType = r.uint64();
                break;
            case 6:
                m.fanout = r.uint64();
                break;
            case 7:
                m.mode = r.uint32();
                break;
            case 8:
                m.mtime = $root.UnixTime.decode(r, r.uint32());
                break;
            default:
                r.skipType(t & 7);
                break;
            }
        }
        if (!m.hasOwnProperty("Type"))
            throw $util.ProtocolError("missing required 'Type'", { instance: m });
        return m;
    };

    /**
     * Creates a Data message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Data
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Data} Data
     */
    Data.fromObject = function fromObject(d) {
        if (d instanceof $root.Data)
            return d;
        var m = new $root.Data();
        switch (d.Type) {
        case "Raw":
        case 0:
            m.Type = 0;
            break;
        case "Directory":
        case 1:
            m.Type = 1;
            break;
        case "File":
        case 2:
            m.Type = 2;
            break;
        case "Metadata":
        case 3:
            m.Type = 3;
            break;
        case "Symlink":
        case 4:
            m.Type = 4;
            break;
        case "HAMTShard":
        case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
            if (typeof d.Data === "string")
                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length)
                m.Data = d.Data;
        }
        if (d.filesize != null) {
            if ($util.Long)
                (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
            else if (typeof d.filesize === "string")
                m.filesize = parseInt(d.filesize, 10);
            else if (typeof d.filesize === "number")
                m.filesize = d.filesize;
            else if (typeof d.filesize === "object")
                m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
            if (!Array.isArray(d.blocksizes))
                throw TypeError(".Data.blocksizes: array expected");
            m.blocksizes = [];
            for (var i = 0; i < d.blocksizes.length; ++i) {
                if ($util.Long)
                    (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
                else if (typeof d.blocksizes[i] === "string")
                    m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
                else if (typeof d.blocksizes[i] === "number")
                    m.blocksizes[i] = d.blocksizes[i];
                else if (typeof d.blocksizes[i] === "object")
                    m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
            }
        }
        if (d.hashType != null) {
            if ($util.Long)
                (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
            else if (typeof d.hashType === "string")
                m.hashType = parseInt(d.hashType, 10);
            else if (typeof d.hashType === "number")
                m.hashType = d.hashType;
            else if (typeof d.hashType === "object")
                m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
            if ($util.Long)
                (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
            else if (typeof d.fanout === "string")
                m.fanout = parseInt(d.fanout, 10);
            else if (typeof d.fanout === "number")
                m.fanout = d.fanout;
            else if (typeof d.fanout === "object")
                m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
            m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
            if (typeof d.mtime !== "object")
                throw TypeError(".Data.mtime: object expected");
            m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
    };

    /**
     * Creates a plain object from a Data message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Data
     * @static
     * @param {Data} m Data
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Data.toObject = function toObject(m, o) {
        if (!o)
            o = {};
        var d = {};
        if (o.arrays || o.defaults) {
            d.blocksizes = [];
        }
        if (o.defaults) {
            d.Type = o.enums === String ? "Raw" : 0;
            if (o.bytes === String)
                d.Data = "";
            else {
                d.Data = [];
                if (o.bytes !== Array)
                    d.Data = $util.newBuffer(d.Data);
            }
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else
                d.filesize = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else
                d.hashType = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else
                d.fanout = o.longs === String ? "0" : 0;
            d.mode = 0;
            d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
            if (typeof m.filesize === "number")
                d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
            else
                d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
            d.blocksizes = [];
            for (var j = 0; j < m.blocksizes.length; ++j) {
                if (typeof m.blocksizes[j] === "number")
                    d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
                else
                    d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
            }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
            if (typeof m.hashType === "number")
                d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
            else
                d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
            if (typeof m.fanout === "number")
                d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
            else
                d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
            d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
            d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
    };

    /**
     * Converts this Data to JSON.
     * @function toJSON
     * @memberof Data
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Data.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util.toJSONOptions);
    };

    /**
     * DataType enum.
     * @name Data.DataType
     * @enum {number}
     * @property {number} Raw=0 Raw value
     * @property {number} Directory=1 Directory value
     * @property {number} File=2 File value
     * @property {number} Metadata=3 Metadata value
     * @property {number} Symlink=4 Symlink value
     * @property {number} HAMTShard=5 HAMTShard value
     */
    Data.DataType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Raw"] = 0;
        values[valuesById[1] = "Directory"] = 1;
        values[valuesById[2] = "File"] = 2;
        values[valuesById[3] = "Metadata"] = 3;
        values[valuesById[4] = "Symlink"] = 4;
        values[valuesById[5] = "HAMTShard"] = 5;
        return values;
    })();

    return Data;
})();

const UnixTime = $root.UnixTime = (() => {

    /**
     * Properties of an UnixTime.
     * @exports IUnixTime
     * @interface IUnixTime
     * @property {number} Seconds UnixTime Seconds
     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds
     */

    /**
     * Constructs a new UnixTime.
     * @exports UnixTime
     * @classdesc Represents an UnixTime.
     * @implements IUnixTime
     * @constructor
     * @param {IUnixTime=} [p] Properties to set
     */
    function UnixTime(p) {
        if (p)
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                    this[ks[i]] = p[ks[i]];
    }

    /**
     * UnixTime Seconds.
     * @member {number} Seconds
     * @memberof UnixTime
     * @instance
     */
    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * UnixTime FractionalNanoseconds.
     * @member {number} FractionalNanoseconds
     * @memberof UnixTime
     * @instance
     */
    UnixTime.prototype.FractionalNanoseconds = 0;

    /**
     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.
     * @function encode
     * @memberof UnixTime
     * @static
     * @param {IUnixTime} m UnixTime message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UnixTime.encode = function encode(m, w) {
        if (!w)
            w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
            w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
    };

    /**
     * Decodes an UnixTime message from the specified reader or buffer.
     * @function decode
     * @memberof UnixTime
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {UnixTime} UnixTime
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UnixTime.decode = function decode(r, l) {
        if (!(r instanceof $Reader))
            r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();
        while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
            case 1:
                m.Seconds = r.int64();
                break;
            case 2:
                m.FractionalNanoseconds = r.fixed32();
                break;
            default:
                r.skipType(t & 7);
                break;
            }
        }
        if (!m.hasOwnProperty("Seconds"))
            throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
    };

    /**
     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UnixTime
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {UnixTime} UnixTime
     */
    UnixTime.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime)
            return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
            if ($util.Long)
                (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
            else if (typeof d.Seconds === "string")
                m.Seconds = parseInt(d.Seconds, 10);
            else if (typeof d.Seconds === "number")
                m.Seconds = d.Seconds;
            else if (typeof d.Seconds === "object")
                m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
    };

    /**
     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UnixTime
     * @static
     * @param {UnixTime} m UnixTime
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UnixTime.toObject = function toObject(m, o) {
        if (!o)
            o = {};
        var d = {};
        if (o.defaults) {
            if ($util.Long) {
                var n = new $util.Long(0, 0, false);
                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else
                d.Seconds = o.longs === String ? "0" : 0;
            d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
            if (typeof m.Seconds === "number")
                d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
            else
                d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
            d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
    };

    /**
     * Converts this UnixTime to JSON.
     * @function toJSON
     * @memberof UnixTime
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UnixTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util.toJSONOptions);
    };

    return UnixTime;
})();

const Metadata = $root.Metadata = (() => {

    /**
     * Properties of a Metadata.
     * @exports IMetadata
     * @interface IMetadata
     * @property {string|null} [MimeType] Metadata MimeType
     */

    /**
     * Constructs a new Metadata.
     * @exports Metadata
     * @classdesc Represents a Metadata.
     * @implements IMetadata
     * @constructor
     * @param {IMetadata=} [p] Properties to set
     */
    function Metadata(p) {
        if (p)
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                    this[ks[i]] = p[ks[i]];
    }

    /**
     * Metadata MimeType.
     * @member {string} MimeType
     * @memberof Metadata
     * @instance
     */
    Metadata.prototype.MimeType = "";

    /**
     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.
     * @function encode
     * @memberof Metadata
     * @static
     * @param {IMetadata} m Metadata message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Metadata.encode = function encode(m, w) {
        if (!w)
            w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
            w.uint32(10).string(m.MimeType);
        return w;
    };

    /**
     * Decodes a Metadata message from the specified reader or buffer.
     * @function decode
     * @memberof Metadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Metadata} Metadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Metadata.decode = function decode(r, l) {
        if (!(r instanceof $Reader))
            r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();
        while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
            case 1:
                m.MimeType = r.string();
                break;
            default:
                r.skipType(t & 7);
                break;
            }
        }
        return m;
    };

    /**
     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Metadata
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Metadata} Metadata
     */
    Metadata.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata)
            return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
            m.MimeType = String(d.MimeType);
        }
        return m;
    };

    /**
     * Creates a plain object from a Metadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Metadata
     * @static
     * @param {Metadata} m Metadata
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Metadata.toObject = function toObject(m, o) {
        if (!o)
            o = {};
        var d = {};
        if (o.defaults) {
            d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
            d.MimeType = m.MimeType;
        }
        return d;
    };

    /**
     * Converts this Metadata to JSON.
     * @function toJSON
     * @memberof Metadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Metadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util.toJSONOptions);
    };

    return Metadata;
})();




/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9pbnRlcmZhY2UtcGVlci1pZC9kaXN0L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9sb2dnZXIvZGlzdC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvbG9nZ2VyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvbG9nZ2VyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UzMi5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9sb2dnZXIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTU4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL2xvZ2dlci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9iYXNlcy9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvbG9nZ2VyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9sb2dnZXIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvbG9nZ2VyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvdmVuZG9yL2Jhc2UteC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL2Rpc3Qvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UxMC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UxNi5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTI1NmVtb2ppLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTMyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTM2LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTU4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTY0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9iYXNlcy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2ljcy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2J5dGVzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvY2lkLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvY29kZWNzL2pzb24uanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9jb2RlY3MvcmF3LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvaGFzaGVzL2RpZ2VzdC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2hhc2hlcy9oYXNoZXIuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9oYXNoZXMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9oYXNoZXMvc2hhMi5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItaWQvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvbGluay9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy92YXJpbnQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3ZlbmRvci9iYXNlLXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3ZlbmRvci92YXJpbnQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZGlzdC9zcmMvZXF1YWxzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci10by11cmkvZGlzdC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Rpc3Qvc3JjL2NvZGVjLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9kaXN0L3NyYy9jb252ZXJ0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9kaXN0L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvZGlzdC9zcmMvaXAuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Rpc3Qvc3JjL3Byb3RvY29scy10YWJsZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTEwLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9iYXNlcy9iYXNlMTYuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9iYXNlcy9iYXNlMjU2ZW1vamkuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2UzMi5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTM2LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9iYXNlcy9iYXNlNTguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYmFzZXMvYmFzZTguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9iYXNlcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2Jhc2ljcy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2NpZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvY29kZWNzL2pzb24uanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2NvZGVjcy9yYXcuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2hhc2hlcy9kaWdlc3QuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2hhc2hlcy9oYXNoZXIuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2hhc2hlcy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9zcmMvaGFzaGVzL3NoYTIuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvc3JjL2xpbmsvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL3NyYy92YXJpbnQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvdmVuZG9yL2Jhc2UteC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy92ZW5kb3IvdmFyaW50LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZGlzdC9zcmMvYWxsb2MuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9kaXN0L3NyYy9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9kaXN0L3NyYy9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9kaXN0L3NyYy9mcm9tLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Rpc3Qvc3JjL3RvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Rpc3Qvc3JjL3V0aWwvYXMtdWludDhhcnJheS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Rpc3Qvc3JjL3V0aWwvYmFzZXMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy92YXJpbnQvZGVjb2RlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3ZhcmludC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3ZhcmludC9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2RhZy1qb3NlL2xpYi9lbmNyeXB0aW9uLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9kYWctam9zZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2RhZy1qb3NlL2xpYi9zaWduaW5nLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9kYWctam9zZS9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvbm9kZV9tb2R1bGVzL25hbm9pZC91cmwtYWxwaGFiZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9zcmMvYWdlbnQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9zcmMvZmlsZXMvbm9ybWFsaXNlLWNhbmRpZGF0ZS1tdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL3NyYy9maWxlcy9ub3JtYWxpc2UtY2FuZGlkYXRlLXNpbmdsZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL3NyYy9maWxlcy9ub3JtYWxpc2UtY29udGVudC5icm93c2VyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL2ZpbGVzL25vcm1hbGlzZS1jb250ZW50LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL2ZpbGVzL25vcm1hbGlzZS1pbnB1dC1tdWx0aXBsZS5icm93c2VyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL2ZpbGVzL25vcm1hbGlzZS1pbnB1dC1tdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL3NyYy9maWxlcy9ub3JtYWxpc2UtaW5wdXQtc2luZ2xlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL2ZpbGVzL3V0aWxzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL21vZGUtdG8tc3RyaW5nLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL211bHRpYmFzZXMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9zcmMvbXVsdGljb2RlY3MuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9zcmMvbXVsdGloYXNoZXMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9zcmMvbXVsdGlwYXJ0LXJlcXVlc3QuYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL3NyYy9tdWx0aXBhcnQtcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL3NyYy9tdWx0aXBhcnQtcmVxdWVzdC5ub2RlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL3BpbnMvbm9ybWFsaXNlLWlucHV0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvc3JjL3RvLXVybC1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2FkZC1hbGwuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2FkZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYml0c3dhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYml0c3dhcC9zdGF0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9iaXRzd2FwL3Vud2FudC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYml0c3dhcC93YW50bGlzdC1mb3ItcGVlci5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYml0c3dhcC93YW50bGlzdC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYmxvY2svZ2V0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9ibG9jay9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYmxvY2svcHV0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9ibG9jay9ybS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYmxvY2svc3RhdC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYm9vdHN0cmFwL2FkZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvYm9vdHN0cmFwL2NsZWFyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9ib290c3RyYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2Jvb3RzdHJhcC9saXN0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9ib290c3RyYXAvcmVzZXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2Jvb3RzdHJhcC9ybS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvY2F0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvY29uZmlnL2dldC1hbGwuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2NvbmZpZy9nZXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2NvbmZpZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvY29uZmlnL3Byb2ZpbGVzL2FwcGx5LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9jb25maWcvcHJvZmlsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2NvbmZpZy9wcm9maWxlcy9saXN0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9jb25maWcvcmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvY29uZmlnL3NldC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGFnL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGFnL2dldC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGFnL2ltcG9ydC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGFnL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9kYWcvcHV0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9kYWcvcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGh0L2ZpbmQtcGVlci5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGh0L2ZpbmQtcHJvdnMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2RodC9nZXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2RodC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGh0L21hcC1ldmVudC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGh0L3Byb3ZpZGUuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2RodC9wdXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2RodC9xdWVyeS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZGh0L3Jlc3BvbnNlLXR5cGVzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9kaWFnL2NtZHMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2RpYWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2RpYWcvbmV0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9kaWFnL3N5cy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZG5zLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9maWxlcy9jaG1vZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZmlsZXMvY3AuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2ZpbGVzL2ZsdXNoLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9maWxlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZmlsZXMvbHMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2ZpbGVzL21rZGlyLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9maWxlcy9tdi5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZmlsZXMvcmVhZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZmlsZXMvcm0uanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2ZpbGVzL3N0YXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2ZpbGVzL3RvdWNoLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9maWxlcy93cml0ZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZ2V0LWVuZHBvaW50LWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvZ2V0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9pZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2lzLW9ubGluZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMva2V5L2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMva2V5L2dlbi5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMva2V5L2ltcG9ydC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMva2V5L2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9rZXkvaW5mby5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMva2V5L2xpc3QuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2tleS9yZW5hbWUuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2tleS9ybS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbGliL2Fib3J0LXNpZ25hbC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbGliL2NvbmZpZ3VyZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2xpYi9odHRwLXJwYy13aXJlLWZvcm1hdC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbGliL21vZGUtdG8tc3RyaW5nLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9saWIvb2JqZWN0LXRvLWNhbWVsLXdpdGgtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2xpYi9vYmplY3QtdG8tY2FtZWwuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2xpYi9wYXJzZS1tdGltZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbGliL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbG9nL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9sb2cvbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2xvZy9scy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbG9nL3RhaWwuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL2xzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9tb3VudC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbmFtZS9wdWJsaXNoLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9uYW1lL3B1YnN1Yi9jYW5jZWwuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL25hbWUvcHVic3ViL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9uYW1lL3B1YnN1Yi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbmFtZS9wdWJzdWIvc3Vicy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvbmFtZS9yZXNvbHZlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9vYmplY3QvZGF0YS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvb2JqZWN0L2dldC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9vYmplY3QvbGlua3MuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL29iamVjdC9uZXcuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL29iamVjdC9wYXRjaC9hZGQtbGluay5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvb2JqZWN0L3BhdGNoL2FwcGVuZC1kYXRhLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9vYmplY3QvcGF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL29iamVjdC9wYXRjaC9ybS1saW5rLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9vYmplY3QvcGF0Y2gvc2V0LWRhdGEuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL29iamVjdC9wdXQuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL29iamVjdC9zdGF0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vYWRkLWFsbC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcGluL2FkZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcGluL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vbHMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3Bpbi9yZW1vdGUvYWRkLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcmVtb3RlL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcmVtb3RlL2xzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcmVtb3RlL3JtLWFsbC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcGluL3JlbW90ZS9ybS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlL2FkZC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlL2luZGV4LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcmVtb3RlL3NlcnZpY2UvbHMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3Bpbi9yZW1vdGUvc2VydmljZS9ybS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlL3V0aWxzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcmVtb3RlL3V0aWxzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcm0tYWxsLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9waW4vcm0uanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3BpbmcuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3B1YnN1Yi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcHVic3ViL2xzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9wdWJzdWIvcGVlcnMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3B1YnN1Yi9wdWJsaXNoLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9wdWJzdWIvc3Vic2NyaWJlLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9wdWJzdWIvc3Vic2NyaXB0aW9uLXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3B1YnN1Yi91bnN1YnNjcmliZS5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcmVmcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcmVmcy9sb2NhbC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcmVwby9nYy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcmVwby9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvcmVwby9zdGF0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9yZXBvL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3N0YXJ0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9zdGF0cy9idy5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvc3RhdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3N0b3AuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3N3YXJtL2FkZHJzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9zd2FybS9jb25uZWN0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9zd2FybS9kaXNjb25uZWN0LmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy9zd2FybS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXNlYXJjaHByb2ovLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9zcmMvc3dhcm0vbG9jYWwtYWRkcnMuanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvc3JjL3N3YXJtL3BlZXJzLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L3NyYy92ZXJzaW9uLmpzIiwid2VicGFjazovL3Jlc2VhcmNocHJvai8uL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVzZWFyY2hwcm9qLy4vbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL3NyYy91bml4ZnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDUDtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKMEI7QUFDNEI7QUFDSDtBQUNBO0FBQ25EO0FBQ0EsK0NBQWtCO0FBQ2xCLHFDQUFxQywyRUFBb0I7QUFDekQ7QUFDQTtBQUNBLCtDQUFrQjtBQUNsQixxQ0FBcUMsd0VBQWlCO0FBQ3REO0FBQ0E7QUFDQSwrQ0FBa0I7QUFDbEIscUNBQXFDLHdFQUFpQjtBQUN0RDtBQUNBO0FBQ0EsK0NBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLCtDQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBa0I7QUFDbEI7QUFDQTtBQUNPO0FBQ1AseUJBQXlCLGtDQUFLO0FBQzlCLGVBQWUsa0NBQUssSUFBSSxLQUFLO0FBQzdCLGVBQWUsa0NBQUssSUFBSSxLQUFLO0FBQzdCLEtBQUs7QUFDTDtBQUNPO0FBQ1AsSUFBSSwwQ0FBYTtBQUNqQjtBQUNPO0FBQ1AsSUFBSSx5Q0FBWTtBQUNoQjtBQUNPO0FBQ1AsV0FBVywwQ0FBYTtBQUN4QjtBQUNBLGlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0MwQztBQUNOO0FBQ3BDO0FBQ0E7QUFDcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVztBQUN4QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVksRUFBRSx1QkFBdUI7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCLElBQUksVUFBVSw4Q0FBOEMsWUFBWTtBQUN0SjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGFBQWEsNkRBQTZEO0FBQzFFLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsMkNBQTJDO0FBQ3hEOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixhQUFhLDZEQUE2RDtBQUMxRSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNERBQTRELHNCQUFzQiw4QkFBOEIsMkJBQTJCO0FBQzNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsV0FBVyw4Q0FBOEM7QUFDekQsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ08sMkRBQTJELGNBQWM7QUFDaEYsd0JBQXdCLDBEQUEwRDtBQUNsRix5QkFBeUIsNERBQTREO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDTztBQUNQO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQixhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDRCQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyw2QkFBNkI7QUFDeEMsYUFBYTtBQUNiO0FBQ08sZUFBZSwrQkFBK0I7QUFDckQ7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTyxnQkFBZ0IseUJBQXlCO0FBQ2hELFNBQVMsaUJBQWlCLEdBQUcsMERBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLG9CQUFvQixpREFBTTtBQUMxQixHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ08sa0JBQWtCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFWbUM7O0FBRTVCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQixpREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSx1QkFBdUIsaURBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sdUJBQXVCLGlEQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxxQkFBcUIsaURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDBCQUEwQixpREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sZ0JBQWdCLGlEQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0RnQzs7QUFFMUIsa0JBQWtCLCtDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0scUJBQXFCLCtDQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWkQ7O0FBRW1DOztBQUU1QixlQUFlLGlEQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxrQkFBa0IsaURBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0scUJBQXFCLGlEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzlCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHVDQUF1QztBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQTs7QUFFZ0Y7Ozs7Ozs7Ozs7Ozs7QUNsRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QywrQ0FBK0M7QUFDL0M7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVksU0FBUyxrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0RBQWUsK0JBQStCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlIUjtBQUNLO0FBQ1U7QUFDRDtBQUNHO0FBQ1E7QUFDZDtBQUNuQjtBQUNvQjtBQUNuRDtBQUNBLFlBQVksc0RBQUs7QUFDakI7QUFDQTtBQUNBLHlDQUF5Qyx1RUFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQSxTQUFTLDZEQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUVBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQU87QUFDakI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFhLENBQUMsdUVBQWdCLEtBQUssSUFBSTtBQUNqRTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMEJBQTBCLDhEQUFhO0FBQ3ZDLCtCQUErQix1RUFBYTtBQUM1QztBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0EsK0JBQStCLGlFQUFXO0FBQzFDLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFXO0FBQ3RDLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQSxnQ0FBZ0MsdUVBQWE7QUFDN0M7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQSw0Q0FBNEMsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0NBQXNDLFlBQVksOERBQWEsQ0FBQyx1RUFBYSwwQkFBMEI7QUFDdkc7QUFDQTtBQUNBLHdDQUF3QyxZQUFZLDhEQUFhLENBQUMsdUVBQWEsMEJBQTBCO0FBQ3pHO0FBQ0EsOEJBQThCLGtCQUFrQixtRUFBYSxvQ0FBb0M7QUFDakc7QUFDQSxpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xMMEM7QUFDTjtBQUNwQztBQUNBO0FBQ3FDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQixhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFdBQVc7QUFDeEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLEVBQUUsdUJBQXVCO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQixhQUFhLDRCQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQixJQUFJLFVBQVUsOENBQThDLFlBQVk7QUFDdEo7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixhQUFhLDZEQUE2RDtBQUMxRSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixhQUFhLDJDQUEyQztBQUN4RDs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsYUFBYSw2REFBNkQ7QUFDMUUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDREQUE0RCxzQkFBc0IsOEJBQThCLDJCQUEyQjtBQUMzSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsOENBQThDO0FBQ3pELFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNPLDJEQUEyRCxjQUFjO0FBQ2hGLHdCQUF3QiwwREFBMEQ7QUFDbEYseUJBQXlCLDREQUE0RDtBQUNyRixDQUFDOztBQUVEO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ087QUFDUDtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLE9BQU87QUFDcEIsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsNkJBQTZCO0FBQ3hDLGFBQWE7QUFDYjtBQUNPLGVBQWUsK0JBQStCO0FBQ3JEOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ08sZ0JBQWdCLHlCQUF5QjtBQUNoRCxTQUFTLGlCQUFpQixHQUFHLDBEQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxvQkFBb0IsaURBQU07QUFDMUIsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNPLGtCQUFrQixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVZpQzs7QUFFMUIsZUFBZSwrQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNORDs7QUFFbUM7O0FBRTVCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQixpREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJEOztBQUVtQzs7QUFFNUIsY0FBYyxpREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVCtCOztBQUVoQztBQUNBLHdDQUF3QyxTQUFTLG1DQUFtQyxVQUFVLFdBQVcsYUFBYSxTQUFTO0FBQy9ILHdDQUF3QyxTQUFTLG1DQUFtQyxjQUFjLE9BQU8sNEJBQTRCLFdBQVcsYUFBYSxTQUFTOztBQUV0SztBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8scUJBQXFCLDhDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDa0M7O0FBRTVCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQixpREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSx1QkFBdUIsaURBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sdUJBQXVCLGlEQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxxQkFBcUIsaURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDBCQUEwQixpREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sZ0JBQWdCLGlEQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0RnQzs7QUFFMUIsZUFBZSwrQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQiwrQ0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaZ0M7O0FBRTFCLGtCQUFrQiwrQ0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHFCQUFxQiwrQ0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pEOztBQUVtQzs7QUFFNUIsZUFBZSxpREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxrQkFBa0IsaURBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHFCQUFxQixpREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJEOztBQUVtQzs7QUFFNUIsY0FBYyxpREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1REOztBQUVnQztBQUNrQjs7QUFFM0MsaUJBQWlCLDhDQUFJO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVE7QUFDM0IsbUJBQW1CLHFEQUFVO0FBQzdCLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNWRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFFbUQ7QUFDVjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDZjtBQUNROztBQUVWO0FBQ0U7O0FBRXVCOztBQUUvRCxlQUFlLElBQUksK0NBQVksS0FBSyw0Q0FBSyxLQUFLLDRDQUFLLEtBQUssNkNBQU0sS0FBSyw2Q0FBTSxLQUFLLDZDQUFNLEtBQUssNkNBQU0sS0FBSyw2Q0FBTSxLQUFLLDZDQUFNLEtBQUssbURBQVk7QUFDdEksZ0JBQWdCLElBQUksNkNBQUksS0FBSyxpREFBUTtBQUNyQyxnQkFBZ0IsSUFBSSxvREFBTTs7QUFFMEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEJwRTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHVDQUF1QztBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQTs7QUFFZ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEUzQztBQUNPO0FBQ0M7QUFDSDtBQUNQO0FBQ25DO0FBQ0E7QUFDMEM7O0FBRTFDO0FBQ21DOztBQUVuQztBQUNBLGNBQWMsK0NBQStDO0FBQzdELGNBQWMsT0FBTztBQUNyQixXQUFXLEVBQUU7QUFDYixXQUFXLDZCQUE2QjtBQUN4QyxhQUFhO0FBQ2I7QUFDTztBQUNQLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCLGNBQWMsK0RBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCLGFBQWEsNERBQWM7QUFDM0U7QUFDQTtBQUNBOztBQUVBLFdBQVcsOENBQThDO0FBQ3pEOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjs7QUFFTztBQUNQO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNDQUFzQztBQUNoRTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsc0NBQXNDO0FBQ2hFO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsMEJBQTBCLHFEQUFhO0FBQ3ZDLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEscUNBQXFDO0FBQ2xELGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFxRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFhO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsUUFBUTtBQUN4QixhQUFhLHVDQUF1QztBQUNwRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxTQUFTLHFEQUFhO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSx5QkFBeUI7QUFDdEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsYUFBYSx5Q0FBeUM7QUFDdEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGFBQWEsS0FBSztBQUNsQixhQUFhLHlCQUF5QjtBQUN0QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLDZDQUE2QztBQUMxRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLG1DQUFtQztBQUNoRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEsbUNBQW1DO0FBQ2hELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLEVBQUU7QUFDL0IsMkJBQTJCLEVBQUU7QUFDN0IsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsRUFBRTtBQUMzQjs7QUFFQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEOztBQUVBO0FBQ0EscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLDZCQUE2QjtBQUMxQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsWUFBWTtBQUMxQixXQUFXLHFEQUFxRDtBQUNoRSxXQUFXLDZCQUE2QjtBQUN4QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBUztBQUN2QztBQUNBLG1CQUFtQixPQUFPLEtBQUssOERBQWdCO0FBQy9DLDBCQUEwQiw4REFBZ0IsQ0FBQyxFQUFFLE9BQU87QUFDcEQ7QUFDQTtBQUNBLFNBQVMsOERBQWdCO0FBQ3pCLDhCQUE4Qix1REFBUztBQUN2Qyx5QkFBeUIsT0FBTyxJQUFJLDhEQUFnQjtBQUNwRDtBQUNBLFNBQVMsMkRBQWE7QUFDdEIsOEJBQThCLG9EQUFNO0FBQ3BDLHlCQUF5QixPQUFPLElBQUksMkRBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLG9CQUFvQjtBQUMvQixXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCLGlCQUFpQiw4REFBZ0I7QUFDakMsOENBQThDLFVBQVU7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLHNEQUFxQjtBQUMxQyxrQ0FBa0Msc0RBQXFCO0FBQ3ZEO0FBQ0EsRUFBRSxnREFBZTtBQUNqQixFQUFFLGdEQUFlO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVpQkE7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRU87QUFDQTs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYTtBQUNiO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QlA7O0FBRW9DOztBQUVwQztBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7O0FBRU87QUFDQTs7QUFFUDtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDTyx5QkFBeUIsaURBQU07O0FBRXRDO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ08seUJBQXlCLGlEQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Qm9CO0FBQ3BCOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsV0FBVztBQUN0QjtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsc0RBQXFCO0FBQzFDLG9DQUFvQyxzREFBcUI7O0FBRXpEO0FBQ0EsRUFBRSxnREFBZTtBQUNqQixFQUFFLGdEQUFlO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNPO0FBQ1AsZ0JBQWdCLGlEQUFNO0FBQ3RCLDZCQUE2Qiw4Q0FBYTtBQUMxQywrQkFBK0IsOENBQWE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNILDZCQUE2Qiw4Q0FBOEM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpREFBVTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRnFDOztBQUVyQztBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDTyxlQUFlLHFCQUFxQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ087QUFDUDtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsS0FBSztBQUNsQixhQUFhLHlDQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFdBQVc7QUFDeEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUFhO0FBQ3ZCO0FBQ0EsZ0NBQWdDLDhDQUFhO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVEb0M7QUFDQzs7QUFFckM7QUFDQTs7QUFFQSxXQUFXLGlDQUFpQztBQUM1QyxlQUFlLDZDQUFNOztBQUVyQjtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsOENBQWE7O0FBRWhDLGtCQUFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmekI7O0FBRTJCO0FBQ087QUFDRTs7QUFFN0IsZUFBZSxnREFBSTtBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLGlEQUFNLENBQUMsOENBQWlCO0FBQzdDLENBQUM7O0FBRU0sZUFBZSxnREFBSTtBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFNLENBQUMsOENBQWlCO0FBQzNDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEI2QjtBQUNPO0FBQ0Y7QUFDUztBQUNBO0FBQzVDO0FBQzhCOztBQUVlOzs7Ozs7Ozs7Ozs7O0FDUjdDOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBd0M7O0FBRXhDO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLGVBQWUsNkRBQWE7QUFDNUIsZ0JBQWdCLG1FQUFtQjtBQUNuQzs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUCxFQUFFLDZEQUFhO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLFNBQVMscUVBQXFCO0FBQzlCOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QywrQ0FBK0M7QUFDL0M7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVksU0FBUyxrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0RBQWUsK0JBQStCLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUM5SC9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrREFBZSxZQUFZLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRjVCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxHQUFHLEtBQUs7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxLQUFLLElBQUksRUFBRSxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxhQUFhLElBQUksR0FBRyxRQUFRO0FBQzVCO0FBQ0Esb0NBQW9DLElBQUksR0FBRyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJLFFBQVEsUUFBUTtBQUNuRCw4QkFBOEIsSUFBSSxPQUFPLFFBQVE7QUFDakQsMkJBQTJCLElBQUk7QUFDL0IsNkJBQTZCLElBQUk7QUFDakMsdUJBQXVCLElBQUk7QUFDM0IseUJBQXlCLElBQUk7QUFDN0Isb0NBQW9DLElBQUk7QUFDeEMsaUNBQWlDLElBQUk7QUFDckMsbUNBQW1DLElBQUk7QUFDdkM7QUFDTztBQUNQLGVBQWUsa0VBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RCtEO0FBQ1o7QUFDdkI7QUFDb0M7QUFDTztBQUN2RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQSxzQkFBc0IsZ0VBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyREFBYztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDREQUFlO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFCQUFxQiwwREFBZ0I7QUFDckM7QUFDQSxrQ0FBa0MsMENBQWE7QUFDL0M7QUFDQSxrQkFBa0IsMERBQWdCLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBYTtBQUNsQyxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBYTtBQUNsQyxrQkFBa0IsZ0RBQW1CO0FBQ3JDLGtCQUFrQixnRUFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDhEQUE4RCwrREFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLGtCQUFrQixnRUFBVztBQUM3QjtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTDhCO0FBQ3FCO0FBQ1o7QUFDWTtBQUNHO0FBQ1Y7QUFDUztBQUN6QjtBQUMyQztBQUNNO0FBQ2I7QUFDaEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUJBQXFCLGdFQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFrQixnQkFBZ0I7QUFDckQ7QUFDQTtBQUNPO0FBQ1AscUJBQXFCLGdFQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQW9CLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsK0JBQStCLHNEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsU0FBUyx3Q0FBTztBQUNoQjtBQUNBO0FBQ0EsV0FBVywyQ0FBVTtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCLDRDQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFvQjtBQUNwQyxpQ0FBaUMsMENBQWE7QUFDOUMsV0FBVywyREFBZ0I7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBYTtBQUM5QixvQkFBb0IsZ0RBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4REFBYSxDQUFDLHVFQUFnQixLQUFLLEtBQUs7QUFDckQ7QUFDQTtBQUNBLGFBQWEsdURBQVM7QUFDdEI7QUFDQTtBQUNBLGlDQUFpQywwQ0FBYTtBQUM5QyxXQUFXLDJEQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQWE7QUFDOUMsV0FBVywyREFBZ0I7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBYTtBQUM5QiwyQkFBMkIsZ0RBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrREFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBYTtBQUM5Qiw4QkFBOEIsZ0RBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBLGdCQUFnQixvRUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQSxnQkFBZ0Isb0VBQWEsS0FBSyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtEQUFrQjtBQUNuQztBQUNBLGNBQWMsS0FBSyxHQUFHLEtBQUs7QUFDM0I7QUFDQSxtQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xOQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBQ3NCO0FBQzlCO0FBQ1c7QUFDZTtBQUN2QjtBQUN3QztBQUNQO0FBQ2hFO0FBQ0E7QUFDQSxJQUFJLGdFQUFXO0FBQ2YsSUFBSSxnRUFBVztBQUNmLElBQUksZ0VBQVc7QUFDZixJQUFJLGdFQUFXO0FBQ2Y7QUFDQTtBQUNBLElBQUksZ0VBQVc7QUFDZixJQUFJLGdFQUFXO0FBQ2Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0EseUJBQXlCLGlEQUFnQjtBQUN6QztBQUNBLHFDQUFxQztBQUNyQyx5QkFBeUIsZ0RBQWUsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvREFBbUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnRUFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDhCQUE4QixFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsS0FBSztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFLGdFQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBYTtBQUN0QyxzQkFBc0IsZ0RBQW1CO0FBQ3pDLHNCQUFzQixnRUFBVztBQUNqQyx5QkFBeUIsa0RBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9EQUFtQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDJEQUEwQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCLGdDQUFnQyxnQkFBZ0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0EsNENBQTRDLG9EQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnRUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQWtCLENBQUMsdUVBQWdCLEtBQUssVUFBVTtBQUM3RTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFrQixDQUFDLHVEQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0VBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQU8sd0NBQXdDLHFCQUFxQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixrQkFBa0IsMkNBQTJDLFNBQVM7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBa0I7QUFDOUIsWUFBWSxvREFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNPO0FBQ1A7QUFDQTtBQUNvQztBQUNwQyxpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN1V1QztBQUNnQztBQUMxQztBQUN0QixhQUFhLHlDQUFNO0FBQ25CLGFBQWEseUNBQU07QUFDMUI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtEQUFrQjtBQUNoRDtBQUNBO0FBQ0Esc0NBQXNDLCtEQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUEyQztBQUNsRTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRkE7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQSwyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFMEM7QUFDTjtBQUNwQztBQUNBO0FBQ3FDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQixhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFdBQVc7QUFDeEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLEVBQUUsdUJBQXVCO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQixhQUFhLDRCQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQixJQUFJLFVBQVUsOENBQThDLFlBQVk7QUFDdEo7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixhQUFhLDZEQUE2RDtBQUMxRSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixhQUFhLDJDQUEyQztBQUN4RDs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsYUFBYSw2REFBNkQ7QUFDMUUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDREQUE0RCxzQkFBc0IsOEJBQThCLDJCQUEyQjtBQUMzSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsOENBQThDO0FBQ3pELFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNPLDJEQUEyRCxjQUFjO0FBQ2hGLHdCQUF3QiwwREFBMEQ7QUFDbEYseUJBQXlCLDREQUE0RDtBQUNyRixDQUFDOztBQUVEO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ087QUFDUDtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLE9BQU87QUFDcEIsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsNkJBQTZCO0FBQ3hDLGFBQWE7QUFDYjtBQUNPLGVBQWUsK0JBQStCO0FBQ3JEOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ08sZ0JBQWdCLHlCQUF5QjtBQUNoRCxTQUFTLGlCQUFpQixHQUFHLDBEQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxvQkFBb0IsaURBQU07QUFDMUIsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNPLGtCQUFrQixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVZpQzs7QUFFMUIsZUFBZSwrQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNORDs7QUFFbUM7O0FBRTVCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQixpREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJEOztBQUVtQzs7QUFFNUIsY0FBYyxpREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVCtCOztBQUVoQztBQUNBLHdDQUF3QyxTQUFTLG1DQUFtQyxVQUFVLFdBQVcsYUFBYSxTQUFTO0FBQy9ILHdDQUF3QyxTQUFTLG1DQUFtQyxjQUFjLE9BQU8sNEJBQTRCLFdBQVcsYUFBYSxTQUFTOztBQUV0SztBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8scUJBQXFCLDhDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDa0M7O0FBRTVCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQixpREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSx1QkFBdUIsaURBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sdUJBQXVCLGlEQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxxQkFBcUIsaURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDBCQUEwQixpREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sZ0JBQWdCLGlEQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0RnQzs7QUFFMUIsZUFBZSwrQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLG9CQUFvQiwrQ0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaZ0M7O0FBRTFCLGtCQUFrQiwrQ0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHFCQUFxQiwrQ0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pEOztBQUVtQzs7QUFFNUIsZUFBZSxpREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxrQkFBa0IsaURBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHFCQUFxQixpREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJEOztBQUVtQzs7QUFFNUIsY0FBYyxpREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1REOztBQUVnQztBQUNrQjs7QUFFM0MsaUJBQWlCLDhDQUFJO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVE7QUFDM0IsbUJBQW1CLHFEQUFVO0FBQzdCLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNWRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFFbUQ7QUFDVjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDZjtBQUNROztBQUVWO0FBQ0U7O0FBRXVCOztBQUUvRCxlQUFlLElBQUksK0NBQVksS0FBSyw0Q0FBSyxLQUFLLDRDQUFLLEtBQUssNkNBQU0sS0FBSyw2Q0FBTSxLQUFLLDZDQUFNLEtBQUssNkNBQU0sS0FBSyw2Q0FBTSxLQUFLLDZDQUFNLEtBQUssbURBQVk7QUFDdEksZ0JBQWdCLElBQUksNkNBQUksS0FBSyxpREFBUTtBQUNyQyxnQkFBZ0IsSUFBSSxvREFBTTs7QUFFMEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEJwRTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHVDQUF1QztBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQTs7QUFFZ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEUzQztBQUNPO0FBQ0M7QUFDSDtBQUNQO0FBQ25DO0FBQ0E7QUFDMEM7O0FBRTFDO0FBQ21DOztBQUVuQztBQUNBLGNBQWMsK0NBQStDO0FBQzdELGNBQWMsT0FBTztBQUNyQixXQUFXLEVBQUU7QUFDYixXQUFXLDZCQUE2QjtBQUN4QyxhQUFhO0FBQ2I7QUFDTztBQUNQLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCLGNBQWMsK0RBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCLGFBQWEsNERBQWM7QUFDM0U7QUFDQTtBQUNBOztBQUVBLFdBQVcsOENBQThDO0FBQ3pEOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjs7QUFFTztBQUNQO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNDQUFzQztBQUNoRTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsc0NBQXNDO0FBQ2hFO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsMEJBQTBCLHFEQUFhO0FBQ3ZDLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEscUNBQXFDO0FBQ2xELGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFxRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFhO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsUUFBUTtBQUN4QixhQUFhLHVDQUF1QztBQUNwRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxTQUFTLHFEQUFhO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSx5QkFBeUI7QUFDdEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsYUFBYSx5Q0FBeUM7QUFDdEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGFBQWEsS0FBSztBQUNsQixhQUFhLHlCQUF5QjtBQUN0QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLDZDQUE2QztBQUMxRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLG1DQUFtQztBQUNoRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEsbUNBQW1DO0FBQ2hELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLEVBQUU7QUFDL0IsMkJBQTJCLEVBQUU7QUFDN0IsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsRUFBRTtBQUMzQjs7QUFFQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEOztBQUVBO0FBQ0EscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLDZCQUE2QjtBQUMxQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsWUFBWTtBQUMxQixXQUFXLHFEQUFxRDtBQUNoRSxXQUFXLDZCQUE2QjtBQUN4QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBUztBQUN2QztBQUNBLG1CQUFtQixPQUFPLEtBQUssOERBQWdCO0FBQy9DLDBCQUEwQiw4REFBZ0IsQ0FBQyxFQUFFLE9BQU87QUFDcEQ7QUFDQTtBQUNBLFNBQVMsOERBQWdCO0FBQ3pCLDhCQUE4Qix1REFBUztBQUN2Qyx5QkFBeUIsT0FBTyxJQUFJLDhEQUFnQjtBQUNwRDtBQUNBLFNBQVMsMkRBQWE7QUFDdEIsOEJBQThCLG9EQUFNO0FBQ3BDLHlCQUF5QixPQUFPLElBQUksMkRBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLG9CQUFvQjtBQUMvQixXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCLGlCQUFpQiw4REFBZ0I7QUFDakMsOENBQThDLFVBQVU7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLHNEQUFxQjtBQUMxQyxrQ0FBa0Msc0RBQXFCO0FBQ3ZEO0FBQ0EsRUFBRSxnREFBZTtBQUNqQixFQUFFLGdEQUFlO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVpQkE7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRU87QUFDQTs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYTtBQUNiO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QlA7O0FBRW9DOztBQUVwQztBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7O0FBRU87QUFDQTs7QUFFUDtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDTyx5QkFBeUIsaURBQU07O0FBRXRDO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ08seUJBQXlCLGlEQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Qm9CO0FBQ3BCOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsV0FBVztBQUN0QjtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsc0RBQXFCO0FBQzFDLG9DQUFvQyxzREFBcUI7O0FBRXpEO0FBQ0EsRUFBRSxnREFBZTtBQUNqQixFQUFFLGdEQUFlO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNPO0FBQ1AsZ0JBQWdCLGlEQUFNO0FBQ3RCLDZCQUE2Qiw4Q0FBYTtBQUMxQywrQkFBK0IsOENBQWE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNILDZCQUE2Qiw4Q0FBOEM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpREFBVTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRnFDOztBQUVyQztBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDTyxlQUFlLHFCQUFxQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ087QUFDUDtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsS0FBSztBQUNsQixhQUFhLHlDQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFdBQVc7QUFDeEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUFhO0FBQ3ZCO0FBQ0EsZ0NBQWdDLDhDQUFhO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVEb0M7QUFDQzs7QUFFckM7QUFDQTs7QUFFQSxXQUFXLGlDQUFpQztBQUM1QyxlQUFlLDZDQUFNOztBQUVyQjtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsOENBQWE7O0FBRWhDLGtCQUFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmekI7O0FBRTJCO0FBQ087QUFDRTs7QUFFN0IsZUFBZSxnREFBSTtBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLGlEQUFNLENBQUMsOENBQWlCO0FBQzdDLENBQUM7O0FBRU0sZUFBZSxnREFBSTtBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFNLENBQUMsOENBQWlCO0FBQzNDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEI2QjtBQUNPO0FBQ0Y7QUFDUztBQUNBO0FBQzVDO0FBQzhCOztBQUVlOzs7Ozs7Ozs7Ozs7O0FDUjdDOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBd0M7O0FBRXhDO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLGVBQWUsNkRBQWE7QUFDNUIsZ0JBQWdCLG1FQUFtQjtBQUNuQzs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUCxFQUFFLDZEQUFhO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLFNBQVMscUVBQXFCO0FBQzlCOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QywrQ0FBK0M7QUFDL0M7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVksU0FBUyxrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0RBQWUsK0JBQStCLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUM5SC9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrREFBZSxZQUFZLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFGMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxvRUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsb0VBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJ5QztBQUNjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ0Esa0M7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJvQztBQUNtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLG1EQUFLO0FBQ3RCO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBLGVBQWUsb0VBQVk7QUFDM0I7QUFDQTtBQUNBLGtDQUFrQyxZQUFZLEVBQUUsT0FBTyxHQUFHO0FBQzFEO0FBQ0EsdUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQm9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsbURBQUs7QUFDdEI7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7Ozs7QUNWNEM7QUFDRjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0Isc0RBQVc7QUFDM0IsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNEQUFLO0FBQ1o7QUFDQSwrREFBZSxLQUFLLEVBQUM7QUFDckIsaUM7Ozs7Ozs7Ozs7QUMvQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQSxZQUFZLG1CQUFPLENBQUMseUZBQWE7QUFDakMsWUFBWSxtQkFBTyxDQUFDLHlGQUFhO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCd0Q7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdEQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQix3REFBYTtBQUNqQyxtQkFBbUIsd0RBQWE7QUFDaEMsWUFBWSx3REFBYTtBQUN6QixhQUFhLHdEQUFhO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixzREFBVztBQUMvQixtQkFBbUIsc0RBQVc7QUFDOUIsWUFBWSxzREFBVztBQUN2QixhQUFhLHNEQUFXO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRHdDO0FBQ007QUFDUDtBQUNoQztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFpQjtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLHFEQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtDQUFjO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFXO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUFjO0FBQzdCO0FBQ0E7QUFDQSxlQUFlLGtEQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RndEO0FBQ2pCO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdDQUF3QztBQUM5RCxjQUFjLHdEQUFVLENBQUMsd0RBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQWE7QUFDekM7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLHdEQUFhO0FBQ2pDO0FBQ0EsUUFBUSx3REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFXO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQVU7QUFDN0I7QUFDQTtBQUNBLG1DOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25Ec0Q7QUFDL0M7QUFDUCxXQUFXLHVFQUFnQjtBQUMzQjtBQUNPO0FBQ1AsV0FBVyx1RUFBZ0IsS0FBSyxFQUFFO0FBQ2xDO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1B1QztBQUNjO0FBQy9CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFjO0FBQ2xCO0FBQ0EsR0FBRztBQUNILElBQUksc0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pELFVBQVUsK0RBQVc7QUFDckI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUNPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7OztBQ0R1QjtBQUNFOztBQUV6QjtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsK0RBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHdDQUFXLEdBQUcsdUNBQVU7QUFDcEUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1o2QjtBQUM4QjtBQUN4QjtBQUNaO0FBTUw7QUFJQzs7QUFFcEI7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRSxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLCtDQUErQztBQUM1RCxhQUFhLDBEQUEwRDtBQUN2RTs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsMERBQTBEO0FBQ3JFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0RBQU8sV0FBVyxpREFBTTtBQUN0RixVQUFVLHFDQUFPO0FBQ2pCOztBQUVBO0FBQ0EsTUFBTSwyREFBZ0I7QUFDdEIsWUFBWSx5REFBaUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix3Q0FBVTtBQUMvQixXQUFXLGNBQWM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQUcsdUJBQXVCLGdCQUFnQiw0QkFBNEIsaUJBQWlCO0FBQ3JHO0FBQ0E7O0FBRUEsUUFBUSxrREFBTztBQUNmO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBWSxvRUFBb0UsMkRBQWdCLFdBQVcsaURBQU07QUFDekgsY0FBYyxtQ0FBRyx1QkFBdUIsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sdURBQVk7QUFDbEIsVUFBVSxxQ0FBTztBQUNqQjs7QUFFQSxRQUFRLHFDQUFPO0FBQ2Y7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLDBEQUEwRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2Qjs7QUFFdEMsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBLFVBQVUsc0RBQVM7QUFDbkIsV0FBVyx1REFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxrQkFBa0I7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RIOEI7QUFDOEI7QUFDeEI7QUFNakI7QUFJQzs7QUFFcEI7QUFDQSxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLCtDQUErQztBQUM1RCxhQUFhLG9EQUFvRDtBQUNqRSxhQUFhLDBEQUEwRDtBQUN2RTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsMERBQTBEO0FBQ3JFO0FBQ0E7QUFDTztBQUNQO0FBQ0EsVUFBVSxxQ0FBTyxnQ0FBZ0MsTUFBTTtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGtEQUFPLFdBQVcsaURBQU07QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwyREFBZ0I7QUFDdEIsWUFBWSx5REFBaUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdDQUFVOztBQUUvQixlQUFlLElBQUk7QUFDbkIsV0FBVyxjQUFjOztBQUV6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFPO0FBQ2pCOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSx1REFBWTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxxQ0FBTztBQUNmOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVywwREFBMEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7O0FBRXRDLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVLHNEQUFTO0FBQ25CLFdBQVcsdURBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBLEdBQUcsa0JBQWtCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RzhCO0FBQ007QUFDd0I7QUFDcEM7QUFLTDs7QUFFbkI7QUFDQSxXQUFXLDhDQUE4QztBQUN6RDtBQUNPO0FBQ1A7QUFDQSxNQUFNLGtEQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0saURBQU07QUFDWjtBQUNBOztBQUVBO0FBQ0EsTUFBTSwyREFBZ0I7QUFDdEIsWUFBWSx5REFBaUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixxQkFBcUIsd0NBQVU7O0FBRS9CLGVBQWUsSUFBSTtBQUNuQixXQUFXLGNBQWM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsbUNBQUc7QUFDaEQ7O0FBRUE7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBLFFBQVEscUNBQU8sZ0NBQWdDLE1BQU07QUFDckQ7O0FBRUE7QUFDQSxXQUFXLDJDQUEyQztBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFFOEI7QUFDOEM7QUFDaEI7QUFDM0I7QUFDRztBQUNaO0FBQ0E7QUFLTDs7QUFFbkI7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQ7QUFDTztBQUNQO0FBQ0EsTUFBTSxrREFBTztBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpREFBTTtBQUNaLFdBQVcsdUNBQVE7QUFDbkI7O0FBRUE7QUFDQSxNQUFNLDJEQUFnQjtBQUN0QixZQUFZLHlEQUFpQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CLHFCQUFxQix3Q0FBVTs7QUFFL0IsZUFBZSxJQUFJO0FBQ25CLFdBQVcsY0FBYzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxtQ0FBRztBQUN0RDs7QUFFQTtBQUNBLFFBQVEsa0RBQU87QUFDZixhQUFhLG1DQUFHO0FBQ2hCO0FBQ0E7O0FBRUEsUUFBUSxxQ0FBTyxnQ0FBZ0MsTUFBTTtBQUNyRDs7QUFFQTtBQUNBLFdBQVcsdUZBQXVGO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxtRUFBb0I7QUFDN0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlGaUU7QUFDYTs7QUFFOUU7QUFDQSxhQUFhLDBEQUEwRDtBQUN2RSxhQUFhLDJEQUEyRDtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0EsU0FBUyw0RkFBMEIsUUFBUSwyRUFBZ0I7QUFDM0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCeUQ7QUFDcUI7O0FBRTlFO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDTztBQUNQLFNBQVMsNEZBQTBCLFFBQVEsbUVBQWdCO0FBQzNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQnlEO0FBQ2lCOztBQUUxRTtBQUNBLGFBQWEsb0RBQW9EO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUF3RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ087QUFDUCxTQUFTLHdGQUF3QixRQUFRLG1FQUFnQjtBQUN6RDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBLFdBQVcsSUFBSTtBQUNmLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ087QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQSxhQUFhLDJEQUEyRDtBQUN4RSxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLGlEQUFpRDtBQUM5RDs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJFQUEyRSxLQUFLOztBQUV6RTtBQUNQO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsV0FBVztBQUN4QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQzs7QUFFQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0EsYUFBYSw2REFBNkQ7QUFDMUUsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSxpREFBaUQ7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtRkFBbUYsV0FBVzs7QUFFdkY7QUFDUDtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFlBQVk7QUFDekIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDOztBQUVBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0EsYUFBYSx3REFBd0Q7QUFDckUsYUFBYSwrQkFBK0I7QUFDNUMsYUFBYSxpREFBaUQ7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxRkFBcUYsV0FBVzs7QUFFekY7QUFDUDtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQ7O0FBRUE7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDNEU7QUFDMUI7O0FBRWxEO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkU7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLCtCQUErQjtBQUMxQztBQUNPLHNFQUFzRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkJBQTZCLElBQUksMEZBQWM7QUFDbkU7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0VBQVksT0FBTztBQUN6Qzs7QUFFQTtBQUNBLGFBQWEsY0FBYzs7QUFFM0IsdUJBQXVCLEtBQUs7O0FBRTVCO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixVQUFVLEdBQUcsYUFBYTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0EsS0FBSztBQUNMLHdFQUF3RSxrQ0FBa0M7QUFDMUcsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RTBEO0FBQzRCO0FBQ007QUFDN0Q7O0FBRS9CO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkU7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLE9BQU87QUFDbEI7QUFDTyxzRUFBc0UsNkNBQTZDLDhDQUFNLEdBQUc7QUFDbkksWUFBWSx3RUFBb0I7O0FBRWhDO0FBQ0E7QUFDQSxNQUFNLHFFQUFrQjtBQUN4QjtBQUNBLFVBQVUsMkVBQXVCO0FBQ2pDOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJvRTtBQUNyQztBQUNtQjtBQUNiO0FBQ3JDO0FBQ21DO0FBQ0k7QUFDSDs7QUFFcEMsY0FBYywrQ0FBYyxFQUFFLHdCQUF3QjtBQUN0RCxZQUFZLHNEQUFNOztBQUVsQjtBQUNBLGFBQWEsMERBQTBEO0FBQ3ZFOztBQUVBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxPQUFPO0FBQ2xCO0FBQ08sc0VBQXNFLDZDQUE2Qyw4Q0FBTSxHQUFHO0FBQ25JO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsTUFBTTtBQUNqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGdFQUFZLE9BQU87QUFDN0M7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYzs7QUFFL0IsMkJBQTJCLEtBQUs7O0FBRWhDO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixVQUFVLEdBQUcsYUFBYTtBQUNuRDs7QUFFQSxtQkFBbUIsU0FBUztBQUM1Qiw4Q0FBOEMsU0FBUyxVQUFVLEVBQUUsYUFBYSwrQkFBK0I7QUFDL0csK0JBQStCLGlFQUFpRTtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssbUJBQW1CLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQVUsQ0FBQyxrRkFBYzs7QUFFNUMsYUFBYSxJQUFJO0FBQ2pCLFNBQVMsY0FBYzs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVksU0FBUztBQUNoRSxLQUFLO0FBQ0w7QUFDQSxVQUFVLHlDQUFRO0FBQ2xCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHOEI7QUFDUTs7QUFFdEM7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxrREFBa0Q7QUFDaEUsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsUUFBUTtBQUN0QixjQUFjLElBQUk7QUFDbEI7QUFDQSxhQUFhLHVEQUF1RDtBQUNwRSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsSUFBSTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRCxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFnRDtBQUNsRTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsVUFBVSxxQ0FBTyxnQ0FBZ0MsTUFBTTtBQUN2RDs7QUFFQTtBQUNBLGNBQWMsdURBQVM7O0FBRXZCO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx1REFBUztBQUNqQixtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBTztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFPO0FBQ2pCOztBQUVBLFFBQVEscUNBQU87QUFDZjs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7O0FBRTFDO0FBQ0EsVUFBVSxxQ0FBTztBQUNqQjs7QUFFQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hKbUQ7QUFDWTs7QUFFL0Q7QUFDQSxhQUFhLDRDQUE0QztBQUN6RDs7QUFFQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsOEVBQWMsQ0FBQyxrRUFBUztBQUNsQyxHQUFHLG1CQUFtQixJQUFJLFVBQVU7O0FBRXBDOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQnNDO0FBQ2tCO0FBQ1Y7QUFDc0I7QUFDSDtBQUNkOztBQUVuRDtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaURBQWlEO0FBQzlELGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsK0RBQStEO0FBQzVFLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVPLHFCQUFxQiw0REFBUztBQUNyQztBQUNBLFlBQVk7QUFDWjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsbUJBQW1CLGlFQUFXO0FBQzlCLFdBQVcsOEJBQThCO0FBQ3pDLFlBQVksbUZBQWdCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxhQUFhLHNFQUFhOztBQUUxQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksc0NBQXNDLFFBQVE7QUFDMUQsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLHNDQUFzQyxHQUFHO0FBQ3JELFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSwyQkFBMkIsNENBQTRDO0FBQ3ZFLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsU0FBUyx1REFBUztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSTJDO0FBQ2pCO0FBQ29CO0FBQytCOztBQUU3RTtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsK0RBQStEO0FBQzVFOztBQUVBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDTztBQUNQLGNBQWMseURBQVk7QUFDMUIsU0FBUyw0REFBUztBQUNsQjtBQUNBLGNBQWM7QUFDZDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLG1CQUFtQixvQ0FBSSxLQUFLLDRGQUFjO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekI4QztBQUNnQjtBQUN4QjtBQUNJOztBQUUxQztBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ087QUFDUDtBQUNBLGNBQWMsNERBQWM7QUFDNUIscUJBQXFCLDRFQUFxQjtBQUMxQyxZQUFZLHdEQUFZO0FBQ3hCLFVBQVUsb0RBQVU7QUFDcEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmc0M7QUFDUztBQUNtQjtBQUNoQjs7QUFFbEQ7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtFQUFrRTtBQUMvRTs7QUFFTyxtQkFBbUIsNERBQVM7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxlQUFlLFVBQVUsdURBQVM7QUFDdEYsNkNBQTZDLE9BQU8sWUFBWSxpRUFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekMrQztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtFQUFrRTtBQUMvRTs7QUFFTyxxQkFBcUIsNERBQVM7QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCcUM7QUFDUztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtFQUFrRTtBQUMvRTs7QUFFTyw4QkFBOEIsNERBQVM7QUFDOUM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwsNkNBQTZDLGVBQWUsVUFBVSx1REFBUztBQUMvRTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCcUM7QUFDUztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtFQUFrRTtBQUMvRTs7QUFFTyx1QkFBdUIsNERBQVM7QUFDdkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLOztBQUVMLDZDQUE2QyxlQUFlLFVBQVUsdURBQVM7QUFDL0U7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sa0JBQWtCLDREQUFTO0FBQ2xDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJtQztBQUNBO0FBQ0Y7QUFDSTs7QUFFdEM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxTQUFTLGtEQUFTO0FBQ2xCLFNBQVMsa0RBQVM7QUFDbEIsUUFBUSxnREFBUTtBQUNoQixVQUFVLG9EQUFVO0FBQ3BCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZzQztBQUM4QjtBQUNyQjtBQUNtQjtBQUNkOztBQUVwRDtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsZ0VBQWdFO0FBQzdFOztBQUVPLGtCQUFrQiw0REFBUztBQUNsQztBQUNBLFlBQVk7QUFDWjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsbUJBQW1CLGlFQUFXOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrRUFBaUI7QUFDdkM7QUFDQSxnQkFBZ0IsbUZBQWdCO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxtQkFBbUIsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNELE9BQU87QUFDUCwwQkFBMEIsNkJBQTZCO0FBQ3ZEOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx1REFBUztBQUNwQjs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q3FDO0FBQ1M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0UsYUFBYSw2Q0FBNkM7QUFDMUQ7O0FBRU8saUJBQWlCLDREQUFTO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxTQUFTLHVEQUFTO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkRzQztBQUNTO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsZ0VBQWdFO0FBQzdFOztBQUVPLG1CQUFtQiw0REFBUztBQUNuQztBQUNBLFlBQVk7QUFDWjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBLFlBQVksTUFBTSx1REFBUztBQUMzQjs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QjhDO0FBQ21CO0FBQ2Y7O0FBRW5EO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxvRUFBb0U7QUFDakY7O0FBRU8sa0JBQWtCLDREQUFTO0FBQ2xDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMLFdBQVcsUUFBUTs7QUFFbkIsWUFBWSw4QkFBOEIsT0FBTyxXQUFXLGtFQUFTO0FBQ3JFOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCOEM7QUFDbUI7QUFDZjs7QUFFbkQ7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLG9FQUFvRTtBQUNqRjs7QUFFTyxvQkFBb0IsNERBQVM7QUFDcEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwsV0FBVyxRQUFROztBQUVuQixZQUFZLDhCQUE4QixPQUFPLFdBQVcsa0VBQVM7QUFDckU7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Qm1DO0FBQ0k7QUFDRjtBQUNFO0FBQ047O0FBRWxDO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQO0FBQ0EsU0FBUyxrREFBUztBQUNsQixXQUFXLHNEQUFXO0FBQ3RCLFVBQVUsb0RBQVU7QUFDcEIsV0FBVyxzREFBVztBQUN0QixRQUFRLGdEQUFRO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQitDO0FBQ21CO0FBQ2Y7O0FBRW5EO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxvRUFBb0U7QUFDakY7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTCxXQUFXLFFBQVE7O0FBRW5CLFlBQVksOEJBQThCLE9BQU8sV0FBVyxrRUFBUztBQUNyRTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQjhDO0FBQ21CO0FBQ2Y7O0FBRW5EO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxvRUFBb0U7QUFDakY7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMLFdBQVcsUUFBUTs7QUFFbkIsWUFBWSw4QkFBOEIsT0FBTyxXQUFXLGtFQUFTO0FBQ3JFOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCOEM7QUFDbUI7QUFDZjs7QUFFbkQ7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLG9FQUFvRTtBQUNqRjs7QUFFTyxpQkFBaUIsNERBQVM7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwsV0FBVyxRQUFROztBQUVuQixZQUFZLDhCQUE4QixPQUFPLFdBQVcsa0VBQVM7QUFDckU7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QjZDO0FBQ21COztBQUVqRTtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLGtCQUFrQiw0REFBUztBQUNsQztBQUNBLFlBQVk7QUFDWjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUI2QztBQUNtQjs7QUFFakU7QUFDQSxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyx1QkFBdUIsNERBQVM7QUFDdkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxpRUFBaUU7QUFDOUU7O0FBRU8scUJBQXFCLDREQUFTO0FBQ3JDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQjhDO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVPLGtCQUFrQiw0REFBUztBQUNsQztBQUNBLFlBQVk7QUFDWjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JtRDtBQUNoQjtBQUNPO0FBQ0M7QUFDUjs7QUFFcEM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxZQUFZLHlEQUFZO0FBQ3hCLFNBQVMsa0RBQVM7QUFDbEIsU0FBUyxrREFBUztBQUNsQixhQUFhLDBEQUFhO0FBQzFCLGNBQWMsa0VBQWM7QUFDNUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJrRDtBQUNtQjs7QUFFckU7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxhQUFhLDBFQUEwRTtBQUN2Rjs7QUFFTyxvQkFBb0IsNERBQVM7QUFDcEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCdUM7QUFDRjs7QUFFdEM7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNPO0FBQ1A7QUFDQSxXQUFXLHNEQUFXO0FBQ3RCLFVBQVUsb0RBQVU7QUFDcEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1g0RDtBQUNWO0FBQ21COztBQUVyRTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsMEVBQTBFO0FBQ3ZGOztBQUVPLG1CQUFtQiw0REFBUztBQUNuQztBQUNBLFlBQVk7QUFDWjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZ0NBQWdDLG9CQUFvQixnQkFBZ0Isc0VBQWE7QUFDakY7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCMkU7QUFDUjtBQUNyQjtBQUNtQjtBQUNkOztBQUVwRDtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVPLHNCQUFzQiw0REFBUztBQUN0QztBQUNBLFlBQVk7QUFDWjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsbUJBQW1CLGlFQUFXOztBQUU5QjtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBLGNBQWMsbUZBQWdCLEVBQUUsbUVBQW9CO0FBQ3BEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEM4QztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGlFQUFpRTtBQUM5RTs7QUFFTyxrQkFBa0IsNERBQVM7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9DK0M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSw4REFBOEQ7QUFDM0U7O0FBRU8scUJBQXFCLDREQUFTO0FBQ3JDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCOEM7QUFDSjtBQUNmO0FBQ0Y7QUFDSTtBQUMrQjs7QUFFN0Q7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFQTtBQUNBLFdBQVcsa0RBQWtEO0FBQzdELFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ087QUFDUCxhQUFhLDREQUFTO0FBQ3RCLHFCQUFxQix3REFBYzs7QUFFbkM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGtCQUFrQixxQ0FBSyxDQUFDLHdEQUFPO0FBQy9CLGtCQUFrQixvQ0FBSSxDQUFDLHdEQUFPO0FBQzlCLG1CQUFtQix3REFBd0Q7QUFDM0U7O0FBRUE7QUFDQSxnQkFBZ0IscUNBQU87QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEQrQztBQUNtQjtBQUNkO0FBQ2dCO0FBQzlCOztBQUV0QztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLHFCQUFxQiw0REFBUztBQUNyQztBQUNBLFlBQVk7QUFDWjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLG1CQUFtQixpRUFBVztBQUM5QixXQUFXLGdCQUFnQixTQUFTLG1GQUFnQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCLEVBQUUsZ0NBQWdDO0FBQ3ZFLEtBQUs7O0FBRUwsc0JBQXNCLE9BQU87QUFDN0I7QUFDQSxlQUFlLE9BQU8sV0FBVyxlQUFlOztBQUVoRDtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFDeUM7QUFDTjtBQUNNO0FBQ047QUFDUTs7QUFFNUM7QUFDQSxXQUFXLGtEQUFrRDtBQUM3RCxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxZQUFZLHdEQUFZO0FBQ3hCLFNBQVMsa0RBQVM7QUFDbEIsWUFBWSx3REFBWTtBQUN4QixTQUFTLGtEQUFTO0FBQ2xCLGFBQWEsMERBQWE7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJzQztBQUNTO0FBQ3FCO0FBQ0Y7QUFDZDs7QUFFcEQ7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFQTtBQUNBLFdBQVcsa0RBQWtEO0FBQzdELFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ087QUFDUCxhQUFhLDREQUFTO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixpRUFBVzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtFQUFpQjtBQUN2QztBQUNBLGdCQUFnQixtRkFBZ0I7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsYUFBYSx1REFBUztBQUN0Qjs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JFc0M7QUFDUztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxzQkFBc0IsNERBQVM7QUFDdEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckMsZ0JBQWdCLFNBQVMsRUFBRSxtQkFBbUIsYUFBYSwrQkFBK0I7QUFDMUY7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMOztBQUVBLFlBQVksTUFBTSx1REFBUztBQUMzQjs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QjhDO0FBQ21CO0FBQ3pCOztBQUV6QztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLHVCQUF1Qiw0REFBUztBQUN2QztBQUNBLFlBQVk7QUFDWjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QjhDO0FBQ21CO0FBQ3pCOztBQUV6QztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLHdCQUF3Qiw0REFBUztBQUN4QztBQUNBLFlBQVk7QUFDWjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0I4QztBQUNtQjtBQUN6QjtBQUM2Qjs7QUFFdEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxrQkFBa0IsNERBQVM7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSx5Q0FBeUMsK0RBQWtCO0FBQzNEO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQjhDO0FBQ0U7QUFDYjtBQUNRO0FBQ1I7QUFDSTs7QUFFeEM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxjQUFjLDZEQUFjO0FBQzVCLGVBQWUsK0RBQWU7QUFDOUIsU0FBUyxrREFBUztBQUNsQixhQUFhLDBEQUFhO0FBQzFCLFNBQVMsa0RBQVM7QUFDbEIsV0FBVyxzREFBVztBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CNEU7QUFVaEQ7QUFDdUI7QUFDRDs7QUFFbEQ7QUFDQSxhQUFhLDJDQUEyQztBQUN4RCxhQUFhLDRDQUE0QztBQUN6RDs7QUFFQTtBQUNBLFlBQVkscURBQXFELDRCQUE0QixJQUFJO0FBQ2pHLGFBQWE7QUFDYjtBQUNPO0FBQ1AscUJBQXFCLDREQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDREQUFZO0FBQ2pDO0FBQ0EsWUFBWSxpRUFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVksT0FBTyxLQUFLLGlFQUFnQixvQ0FBb0Msa0VBQVMsd0JBQXdCO0FBQ3pKLCtDQUErQyxZQUFZLE9BQU8sS0FBSyxpRUFBZ0Isb0NBQW9DLGtFQUFTLHdCQUF3QjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIseURBQVM7QUFDOUI7QUFDQSxlQUFlLCtDQUErQztBQUM5RDtBQUNBO0FBQ0Esc0JBQXNCLGlFQUFnQjtBQUN0QyxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBZ0I7QUFDNUIseURBQXlELGtFQUFTO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0RBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVksT0FBTyxLQUFLLGlFQUFnQixvQ0FBb0Msa0VBQVMsd0JBQXdCO0FBQ3BKO0FBQ0E7O0FBRUEscUJBQXFCLHFEQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQW9CO0FBQ2pDO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUFVO0FBQy9CLHdDQUF3QyxLQUFLLEtBQUssaUVBQWdCOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwyREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFnQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6SCtDO0FBQ21CO0FBQ3pCOztBQUV6QztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFLGFBQWEsK0JBQStCO0FBQzVDOztBQUVPLHNCQUFzQiw0REFBUztBQUN0QztBQUNBLFlBQVk7QUFDWjtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsZUFBZSxNQUFNO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDOEM7QUFDbUI7QUFDRTtBQUNoQjtBQUNrQjtBQUM3Qjs7QUFFekM7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxrQkFBa0IsNERBQVM7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLG1CQUFtQixpRUFBVzs7QUFFOUI7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckMseUNBQXlDLCtEQUFrQjtBQUMzRDtBQUNBLE9BQU87QUFDUDtBQUNBLGNBQWMsbUZBQWdCO0FBQzlCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QzhDO0FBQ21CO0FBQ3pCOztBQUV6QztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLG9CQUFvQiw0REFBUztBQUNwQztBQUNBLFlBQVk7QUFDWjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCRDtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVndDO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLG1CQUFtQiw0REFBUztBQUNuQztBQUNBLFlBQVk7QUFDWjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCcUM7QUFDRjtBQUNBOztBQUVwQztBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ087QUFDUDtBQUNBLFVBQVUsb0RBQVU7QUFDcEIsU0FBUyxrREFBUztBQUNsQixTQUFTLGtEQUFTO0FBQ2xCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2IrQztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyxrQkFBa0IsNERBQVM7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckI4QztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyxrQkFBa0IsNERBQVM7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCNkM7QUFDbUI7O0FBRWpFO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sa0JBQWtCLDREQUFTO0FBQ2xDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCcUM7QUFDUztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTs7QUFFTyxpQkFBaUIsNERBQVM7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1REFBdUQ7QUFDdkQsZUFBZSwrQ0FBK0M7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckMsc0RBQXNELHVEQUFTLGlCQUFpQixJQUFJO0FBQ3BGO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JxQztBQUNTO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsZ0VBQWdFO0FBQzdFOztBQUVPLG9CQUFvQiw0REFBUztBQUNwQztBQUNBLFlBQVk7QUFDWjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQSxXQUFXLHVEQUFTO0FBQ3BCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQnVDO0FBQ047QUFDTTtBQUNOO0FBQ007QUFDTjtBQUNJO0FBQ0o7QUFDSTtBQUNFO0FBQ0E7O0FBRXhDO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQO0FBQ0EsV0FBVyxzREFBVztBQUN0QixRQUFRLGdEQUFRO0FBQ2hCLFdBQVcsc0RBQVc7QUFDdEIsUUFBUSxnREFBUTtBQUNoQixXQUFXLHNEQUFXO0FBQ3RCLFFBQVEsZ0RBQVE7QUFDaEIsVUFBVSxvREFBVTtBQUNwQixRQUFRLGdEQUFRO0FBQ2hCLFVBQVUsb0RBQVU7QUFDcEIsV0FBVyxzREFBVztBQUN0QixXQUFXLHVEQUFXO0FBQ3RCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JzQztBQUM2QztBQUNwQztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTtBQUNPLGlCQUFpQiw0REFBUztBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckMsYUFBYSx1REFBUyxrQkFBa0IsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0dBQXlCO0FBQ3pEO0FBQ0EsT0FBTztBQUNQLDhCQUE4QixnR0FBeUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFTO0FBQ3pCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pEK0M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8saUJBQWlCLDREQUFTO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0I4QztBQUNtQjtBQUNsRTtBQUMrQzs7QUFFL0M7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTs7QUFFTyxtQkFBbUIsNERBQVM7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTCxZQUFZLG1EQUFVO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUI4QztBQUNtQjtBQUN6Qjs7QUFFekM7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTs7QUFFTyxpQkFBaUIsNERBQVM7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qix3QkFBd0IsNkRBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbENxQztBQUM2QztBQUNwQztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTs7QUFFTyxtQkFBbUIsNERBQVM7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDJCQUEyQixnR0FBeUI7QUFDcEQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0EsY0FBYyx1REFBUztBQUN2QjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDK0M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QnNEO0FBQ0w7QUFDSDtBQUNxQjtBQUNGO0FBQ2Q7O0FBRXBEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQVc7O0FBRTlCO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxtRkFBZ0I7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQixvRUFBWTtBQUM1QixpQkFBaUIsK0RBQVU7QUFDM0IsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzFDNkM7O0FBRXZDLGdDQUFnQyw0REFBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNicUM7QUFDUTtBQUNtQjs7QUFFakU7QUFDQSxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyxrQkFBa0IsNERBQVM7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSwwQ0FBMEM7QUFDMUMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxjQUFjLDZCQUE2Qix3REFBVSxjQUFjO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ3VEO0FBQ0w7QUFDTDtBQUNtQjtBQUNmOztBQUVsRDtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLGlCQUFpQiw0REFBUztBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsU0FBUyxzRUFBYTtBQUN0Qjs7QUFFQSxnQkFBZ0IsaUVBQWdCOztBQUVoQztBQUNBLDBEQUEwRCxPQUFPLFdBQVcsa0VBQVM7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENEOztBQUV1RDtBQUNFO0FBQ0E7QUFDcEI7QUFDSTtBQUNBO0FBQ047QUFDb0I7QUFDSTtBQUNUO0FBQ0o7QUFDUTtBQUNOO0FBQ047QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNBO0FBQ0U7QUFDSTtBQUNOO0FBQ007QUFDSjtBQUNBO0FBQ0U7QUFDQTtBQUNWO0FBQ087QUFDUDtBQUNVO0FBQ1Y7QUFDOEI7QUFDOUI7QUFDRjtBQUNhO0FBQ2I7QUFDTTtBQUNGO0FBQ007QUFDSjtBQUNGO0FBQ007QUFDc0I7O0FBRWxFO0FBQ0EsYUFBYSw2REFBNkQ7QUFDMUUsYUFBYSx3REFBd0Q7QUFDckUsYUFBYSwyREFBMkQ7QUFDeEUsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSwrQkFBK0I7QUFDNUMsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSxpQ0FBaUM7QUFDOUMsYUFBYSxpQ0FBaUM7QUFDOUM7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTyw2QkFBNkI7QUFDcEM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVUsdUVBQWE7QUFDdkIsVUFBVSx1RUFBYTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUIsd0NBQXdDLHNEQUFLOztBQUU3Qzs7QUFFQSx5QkFBeUIsa0VBQVU7QUFDbkM7QUFDQTtBQUNBLEdBQUc7O0FBRUgsYUFBYSxhQUFhO0FBQzFCLG9DQUFvQyx1REFBTTs7QUFFMUMsR0FBRyw4TUFBSyxFQUFFLG9OQUFPLEVBQUUsb05BQU8sRUFBRSxxQ0FBTzs7QUFFbkMsMEJBQTBCLG9FQUFXO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHOztBQUVILGFBQWEsa0JBQWtCO0FBQy9CLHlDQUF5Qyx1REFBTTs7QUFFL0M7O0FBRUEsMEJBQTBCLG9FQUFXO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHOztBQUVILGFBQWEsZUFBZTtBQUM1QjtBQUNBLFNBQVMsbURBQVM7QUFDbEIsWUFBWSwwREFBWTtBQUN4QixhQUFhLGdFQUFhO0FBQzFCLFdBQVcsNkRBQVc7QUFDdEIsZUFBZSxxRUFBZTtBQUM5QixTQUFTLG1EQUFTO0FBQ2xCLGNBQWMsNkRBQWM7QUFDNUIsWUFBWSwrREFBWTtBQUN4QixTQUFTLHlEQUFTO0FBQ2xCLFNBQVMseURBQVM7QUFDbEIsVUFBVSwyREFBVTtBQUNwQixTQUFTLG1EQUFTO0FBQ2xCLFdBQVcsNkRBQVc7QUFDdEIsU0FBUyxtREFBUztBQUNsQix1QkFBdUIsaUZBQXVCO0FBQzlDLFFBQVEsaURBQVE7QUFDaEIsY0FBYyw4REFBYztBQUM1QixTQUFTLHlEQUFTO0FBQ2xCLFNBQVMseURBQVM7QUFDbEIsUUFBUSxpREFBUTtBQUNoQixXQUFXLHVEQUFXO0FBQ3RCLFVBQVUsMkRBQVU7QUFDcEIsWUFBWSwrREFBWTtBQUN4QixTQUFTLHlEQUFTO0FBQ2xCLFVBQVUscURBQVU7QUFDcEIsWUFBWSwrREFBWTtBQUN4QixVQUFVLDJEQUFVO0FBQ3BCLFVBQVUsMkRBQVU7QUFDcEIsYUFBYSwyREFBYTtBQUMxQixXQUFXLHVEQUFXO0FBQ3RCLFdBQVcsNkRBQVc7QUFDdEIsVUFBVSxxREFBVTtBQUNwQixXQUFXLDZEQUFXO0FBQ3RCLGFBQWEsMkRBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFc0M7QUFDYTtBQUNzQjtBQUNsRSxtQkFBbUIsaUVBQWdCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hKUjs7QUFFbEM7QUFDQSxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ087QUFDUCxhQUFhLGdEQUFROztBQUVyQjtBQUNBLFlBQVk7QUFDWjtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEIrQztBQUNqQjs7QUFFOUI7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxxQkFBcUIsNERBQVM7QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1REFBdUQ7QUFDdkQsVUFBVSxxQ0FBTztBQUNqQjs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQndEO0FBQ1Y7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSw4REFBOEQ7QUFDM0U7O0FBRU8sa0JBQWtCLDREQUFTO0FBQ2xDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxzRUFBYTtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCd0Q7QUFDVjtBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxxQkFBcUIsNERBQVM7QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCeUM7QUFDTjtBQUNNO0FBQ0o7QUFDQTtBQUNJO0FBQ1I7O0FBRWxDO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQO0FBQ0EsWUFBWSx3REFBWTtBQUN4QixTQUFTLGtEQUFTO0FBQ2xCLFlBQVksd0RBQVk7QUFDeEIsVUFBVSxvREFBVTtBQUNwQixVQUFVLG9EQUFVO0FBQ3BCLFlBQVksd0RBQVk7QUFDeEIsUUFBUSxnREFBUTtBQUNoQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQitDO0FBQ2pCOztBQUU5QjtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLG1CQUFtQiw0REFBUztBQUNuQztBQUNBLFlBQVk7QUFDWjtBQUNBLHdDQUF3QztBQUN4QyxVQUFVLHFDQUFPO0FBQ2pCOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCd0Q7QUFDVjtBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxtQkFBbUIsNERBQVM7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsNkNBQTZDLElBQUksV0FBVyxzRUFBYTtBQUN6RTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCd0Q7QUFDVjtBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxxQkFBcUIsNERBQVM7QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJ3RDtBQUNWO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLGlCQUFpQiw0REFBUztBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxzRUFBYTtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QnFDOztBQUV0QztBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNPO0FBQ1AsU0FBUyxxREFBUztBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZEE7O0FBRWtDOztBQUVsQztBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsNENBQU07QUFDeEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUJBOztBQUVxRDtBQUNpQjtBQUM1QjtBQUNIO0FBQ0U7QUFDSjtBQUNzQjtBQUNmOztBQUU1QyxZQUFZLHNEQUFNO0FBQ2xCLGNBQWMsK0NBQWMsRUFBRSx3QkFBd0I7O0FBRXRELHlCQUF5Qiw0REFBUyxJQUFJLDhEQUFXO0FBQ2pELHFCQUFxQiw0REFBUyxJQUFJLDhEQUFXO0FBQzdDLHFCQUFxQiw0REFBUyxJQUFJLDhEQUFXOztBQUU3QztBQUNBLGFBQWEsMkNBQTJDO0FBQ3hELGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsNENBQTRDO0FBQ3pEOztBQUVBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsYUFBYTtBQUNiO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUEscUNBQXFDLG9FQUFXO0FBQ2hELGtCQUFrQiwwRUFBVztBQUM3QixHQUFHO0FBQ0g7QUFDQSxHQUFHLDZDQUE2QyxvRUFBVztBQUMzRCxrQkFBa0IsMEVBQVc7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVMsS0FBSyxLQUFLLEdBQUcsS0FBSztBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsTUFBTSx5REFBTTtBQUNaLGtCQUFrQiw4REFBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsbUJBQW1CLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxNQUFNO0FBQ25CLGtCQUFrQiw2REFBYzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EscUNBQXFDLDJDQUFhO0FBQ2xEOztBQUVPLHFCQUFxQixtREFBSTtBQUNoQztBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFlBQVk7QUFDM0I7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxzQkFBc0IsU0FBUyxHQUFHLFNBQVM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sa0JBQWtCLDZEQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25OcUM7QUFDTjtBQUNqQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQSx3QkFBd0IsK0RBQWtCOztBQUUxQztBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQSx5QkFBeUIsdUVBQWdCOztBQUV6QztBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQSxzQ0FBc0MsK0RBQWtCLENBQUMsdUVBQWdCLGdCQUFnQjs7QUFFekY7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLHVFQUFnQixDQUFDLG1FQUFvQjs7QUFFYzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Q3BGO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkb0Q7O0FBRXBEO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDTztBQUNQLGVBQWUsa0VBQWE7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsb0JBQW9CO0FBQ2pDOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSyw0QkFBNEI7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlCOEI7O0FBRTlCO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLCtCQUErQixhQUFhO0FBQzFEOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHFDQUFPO0FBQ2pCOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFc0M7QUFDUjs7QUFFOUI7QUFDQSxhQUFhLGlEQUFpRDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLE9BQU87QUFDbEIsV0FBVyxrREFBa0Q7QUFDN0QsV0FBVywwREFBMEQ7QUFDckUsV0FBVyxhQUFhO0FBQ3hCO0FBQ087QUFDUDtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHFDQUFPLHNDQUFzQyxLQUFLO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxxQ0FBTyw2QkFBNkIsSUFBSSxVQUFVLFFBQVE7QUFDdEU7O0FBRUEsZ0JBQWdCLHVEQUFTOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlEa0Q7QUFDQTs7QUFFbEQ7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhO0FBQ2I7QUFDTyw2QkFBNkIsc0RBQXNELEtBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0RBQVU7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnRUFBWTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLElBQUk7O0FBRTlCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q3dDO0FBQ047QUFDSTs7QUFFdEM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxXQUFXLHNEQUFXO0FBQ3RCLFFBQVEsZ0RBQVE7QUFDaEIsVUFBVSxvREFBVTtBQUNwQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYnlEO0FBQ1Y7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSw4REFBOEQ7QUFDM0U7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMLFdBQVcsc0VBQWE7QUFDeEI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSw4REFBOEQ7QUFDM0U7O0FBRU8saUJBQWlCLDREQUFTO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSw4REFBOEQ7QUFDM0U7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCcUM7QUFDUTtBQUNtQjtBQUNyQjs7QUFFNUM7QUFDQSxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyxpQkFBaUIsNERBQVM7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekMsdUJBQXVCLDZCQUE2Qix3REFBVSxjQUFjOztBQUU1RTtBQUNBLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFLDRCQUE0QiwwREFBVTs7QUFFdEM7QUFDQSxPQUFPO0FBQ1AsZUFBZSx1REFBUztBQUN4Qjs7QUFFQSxpQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvR3dEO0FBQ1Y7QUFDbUI7O0FBRWpFO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTCxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkIyQztBQUNBO0FBQ0k7O0FBRWhEO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQO0FBQ0EsYUFBYSwwREFBYTtBQUMxQixhQUFhLDBEQUFhO0FBQzFCLFlBQVksOERBQVk7QUFDeEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2J5RDtBQUNWO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLHNCQUFzQiw0REFBUztBQUN0QztBQUNBLFlBQVk7QUFDWjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQyxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0IyRDtBQUNWO0FBQ21COztBQUVyRTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsc0VBQXNFO0FBQ25GOztBQUVPLHFCQUFxQiw0REFBUztBQUNyQztBQUNBLFlBQVk7QUFDWjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFdBQVcsc0VBQWE7QUFDeEI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQnlDO0FBQ0Y7QUFDRjs7QUFFdEM7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNPO0FBQ1A7QUFDQSxZQUFZLHdEQUFZO0FBQ3hCLFdBQVcsc0RBQVc7QUFDdEIsVUFBVSxvREFBVTtBQUNwQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYjREO0FBQ1Y7QUFDbUI7O0FBRXJFO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxzRUFBc0U7QUFDbkY7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFdBQVcsc0VBQWE7QUFDeEI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCaUQ7QUFDbUI7O0FBRXJFO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxzRUFBc0U7QUFDbkY7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sc0JBQXNCLDREQUFTO0FBQ3RDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QnFDO0FBQ1M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxpRUFBaUU7QUFDOUU7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDLGdCQUFnQiw0QkFBNEIsd0RBQVUsWUFBWTtBQUNsRTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCcUM7QUFDUztBQUNtQjtBQUNVOztBQUU1RTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVPLGtCQUFrQiw0REFBUztBQUNsQztBQUNBLFlBQVk7QUFDWjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQyxnQkFBZ0IsNEJBQTRCLHdEQUFVLFlBQVk7QUFDbEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0EsY0FBYyx1REFBUztBQUN2QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDcUM7QUFDRjtBQUNJO0FBQ0o7QUFDQTtBQUNFO0FBQ1E7O0FBRTlDO0FBQ0EsV0FBVyxrREFBa0Q7QUFDN0QsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQO0FBQ0EsVUFBVSxvREFBVTtBQUNwQixTQUFTLGtEQUFTO0FBQ2xCLFdBQVcsc0RBQVc7QUFDdEIsU0FBUyxrREFBUztBQUNsQixTQUFTLGtEQUFTO0FBQ2xCLFVBQVUsb0RBQVU7QUFDcEIsV0FBVyw0REFBVztBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJzQztBQUNTO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVPLG9CQUFvQiw0REFBUztBQUNwQztBQUNBLFlBQVk7QUFDWjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQyxnQkFBZ0IsNEJBQTRCLHdEQUFVLFlBQVk7QUFDbEU7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsOENBQThDLElBQUk7QUFDbEQ7QUFDQTtBQUNBLFlBQVksdURBQVM7QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JxQztBQUNTO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVPLGtCQUFrQiw0REFBUztBQUNsQztBQUNBLFlBQVk7QUFDWjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTCxXQUFXLE9BQU87O0FBRWxCLFdBQVcsdURBQVM7QUFDcEI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QnFDO0FBQ1k7QUFDbUI7O0FBRXJFO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSx1RUFBdUU7QUFDcEY7O0FBRU8sc0JBQXNCLDREQUFTO0FBQ3RDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwsV0FBVyxPQUFPOztBQUVsQixXQUFXLHVEQUFTO0FBQ3BCOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNxQztBQUM4QjtBQUNsQjtBQUNtQjtBQUNkOztBQUV2RDtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsdUVBQXVFO0FBQ3BGOztBQUVPLHlCQUF5Qiw0REFBUztBQUN6QztBQUNBLFlBQVk7QUFDWjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsbUJBQW1CLGlFQUFXOztBQUU5QjtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQyxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBLE9BQU87QUFDUDtBQUNBLGNBQWMsbUZBQWdCO0FBQzlCO0FBQ0EsS0FBSzs7QUFFTCxXQUFXLE9BQU87O0FBRWxCLFdBQVcsdURBQVM7QUFDcEI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEM0QztBQUNNO0FBQ1I7QUFDRTs7QUFFN0M7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNPO0FBQ1A7QUFDQSxhQUFhLDJEQUFhO0FBQzFCLGdCQUFnQixpRUFBZ0I7QUFDaEMsWUFBWSx5REFBWTtBQUN4QixhQUFhLDJEQUFhO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmc0M7QUFDWTtBQUNtQjs7QUFFckU7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxhQUFhLHVFQUF1RTtBQUNwRjs7QUFFTyxxQkFBcUIsNERBQVM7QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMLFdBQVcsT0FBTzs7QUFFbEIsV0FBVyx1REFBUztBQUNwQjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaENxQztBQUM4QjtBQUNsQjtBQUNtQjtBQUNkOztBQUV2RDtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsdUVBQXVFO0FBQ3BGOztBQUVPLHNCQUFzQiw0REFBUztBQUN0QztBQUNBLFlBQVk7QUFDWjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsbUJBQW1CLGlFQUFXOztBQUU5QjtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxtRkFBZ0I7QUFDOUI7QUFDQSxLQUFLOztBQUVMLFdBQVcsT0FBTzs7QUFFbEIsV0FBVyx1REFBUztBQUNwQjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEM4QztBQUNVOztBQUV6RDtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVBO0FBQ0EsV0FBVyxrREFBa0Q7QUFDN0QsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQLGFBQWEsNERBQVM7QUFDdEIsbUJBQW1CLHNEQUFZOztBQUUvQjtBQUNBLGNBQWM7QUFDZDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQnNDO0FBQ1M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxpRUFBaUU7QUFDOUU7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx1REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CcUM7QUFDUztBQUNzQjtBQUNIOztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVPLHFCQUFxQiw0REFBUztBQUNyQztBQUNBLFlBQVk7QUFDWjtBQUNBLCtDQUErQztBQUMvQyxzQkFBc0IsNEJBQTRCLElBQUksb0ZBQWM7QUFDcEU7QUFDQTtBQUNBLHNCQUFzQiwrRUFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87O0FBRVA7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQkFBa0IsdURBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBLGNBQWMsdURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekMwQztBQUNqQjtBQUNxQjs7QUFFL0M7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ087QUFDUCxjQUFjLHlEQUFZOztBQUUxQixTQUFTLDREQUFTO0FBQ2xCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYSxvQ0FBSTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QjJDO0FBQ1A7QUFDRjtBQUNPO0FBQ1A7QUFDYzs7QUFFaEQ7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxZQUFZLHlEQUFZO0FBQ3hCLFNBQVMsa0RBQVM7QUFDbEIsUUFBUSxnREFBUTtBQUNoQixXQUFXLHVEQUFXO0FBQ3RCLFFBQVEsZ0RBQVE7QUFDaEIsWUFBWSw4REFBWTtBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJzQztBQUNTO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0EsYUFBYSwyQ0FBMkM7QUFDeEQ7QUFDQTtBQUNBLFNBQVMsdURBQVM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU8saUJBQWlCLDREQUFTO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbUNBQW1DO0FBQ25DLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURzRDs7QUFFdkQ7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxhQUFhLHFFQUFxRTtBQUNsRjs7QUFFQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ087QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWUsRUFBRSxnQkFBZ0I7QUFDckQsS0FBSzs7QUFFTCxXQUFXLG9EQUFTO0FBQ3BCOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQjBDO0FBQ047QUFDRjtBQUNBO0FBQ087QUFDUzs7QUFFbEQ7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNPO0FBQ1AscUJBQXFCLGdEQUFNOztBQUUzQjtBQUNBLFNBQVMsa0RBQVM7QUFDbEIsUUFBUSxnREFBUTtBQUNoQixRQUFRLGdEQUFRO0FBQ2hCLFdBQVcsdURBQVc7QUFDdEIsYUFBYSxnRUFBYTtBQUMxQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCbUQ7O0FBRW5EO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxxRUFBcUU7QUFDbEY7O0FBRUE7QUFDQSxXQUFXLGdDQUFnQztBQUMzQztBQUNPO0FBQ1A7QUFDQSxZQUFZO0FBQ1o7QUFDQSx3QkFBd0IscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFXO0FBQy9CLEtBQUs7O0FBRUw7QUFDQSxZQUFZLG9EQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QndDOztBQUV4QztBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEscUVBQXFFO0FBQ2xGOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBVztBQUMvQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNCd0M7O0FBRXhDO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxxRUFBcUU7QUFDbEY7O0FBRUE7QUFDQSxXQUFXLGdDQUFnQztBQUMzQztBQUNPO0FBQ1A7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFXO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCd0U7QUFDN0I7O0FBRTNDO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYSw2RUFBNkU7QUFDMUY7O0FBRUE7QUFDQSxXQUFXLG1DQUFtQztBQUM5QztBQUNPO0FBQ1A7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsMENBQTBDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDLG9CQUFvQix5REFBYztBQUNsQyxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QjZDO0FBQ1Q7QUFDRjtBQUNBOztBQUVsQztBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ087QUFDUCxxQkFBcUIsZ0RBQU07O0FBRTNCO0FBQ0EsU0FBUyxrREFBUztBQUNsQixRQUFRLGdEQUFRO0FBQ2hCLFFBQVEsZ0RBQVE7QUFDaEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJ3RTtBQUN4Qjs7QUFFaEQ7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLDZFQUE2RTtBQUMxRjs7QUFFQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ087QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBLGlDQUFpQztBQUNqQztBQUNBLFdBQVcsaUNBQWlDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrRUFBaUIsRUFBRSxPQUFPO0FBQzlELEtBQUs7O0FBRUwsZ0JBQWdCLDBCQUEwQjtBQUMxQyxXQUFXLGlCQUFpQjs7QUFFNUIsOEJBQThCLDBEQUFtQjtBQUNqRDs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDd0U7O0FBRXhFO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYSw2RUFBNkU7QUFDMUY7O0FBRUE7QUFDQSxXQUFXLG1DQUFtQztBQUM5QztBQUNPO0FBQ1A7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0EsYUFBYSwwRUFBMEU7QUFDdkY7O0FBRUE7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3REc0M7QUFDK0I7O0FBRXJFO0FBQ0EsYUFBYSxpREFBaUQ7QUFDOUQsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxvREFBb0Q7QUFDakUsYUFBYSwrQ0FBK0M7QUFDNUQsYUFBYSxnREFBZ0Q7QUFDN0Q7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ08sb0JBQW9CLHVDQUF1QztBQUNsRTtBQUNBLFNBQVMsdURBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLElBQUk7QUFDZixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ087QUFDUCxNQUFNLHVEQUFTO0FBQ2Y7QUFDQSxHQUFHO0FBQ0gsNERBQTRELFdBQVc7QUFDdkU7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUyxpQkFBaUI7QUFDckMsYUFBYTtBQUNiO0FBQ08sc0JBQXNCLGtDQUFrQztBQUMvRCxnQkFBZ0IsK0VBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWMsU0FBUztBQUNsQyxhQUFhO0FBQ2I7QUFDTywwQkFBMEIsMENBQTBDO0FBQzNFLGlCQUFpQiwrRUFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRnNDO0FBQ1M7QUFDc0I7QUFDSDs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFTyxvQkFBb0IsNERBQVM7QUFDcEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSw4Q0FBOEM7QUFDOUMsc0JBQXNCLGtCQUFrQixJQUFJLG9GQUFjO0FBQzFEO0FBQ0Esb0NBQW9DLEtBQUs7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrRUFBaUI7QUFDdkM7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxPQUFPLFlBQVksdURBQVM7QUFDdkU7QUFDQTtBQUNBLGNBQWMsdURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekN3QztBQUNmO0FBQ3FCOztBQUUvQztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsOERBQThEO0FBQzNFOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQLGNBQWMsdURBQVc7O0FBRXpCLFNBQVMsNERBQVM7QUFDbEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhLG9DQUFJO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCd0Q7QUFDVjtBQUNtQjs7QUFFakU7QUFDQSxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyxtQkFBbUIsNERBQVM7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsa0VBQWE7QUFDOUIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JpQztBQUNNO0FBQ0k7QUFDSTtBQUNJO0FBQ1c7O0FBRS9EO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQLGtDQUFrQyx5RUFBbUI7O0FBRXJEO0FBQ0EsUUFBUSxnREFBUTtBQUNoQixXQUFXLHNEQUFXO0FBQ3RCLGFBQWEsMERBQWE7QUFDMUIsZUFBZSw4REFBZTtBQUM5QixpQkFBaUIsa0VBQWlCO0FBQ2xDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQitDO0FBQ21CO0FBQ0U7O0FBRXBFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxpRUFBaUU7QUFDOUU7O0FBRU8saUJBQWlCLDREQUFTO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDO0FBQ2pDLFdBQVcsVUFBVTtBQUNyQjtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLOztBQUVMLFdBQVcsaUZBQW1CO0FBQzlCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkI4QztBQUNtQjtBQUNEOztBQUVqRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsaUVBQWlFO0FBQzlFOztBQUVPLG9CQUFvQiw0REFBUztBQUNwQztBQUNBLFlBQVk7QUFDWjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQyxhQUFhLDhFQUFnQjtBQUM3QjtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwsV0FBVyxVQUFVOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QjhDO0FBQ21CO0FBQ0U7QUFDaEI7QUFDYTs7QUFFakU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGlFQUFpRTtBQUM5RTs7QUFFTyxzQkFBc0IsNERBQVM7QUFDdEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtREFBbUQ7QUFDbkQseUJBQXlCLCtFQUFpQjtBQUMxQyxXQUFXLDhFQUFnQjtBQUMzQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1CQUFtQixpRUFBVzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1GQUFnQjtBQUM5QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENzQztBQUNRO0FBQ21CO0FBQ21DO0FBQ25EO0FBQ2xELFlBQVksc0RBQU07O0FBRWxCO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSwyQ0FBMkM7QUFDeEQsYUFBYSxvREFBb0Q7QUFDakUsYUFBYSxtRUFBbUUsMkJBQTJCLEVBQUU7QUFDN0csYUFBYSwyQkFBMkI7QUFDeEM7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEU7QUFDTztBQUNQLFNBQVMsNERBQVM7QUFDbEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwwREFBMEQsR0FBRztBQUM3RDs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0VBQWlCO0FBQ3ZDLGVBQWUsOEVBQWdCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRCxXQUFXLE9BQU87QUFDbEIsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsZUFBZTtBQUMxQjtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBZ0I7QUFDbEMsa0JBQWtCLHdFQUFVO0FBQzVCLDRCQUE0Qix5RUFBVztBQUN2QyxtQkFBbUIsdUVBQVM7QUFDNUIsaUJBQWlCLHdFQUFVO0FBQzNCLHVCQUF1Qix3RUFBVTtBQUNqQyxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0Isd0VBQVU7QUFDNUIsbUJBQW1CLHVFQUFTO0FBQzVCLFdBQVc7QUFDWDtBQUNBLE9BQU8sbUJBQW1CLElBQUk7QUFDOUIseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQkFBbUIsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTLGNBQWM7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0pBO0FBQ0EsYUFBYSwyQ0FBMkM7QUFDeEQsYUFBYSwwREFBMEQ7QUFDdkU7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUI7O0FBRU87QUFDUDtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLHNCQUFzQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxpRUFBaUU7QUFDOUUsYUFBYSwyQkFBMkI7QUFDeEM7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEU7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJzQztBQUNtQjtBQUNWO0FBQ21CO0FBQzFCOztBQUV4QztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLG1CQUFtQiw0REFBUztBQUNuQztBQUNBLFlBQVk7QUFDWjtBQUNBLG1EQUFtRDtBQUNuRCxlQUFlLCtDQUErQztBQUM5RDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQyxtQ0FBbUMsNEJBQTRCLHdEQUFVLFlBQVk7QUFDckY7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsa0VBQWE7QUFDOUIsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxzREFBVztBQUN0QixHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25Dd0Q7QUFDVjtBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLCtEQUErRDtBQUM1RTs7QUFFTyxvQkFBb0IsNERBQVM7QUFDcEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGlCQUFpQixrRUFBYTtBQUM5QixvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEJxQztBQUNTO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLGlCQUFpQiw0REFBUztBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTLHVEQUFTO0FBQy9DO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QmlDO0FBQ0k7QUFDTTs7QUFFNUM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxRQUFRLGdEQUFRO0FBQ2hCLFVBQVUsb0RBQVU7QUFDcEIsYUFBYSwwREFBYTtBQUMxQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiK0M7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sc0JBQXNCLDREQUFTO0FBQ3RDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QjZDO0FBQ21COztBQUVqRTtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLHNCQUFzQiw0REFBUztBQUN0QztBQUNBLFlBQVk7QUFDWjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QjZDO0FBQ2hCOztBQUU5QjtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsK0RBQStEO0FBQzVFOztBQUVPLG9CQUFvQiw0REFBUztBQUNwQztBQUNBLFlBQVk7QUFDWjtBQUNBLG1DQUFtQztBQUNuQyxVQUFVLHFDQUFPO0FBQ2pCOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakI4QztBQUNtQjs7QUFFbEU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTs7QUFFTyxpQkFBaUIsNERBQVM7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCK0Q7QUFDTjtBQUN4Qjs7QUFFbEM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxhQUFhLDREQUFhO0FBQzFCLFVBQVUseURBQVU7QUFDcEIsUUFBUSxnREFBUTtBQUNoQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiOEM7QUFDbUI7O0FBRWpFO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sbUJBQW1CLDREQUFTO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCa0Q7QUFDSjtBQUNtQjtBQUNoQjs7QUFFbEQ7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGdFQUFnRTtBQUM3RTs7QUFFTyxvQkFBb0IsNERBQVM7QUFDcEM7QUFDQSxZQUFZO0FBQ1o7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixtQ0FBbUM7QUFDbkQsV0FBVyxRQUFROztBQUVuQjtBQUNBLFVBQVUsaUVBQWdCO0FBQzFCLHdDQUF3QyxrRUFBUztBQUNqRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCOEM7QUFDbUI7O0FBRWxFO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sc0JBQXNCLDREQUFTO0FBQ3RDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsV0FBVyxVQUFVOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQjhDO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsZ0VBQWdFO0FBQzdFOztBQUVPLHlCQUF5Qiw0REFBUztBQUN6QztBQUNBLFlBQVk7QUFDWjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLFdBQVcsVUFBVTs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJ1QztBQUNJO0FBQ007QUFDQztBQUNYOztBQUV4QztBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ087QUFDUDtBQUNBLFdBQVcsc0RBQVc7QUFDdEIsYUFBYSwwREFBYTtBQUMxQixnQkFBZ0IsZ0VBQWdCO0FBQ2hDLGdCQUFnQixpRUFBZ0I7QUFDaEMsV0FBVyxzREFBVztBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJtRDtBQUNKO0FBQ21COztBQUVsRTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsZ0VBQWdFO0FBQzdFOztBQUVPLHlCQUF5Qiw0REFBUztBQUN6QztBQUNBLFlBQVk7QUFDWjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLHFCQUFxQjtBQUNyQyxXQUFXLFVBQVU7O0FBRXJCLG9DQUFvQyxrRUFBUztBQUM3QztBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQmtEO0FBQ0o7QUFDbUI7QUFDaEI7O0FBRWxEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRU8sb0JBQW9CLDREQUFTO0FBQ3BDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsU0FBUyxzR0FBc0csS0FBSztBQUNwSSxXQUFXLFFBQVE7O0FBRW5CO0FBQ0E7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCLGNBQWMsaUVBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ3VEO0FBQ1Y7QUFDbUI7O0FBRWpFO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwrREFBK0Q7QUFDNUU7O0FBRU8sc0JBQXNCLDREQUFTO0FBQ3RDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsU0FBUyxzRUFBYTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCNkI7QUFDRztBQUNqQyxlQUFlLDRDQUFPOztBQUV0QjtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsNEJBQTRCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUscUNBQU87QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsV0FBVztBQUN4QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxZQUFZLHFDQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qyx5REFBeUQ7QUFDekQsK0NBQStDO0FBQy9DLHVEQUF1RDtBQUN2RCxxREFBcUQ7QUFDckQsc0VBQXNFO0FBQ3RFO0FBQ0EsY0FBYyxxQ0FBTztBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6VWpCO0FBQzhDOztBQUU5QztBQUNBLGdCQUFnQix5REFBZ0IsWUFBWSx5REFBZ0IsVUFBVSx1REFBYzs7QUFFcEY7QUFDQSxjQUFjLHVFQUE4QixLQUFLLHVFQUE4QixLQUFLOztBQUU3RTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCLFlBQVk7QUFDOUIsa0JBQWtCLG9CQUFvQjtBQUN0QyxrQkFBa0IsWUFBWTtBQUM5QixrQkFBa0IsWUFBWTtBQUM5QixrQkFBa0IsWUFBWTtBQUM5QixrQkFBa0IsZUFBZTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLHlCQUF5QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLEtBQUs7QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxjQUFjO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLDZCQUE2QjtBQUM1QyxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSwrQ0FBK0MscUVBQTRCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRU07O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsNkJBQTZCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLDZCQUE2QjtBQUM1QyxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSwrQ0FBK0MscUVBQTRCO0FBQzNFOztBQUVBO0FBQ0EsQ0FBQzs7QUFFTTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLDZCQUE2QjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSw2QkFBNkI7QUFDNUMsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsK0NBQStDLHFFQUE0QjtBQUMzRTs7QUFFQTtBQUNBLENBQUM7O0FBRTJCIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX2lwZnMtaHR0cC1jbGllbnRfc3JjX2luZGV4X2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ0BsaWJwMnAvcGVlci1pZCcpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVlcklkKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyICE9IG51bGwgJiYgQm9vbGVhbihvdGhlcltzeW1ib2xdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBiYXNlNThidGMgfSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzZXMvYmFzZTU4JztcbmltcG9ydCB7IGJhc2UzMiB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNlcy9iYXNlMzInO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jhc2VzL2Jhc2U2NCc7XG4vLyBBZGQgYSBmb3JtYXR0ZXIgZm9yIGNvbnZlcnRpbmcgdG8gYSBiYXNlNTggc3RyaW5nXG5kZWJ1Zy5mb3JtYXR0ZXJzLmIgPSAodikgPT4ge1xuICAgIHJldHVybiB2ID09IG51bGwgPyAndW5kZWZpbmVkJyA6IGJhc2U1OGJ0Yy5iYXNlRW5jb2RlKHYpO1xufTtcbi8vIEFkZCBhIGZvcm1hdHRlciBmb3IgY29udmVydGluZyB0byBhIGJhc2UzMiBzdHJpbmdcbmRlYnVnLmZvcm1hdHRlcnMudCA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/ICd1bmRlZmluZWQnIDogYmFzZTMyLmJhc2VFbmNvZGUodik7XG59O1xuLy8gQWRkIGEgZm9ybWF0dGVyIGZvciBjb252ZXJ0aW5nIHRvIGEgYmFzZTY0IHN0cmluZ1xuZGVidWcuZm9ybWF0dGVycy5tID0gKHYpID0+IHtcbiAgICByZXR1cm4gdiA9PSBudWxsID8gJ3VuZGVmaW5lZCcgOiBiYXNlNjQuYmFzZUVuY29kZSh2KTtcbn07XG4vLyBBZGQgYSBmb3JtYXR0ZXIgZm9yIHN0cmluZ2lmeWluZyBwZWVyIGlkc1xuZGVidWcuZm9ybWF0dGVycy5wID0gKHYpID0+IHtcbiAgICByZXR1cm4gdiA9PSBudWxsID8gJ3VuZGVmaW5lZCcgOiB2LnRvU3RyaW5nKCk7XG59O1xuLy8gQWRkIGEgZm9ybWF0dGVyIGZvciBzdHJpbmdpZnlpbmcgQ0lEc1xuZGVidWcuZm9ybWF0dGVycy5jID0gKHYpID0+IHtcbiAgICByZXR1cm4gdiA9PSBudWxsID8gJ3VuZGVmaW5lZCcgOiB2LnRvU3RyaW5nKCk7XG59O1xuLy8gQWRkIGEgZm9ybWF0dGVyIGZvciBzdHJpbmdpZnlpbmcgRGF0YXN0b3JlIGtleXNcbmRlYnVnLmZvcm1hdHRlcnMuayA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/ICd1bmRlZmluZWQnIDogdi50b1N0cmluZygpO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBsb2dnZXIobmFtZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlYnVnKG5hbWUpLCB7XG4gICAgICAgIGVycm9yOiBkZWJ1ZyhgJHtuYW1lfTplcnJvcmApLFxuICAgICAgICB0cmFjZTogZGVidWcoYCR7bmFtZX06dHJhY2VgKVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgZGVidWcuZGlzYWJsZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgZGVidWcuZW5hYmxlKG5hbWVzcGFjZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZWQobmFtZXNwYWNlcykge1xuICAgIHJldHVybiBkZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnXG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuLi9ieXRlcy5qcydcbi8vIExpbnRlciBjYW4ndCBzZWUgdGhhdCBBUEkgaXMgdXNlZCBpbiB0eXBlcy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW50ZXJmYWNlLmpzJ1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudHMgYm90aCBCYXNlRW5jb2RlciBhbmQgTXVsdGliYXNlRW5jb2RlciBtZWFuaW5nIGl0XG4gKiBjYW4gYmUgdXNlZCB0byBlbmNvZGUgdG8gbXVsdGliYXNlIG9yIGJhc2UgZW5jb2RlIHdpdGhvdXQgbXVsdGliYXNlXG4gKiBwcmVmaXguXG4gKlxuICogQGNsYXNzXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gQmFzZVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQGltcGxlbWVudHMge0FQSS5NdWx0aWJhc2VFbmNvZGVyPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLkJhc2VFbmNvZGVyfVxuICovXG5jbGFzcyBFbmNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZX0gbmFtZVxuICAgKiBAcGFyYW0ge1ByZWZpeH0gcHJlZml4XG4gICAqIEBwYXJhbSB7KGJ5dGVzOlVpbnQ4QXJyYXkpID0+IHN0cmluZ30gYmFzZUVuY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAqIEByZXR1cm5zIHtBUEkuTXVsdGliYXNlPFByZWZpeD59XG4gICAqL1xuICBlbmNvZGUgKGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7dGhpcy5iYXNlRW5jb2RlKGJ5dGVzKX1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqL1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRzIGJvdGggQmFzZURlY29kZXIgYW5kIE11bHRpYmFzZURlY29kZXIgc28gaXQgY291bGQgYmUgdXNlZFxuICogdG8gZGVjb2RlIG11bHRpYmFzZXMgKHdpdGggbWF0Y2hpbmcgcHJlZml4KSBvciBqdXN0IGJhc2UgZGVjb2RlIHN0cmluZ3NcbiAqIHdpdGggY29ycmVzcG9uZGluZyBiYXNlIGVuY29kaW5nLlxuICpcbiAqIEBjbGFzc1xuICogQHRlbXBsYXRlIHtzdHJpbmd9IEJhc2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBpbXBsZW1lbnRzIHtBUEkuTXVsdGliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5VbmliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlRGVjb2Rlcn1cbiAqL1xuY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2V9IG5hbWVcbiAgICogQHBhcmFtIHtQcmVmaXh9IHByZWZpeFxuICAgKiBAcGFyYW0geyh0ZXh0OnN0cmluZykgPT4gVWludDhBcnJheX0gYmFzZURlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocHJlZml4LmNvZGVQb2ludEF0KDApID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJylcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5wcmVmaXhDb2RlUG9pbnQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHByZWZpeC5jb2RlUG9pbnRBdCgwKSlcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGRlY29kZSAodGV4dCkge1xuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0ZXh0LmNvZGVQb2ludEF0KDApICE9PSB0aGlzLnByZWZpeENvZGVQb2ludCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkodGV4dCl9LCAke3RoaXMubmFtZX0gZGVjb2RlciBvbmx5IHN1cHBvcnRzIGlucHV0cyBwcmVmaXhlZCB3aXRoICR7dGhpcy5wcmVmaXh9YClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUodGV4dC5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtzdHJpbmd9IE90aGVyUHJlZml4XG4gICAqIEBwYXJhbSB7QVBJLlVuaWJhc2VEZWNvZGVyPE90aGVyUHJlZml4PnxDb21wb3NlZERlY29kZXI8T3RoZXJQcmVmaXg+fSBkZWNvZGVyXG4gICAqIEByZXR1cm5zIHtDb21wb3NlZERlY29kZXI8UHJlZml4fE90aGVyUHJlZml4Pn1cbiAgICovXG4gIG9yIChkZWNvZGVyKSB7XG4gICAgcmV0dXJuIG9yKHRoaXMsIGRlY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAdHlwZWRlZiB7UmVjb3JkPFByZWZpeCwgQVBJLlVuaWJhc2VEZWNvZGVyPFByZWZpeD4+fSBEZWNvZGVyc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQGltcGxlbWVudHMge0FQSS5NdWx0aWJhc2VEZWNvZGVyPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLkNvbWJvYmFzZURlY29kZXI8UHJlZml4Pn1cbiAqL1xuY2xhc3MgQ29tcG9zZWREZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVjb2RlcnM8UHJlZml4Pn0gZGVjb2RlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVycykge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBkZWNvZGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBPdGhlclByZWZpeFxuICAgKiBAcGFyYW0ge0FQSS5VbmliYXNlRGVjb2RlcjxPdGhlclByZWZpeD58Q29tcG9zZWREZWNvZGVyPE90aGVyUHJlZml4Pn0gZGVjb2RlclxuICAgKiBAcmV0dXJucyB7Q29tcG9zZWREZWNvZGVyPFByZWZpeHxPdGhlclByZWZpeD59XG4gICAqL1xuICBvciAoZGVjb2Rlcikge1xuICAgIHJldHVybiBvcih0aGlzLCBkZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGRlY29kZSAoaW5wdXQpIHtcbiAgICBjb25zdCBwcmVmaXggPSAvKiogQHR5cGUge1ByZWZpeH0gKi8gKGlucHV0WzBdKVxuICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLmRlY29kZXJzW3ByZWZpeF1cbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBSYW5nZUVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShpbnB1dCl9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5kZWNvZGVycyl9IGFyZSBzdXBwb3J0ZWRgKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBMXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICogQHBhcmFtIHtBUEkuVW5pYmFzZURlY29kZXI8TD58QVBJLkNvbWJvYmFzZURlY29kZXI8TD59IGxlZnRcbiAqIEBwYXJhbSB7QVBJLlVuaWJhc2VEZWNvZGVyPFI+fEFQSS5Db21ib2Jhc2VEZWNvZGVyPFI+fSByaWdodFxuICogQHJldHVybnMge0NvbXBvc2VkRGVjb2RlcjxMfFI+fVxuICovXG5leHBvcnQgY29uc3Qgb3IgPSAobGVmdCwgcmlnaHQpID0+IG5ldyBDb21wb3NlZERlY29kZXIoLyoqIEB0eXBlIHtEZWNvZGVyczxMfFI+fSAqLyh7XG4gIC4uLihsZWZ0LmRlY29kZXJzIHx8IHsgWy8qKiBAdHlwZSBBUEkuVW5pYmFzZURlY29kZXI8TD4gKi8obGVmdCkucHJlZml4XTogbGVmdCB9KSxcbiAgLi4uKHJpZ2h0LmRlY29kZXJzIHx8IHsgWy8qKiBAdHlwZSBBUEkuVW5pYmFzZURlY29kZXI8Uj4gKi8ocmlnaHQpLnByZWZpeF06IHJpZ2h0IH0pXG59KSlcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBCYXNlXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAaW1wbGVtZW50cyB7QVBJLk11bHRpYmFzZUNvZGVjPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLk11bHRpYmFzZUVuY29kZXI8UHJlZml4Pn1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuTXVsdGliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlQ29kZWN9XG4gKiBAaW1wbGVtZW50cyB7QVBJLkJhc2VFbmNvZGVyfVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlRGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVjIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZX0gbmFtZVxuICAgKiBAcGFyYW0ge1ByZWZpeH0gcHJlZml4XG4gICAqIEBwYXJhbSB7KGJ5dGVzOlVpbnQ4QXJyYXkpID0+IHN0cmluZ30gYmFzZUVuY29kZVxuICAgKiBAcGFyYW0geyh0ZXh0OnN0cmluZykgPT4gVWludDhBcnJheX0gYmFzZURlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSwgYmFzZURlY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGVcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlXG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlKVxuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gICAqL1xuICBlbmNvZGUgKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAqL1xuICBkZWNvZGUgKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5kZWNvZGUoaW5wdXQpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gQmFzZVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QmFzZX0gb3B0aW9ucy5uYW1lXG4gKiBAcGFyYW0ge1ByZWZpeH0gb3B0aW9ucy5wcmVmaXhcbiAqIEBwYXJhbSB7KGJ5dGVzOlVpbnQ4QXJyYXkpID0+IHN0cmluZ30gb3B0aW9ucy5lbmNvZGVcbiAqIEBwYXJhbSB7KGlucHV0OnN0cmluZykgPT4gVWludDhBcnJheX0gb3B0aW9ucy5kZWNvZGVcbiAqIEByZXR1cm5zIHtDb2RlYzxCYXNlLCBQcmVmaXg+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9ICh7IG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUgfSkgPT5cbiAgbmV3IENvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEJhc2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jhc2V9IG9wdGlvbnMubmFtZVxuICogQHBhcmFtIHtQcmVmaXh9IG9wdGlvbnMucHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hbHBoYWJldFxuICogQHJldHVybnMge0NvZGVjPEJhc2UsIFByZWZpeD59XG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlWCA9ICh7IHByZWZpeCwgbmFtZSwgYWxwaGFiZXQgfSkgPT4ge1xuICBjb25zdCB7IGVuY29kZSwgZGVjb2RlIH0gPSBiYXNleChhbHBoYWJldCwgbmFtZSlcbiAgcmV0dXJuIGZyb20oe1xuICAgIHByZWZpeCxcbiAgICBuYW1lLFxuICAgIGVuY29kZSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqL1xuICAgIGRlY29kZTogdGV4dCA9PiBjb2VyY2UoZGVjb2RlKHRleHQpKVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICAvLyBCdWlsZCB0aGUgY2hhcmFjdGVyIGxvb2t1cCB0YWJsZTpcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSAqL1xuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm9uLSR7bmFtZX0gY2hhcmFjdGVyYClcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJGQzQ2NDggRmFjdG9yeVxuICpcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBCYXNlXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCYXNlfSBvcHRpb25zLm5hbWVcbiAqIEBwYXJhbSB7UHJlZml4fSBvcHRpb25zLnByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmJpdHNQZXJDaGFyXG4gKi9cbmV4cG9ydCBjb25zdCByZmM0NjQ4ID0gKHsgbmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXQgfSkgPT4ge1xuICByZXR1cm4gZnJvbSh7XG4gICAgcHJlZml4LFxuICAgIG5hbWUsXG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH0sXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyLCBuYW1lKVxuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlMzIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnYicsXG4gIG5hbWU6ICdiYXNlMzInLFxuICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJ1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdCJyxcbiAgbmFtZTogJ2Jhc2UzMnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMycGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2MnLFxuICBuYW1lOiAnYmFzZTMycGFkJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMnBhZHVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ0MnLFxuICBuYW1lOiAnYmFzZTMycGFkdXBwZXInLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3YnLFxuICBuYW1lOiAnYmFzZTMyaGV4JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVicsXG4gIG5hbWU6ICdiYXNlMzJoZXh1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMmhleHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd0JyxcbiAgbmFtZTogJ2Jhc2UzMmhleHBhZCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhwYWR1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdUJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMnogPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnaCcsXG4gIG5hbWU6ICdiYXNlMzJ6JyxcbiAgYWxwaGFiZXQ6ICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuIiwiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlNThidGMgPSBiYXNlWCh7XG4gIG5hbWU6ICdiYXNlNThidGMnLFxuICBwcmVmaXg6ICd6JyxcbiAgYWxwaGFiZXQ6ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xufSlcblxuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGZsaWNrcicsXG4gIHByZWZpeDogJ1onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXG59KVxuIiwiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlNjQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnbScsXG4gIG5hbWU6ICdiYXNlNjQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLFxuICBiaXRzUGVyQ2hhcjogNlxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2U2NHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdNJyxcbiAgbmFtZTogJ2Jhc2U2NHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd1JyxcbiAgbmFtZTogJ2Jhc2U2NHVybCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycsXG4gIGJpdHNQZXJDaGFyOiA2XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTY0dXJscGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ1UnLFxuICBuYW1lOiAnYmFzZTY0dXJscGFkJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPScsXG4gIGJpdHNQZXJDaGFyOiA2XG59KVxuIiwiLy8gdGhpcyBpcyBkdW1teSBtb2R1bGUgb3ZlcmxheWVkIGJ5IGludGVyZmFjZS50c1xuIiwiY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheSgwKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZFxuICovXG5jb25zdCB0b0hleCA9IGQgPT4gZC5yZWR1Y2UoKGhleCwgYnl0ZSkgPT4gaGV4ICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICovXG5jb25zdCBmcm9tSGV4ID0gaGV4ID0+IHtcbiAgY29uc3QgaGV4ZXMgPSBoZXgubWF0Y2goLy4uL2cpXG4gIHJldHVybiBoZXhlcyA/IG5ldyBVaW50OEFycmF5KGhleGVzLm1hcChiID0+IHBhcnNlSW50KGIsIDE2KSkpIDogZW1wdHlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJiXG4gKi9cbmNvbnN0IGVxdWFscyA9IChhYSwgYmIpID0+IHtcbiAgaWYgKGFhID09PSBiYikgcmV0dXJuIHRydWVcbiAgaWYgKGFhLmJ5dGVMZW5ndGggIT09IGJiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBhYS5ieXRlTGVuZ3RoOyBpaSsrKSB7XG4gICAgaWYgKGFhW2lpXSAhPT0gYmJbaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl9IG9cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBjb2VyY2UgPSBvID0+IHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSByZXR1cm4gb1xuICBpZiAobyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobylcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvLmJ1ZmZlciwgby5ieXRlT2Zmc2V0LCBvLmJ5dGVMZW5ndGgpXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvXG4gKiBAcmV0dXJucyB7byBpcyBBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9XG4gKi9cbmNvbnN0IGlzQmluYXJ5ID0gbyA9PlxuICBvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG8pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGZyb21TdHJpbmcgPSBzdHIgPT4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUoc3RyKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgdG9TdHJpbmcgPSBiID0+IChuZXcgVGV4dERlY29kZXIoKSkuZGVjb2RlKGIpXG5cbmV4cG9ydCB7IGVxdWFscywgY29lcmNlLCBpc0JpbmFyeSwgZnJvbUhleCwgdG9IZXgsIGZyb21TdHJpbmcsIHRvU3RyaW5nLCBlbXB0eSB9XG4iLCIvLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVULCBuYW1lKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpO1xuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaTtcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aDtcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKTtcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KTsgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSk7IC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIDsgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5JykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB2YXIgcGJlZ2luID0gMDtcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKys7XG4gICAgICB6ZXJvZXMrKztcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDA7XG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDA7XG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrKztcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKTtcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSk7IH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHNwYWNlcy5cbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykgeyByZXR1cm4gfVxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDA7IC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMDtcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBTa2lwIHRyYWlsaW5nIHNwYWNlcy5cbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykgeyByZXR1cm4gfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi0ke25hbWV9IGNoYXJhY3RlcmApXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG52YXIgc3JjID0gYmFzZTtcblxudmFyIF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVggPSBzcmM7XG5cbmV4cG9ydCBkZWZhdWx0IF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVg7XG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGJhc2VzIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jhc2ljcyc7XG5pbXBvcnQgeyBiYXNlNThidGMgfSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzZXMvYmFzZTU4JztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2RpZ2VzdCc7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvaWRlbnRpdHknO1xuaW1wb3J0IHsgZXF1YWxzIGFzIHVpbnQ4QXJyYXlFcXVhbHMgfSBmcm9tICd1aW50OGFycmF5cy9lcXVhbHMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJztcbmltcG9ydCBlcnJjb2RlIGZyb20gJ2Vyci1jb2RlJztcbmltcG9ydCB7IHN5bWJvbCB9IGZyb20gJ0BsaWJwMnAvaW50ZXJmYWNlLXBlZXItaWQnO1xuY29uc3QgYmFzZURlY29kZXIgPSBPYmplY3RcbiAgICAudmFsdWVzKGJhc2VzKVxuICAgIC5tYXAoY29kZWMgPT4gY29kZWMuZGVjb2RlcilcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvanMtbXVsdGlmb3JtYXRzL2lzc3Vlcy8xNDFcbiAgICAucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYy5vcihjdXJyKSwgYmFzZXMuaWRlbnRpdHkuZGVjb2Rlcik7XG4vLyB0aGVzZSB2YWx1ZXMgYXJlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWNvZGVjL2Jsb2IvbWFzdGVyL3RhYmxlLmNzdlxuY29uc3QgTElCUDJQX0tFWV9DT0RFID0gMHg3MjtcbmNvbnN0IE1BUlNIQUxMRURfRUQyMjU1MTlfUFVCTElDX0tFWV9MRU5HVEggPSAzNjtcbmNvbnN0IE1BUlNIQUxMRURfU0VDUDI1NksxX1BVQkxJQ19LRVlfTEVOR1RIID0gMzc7XG5jbGFzcyBQZWVySWRJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IGluaXQudHlwZTtcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSBpbml0Lm11bHRpaGFzaDtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gaW5pdC5wcml2YXRlS2V5O1xuICAgICAgICAvLyBtYXJrIHN0cmluZyBjYWNoZSBhcyBub24tZW51bWVyYWJsZVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0cmluZycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIGBQZWVySWQoJHt0aGlzLnRvU3RyaW5nKCl9KWA7XG4gICAgfVxuICAgIGdldCBbc3ltYm9sXSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5zdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmcgPSBiYXNlNThidGMuZW5jb2RlKHRoaXMubXVsdGloYXNoLmJ5dGVzKS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIC8vIHJldHVybiBzZWxmLWRlc2NyaWJpbmcgU3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gaW4gZGVmYXVsdCBmb3JtYXQgZnJvbSBSRkMgMDAwMTogaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9zcGVjcy9wdWxsLzIwOVxuICAgIHRvQ0lEKCkge1xuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYxKExJQlAyUF9LRVlfQ09ERSwgdGhpcy5tdWx0aWhhc2gpO1xuICAgIH1cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aWhhc2guYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgTXVsdGlhZGRyIGFzIGEgSlNPTiBlbmNvZGVkIG9iamVjdFxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBlcXVhbGl0eSBvZiBgdGhpc2AgcGVlciBhZ2FpbnN0IGEgZ2l2ZW4gUGVlcklkXG4gICAgICovXG4gICAgZXF1YWxzKGlkKSB7XG4gICAgICAgIGlmIChpZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5RXF1YWxzKHRoaXMubXVsdGloYXNoLmJ5dGVzLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBlZXJJZEZyb21TdHJpbmcoaWQpLmVxdWFscyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZD8ubXVsdGloYXNoPy5ieXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdWludDhBcnJheUVxdWFscyh0aGlzLm11bHRpaGFzaC5ieXRlcywgaWQubXVsdGloYXNoLmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHZhbGlkIElkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBSU0FQZWVySWRJbXBsIGV4dGVuZHMgUGVlcklkSW1wbCB7XG4gICAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgICAgICBzdXBlcih7IC4uLmluaXQsIHR5cGU6ICdSU0EnIH0pO1xuICAgICAgICB0aGlzLnR5cGUgPSAnUlNBJztcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBpbml0LnB1YmxpY0tleTtcbiAgICB9XG59XG5jbGFzcyBFZDI1NTE5UGVlcklkSW1wbCBleHRlbmRzIFBlZXJJZEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICAgICAgc3VwZXIoeyAuLi5pbml0LCB0eXBlOiAnRWQyNTUxOScgfSk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdFZDI1NTE5JztcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBpbml0Lm11bHRpaGFzaC5kaWdlc3Q7XG4gICAgfVxufVxuY2xhc3MgU2VjcDI1NmsxUGVlcklkSW1wbCBleHRlbmRzIFBlZXJJZEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICAgICAgc3VwZXIoeyAuLi5pbml0LCB0eXBlOiAnc2VjcDI1NmsxJyB9KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3NlY3AyNTZrMSc7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gaW5pdC5tdWx0aWhhc2guZGlnZXN0O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQZWVySWQoaW5pdCkge1xuICAgIHJldHVybiBuZXcgUGVlcklkSW1wbChpbml0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZWVySWRGcm9tUGVlcklkKG90aGVyKSB7XG4gICAgaWYgKG90aGVyLnR5cGUgPT09ICdSU0EnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUlNBUGVlcklkSW1wbChvdGhlcik7XG4gICAgfVxuICAgIGlmIChvdGhlci50eXBlID09PSAnRWQyNTUxOScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZDI1NTE5UGVlcklkSW1wbChvdGhlcik7XG4gICAgfVxuICAgIGlmIChvdGhlci50eXBlID09PSAnc2VjcDI1NmsxJykge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3AyNTZrMVBlZXJJZEltcGwob3RoZXIpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcignTm90IGEgUGVlcklkJyksICdFUlJfSU5WQUxJRF9QQVJBTUVURVJTJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVlcklkRnJvbVN0cmluZyhzdHIsIGRlY29kZXIpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciA/PyBiYXNlRGVjb2RlcjtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJzEnIHx8IHN0ci5jaGFyQXQoMCkgPT09ICdRJykge1xuICAgICAgICAvLyBpZGVudGl0eSBoYXNoIGVkMjU1MTkvc2VjcDI1NmsxIGtleSBvciBzaGEyLTI1NiBoYXNoIG9mXG4gICAgICAgIC8vIHJzYSBwdWJsaWMga2V5IC0gYmFzZTU4YnRjIGVuY29kZWQgZWl0aGVyIHdheVxuICAgICAgICBjb25zdCBtdWx0aWhhc2ggPSBEaWdlc3QuZGVjb2RlKGJhc2U1OGJ0Yy5kZWNvZGUoYHoke3N0cn1gKSk7XG4gICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnMTJEJykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWQyNTUxOVBlZXJJZEltcGwoeyBtdWx0aWhhc2ggfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyLnN0YXJ0c1dpdGgoJzE2VScpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlY3AyNTZrMVBlZXJJZEltcGwoeyBtdWx0aWhhc2ggfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJTQVBlZXJJZEltcGwoeyBtdWx0aWhhc2ggfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBlZXJJZEZyb21CeXRlcyhiYXNlRGVjb2Rlci5kZWNvZGUoc3RyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVlcklkRnJvbUJ5dGVzKGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG11bHRpaGFzaCA9IERpZ2VzdC5kZWNvZGUoYnVmKTtcbiAgICAgICAgaWYgKG11bHRpaGFzaC5jb2RlID09PSBpZGVudGl0eS5jb2RlKSB7XG4gICAgICAgICAgICBpZiAobXVsdGloYXNoLmRpZ2VzdC5sZW5ndGggPT09IE1BUlNIQUxMRURfRUQyMjU1MTlfUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQZWVySWRJbXBsKHsgbXVsdGloYXNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGloYXNoLmRpZ2VzdC5sZW5ndGggPT09IE1BUlNIQUxMRURfU0VDUDI1NksxX1BVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWNwMjU2azFQZWVySWRJbXBsKHsgbXVsdGloYXNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aWhhc2guY29kZSA9PT0gc2hhMjU2LmNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUlNBUGVlcklkSW1wbCh7IG11bHRpaGFzaCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBwZWVySWRGcm9tQ0lEKENJRC5kZWNvZGUoYnVmKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgUGVlcklEIENJRCBpcyBpbnZhbGlkJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVlcklkRnJvbUNJRChjaWQpIHtcbiAgICBpZiAoY2lkID09IG51bGwgfHwgY2lkLm11bHRpaGFzaCA9PSBudWxsIHx8IGNpZC52ZXJzaW9uID09IG51bGwgfHwgKGNpZC52ZXJzaW9uID09PSAxICYmIGNpZC5jb2RlICE9PSBMSUJQMlBfS0VZX0NPREUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgUGVlcklEIENJRCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIGNvbnN0IG11bHRpaGFzaCA9IGNpZC5tdWx0aWhhc2g7XG4gICAgaWYgKG11bHRpaGFzaC5jb2RlID09PSBzaGEyNTYuY29kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJTQVBlZXJJZEltcGwoeyBtdWx0aWhhc2g6IGNpZC5tdWx0aWhhc2ggfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG11bHRpaGFzaC5jb2RlID09PSBpZGVudGl0eS5jb2RlKSB7XG4gICAgICAgIGlmIChtdWx0aWhhc2guZGlnZXN0Lmxlbmd0aCA9PT0gTUFSU0hBTExFRF9FRDIyNTUxOV9QVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFZDI1NTE5UGVlcklkSW1wbCh7IG11bHRpaGFzaDogY2lkLm11bHRpaGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdWx0aWhhc2guZGlnZXN0Lmxlbmd0aCA9PT0gTUFSU0hBTExFRF9TRUNQMjU2SzFfUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VjcDI1NmsxUGVlcklkSW1wbCh7IG11bHRpaGFzaDogY2lkLm11bHRpaGFzaCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIFBlZXJJRCBDSUQgaXMgaW52YWxpZCcpO1xufVxuLyoqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gQSBtYXJzaGFsbGVkIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSBwcml2YXRlS2V5IC0gQSBtYXJzaGFsbGVkIHByaXZhdGUga2V5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZWVySWRGcm9tS2V5cyhwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gTUFSU0hBTExFRF9FRDIyNTUxOV9QVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQZWVySWRJbXBsKHsgbXVsdGloYXNoOiBEaWdlc3QuY3JlYXRlKGlkZW50aXR5LmNvZGUsIHB1YmxpY0tleSksIHByaXZhdGVLZXkgfSk7XG4gICAgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSBNQVJTSEFMTEVEX1NFQ1AyNTZLMV9QVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3AyNTZrMVBlZXJJZEltcGwoeyBtdWx0aWhhc2g6IERpZ2VzdC5jcmVhdGUoaWRlbnRpdHkuY29kZSwgcHVibGljS2V5KSwgcHJpdmF0ZUtleSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSU0FQZWVySWRJbXBsKHsgbXVsdGloYXNoOiBhd2FpdCBzaGEyNTYuZGlnZXN0KHB1YmxpY0tleSksIHB1YmxpY0tleSwgcHJpdmF0ZUtleSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBiYXNleCBmcm9tICcuLi8uLi92ZW5kb3IvYmFzZS14LmpzJ1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnXG4vLyBMaW50ZXIgY2FuJ3Qgc2VlIHRoYXQgQVBJIGlzIHVzZWQgaW4gdHlwZXMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2ludGVyZmFjZS5qcydcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRzIGJvdGggQmFzZUVuY29kZXIgYW5kIE11bHRpYmFzZUVuY29kZXIgbWVhbmluZyBpdFxuICogY2FuIGJlIHVzZWQgdG8gZW5jb2RlIHRvIG11bHRpYmFzZSBvciBiYXNlIGVuY29kZSB3aXRob3V0IG11bHRpYmFzZVxuICogcHJlZml4LlxuICpcbiAqIEBjbGFzc1xuICogQHRlbXBsYXRlIHtzdHJpbmd9IEJhc2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBpbXBsZW1lbnRzIHtBUEkuTXVsdGliYXNlRW5jb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlRW5jb2Rlcn1cbiAqL1xuY2xhc3MgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2V9IG5hbWVcbiAgICogQHBhcmFtIHtQcmVmaXh9IHByZWZpeFxuICAgKiBAcGFyYW0geyhieXRlczpVaW50OEFycmF5KSA9PiBzdHJpbmd9IGJhc2VFbmNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXhcbiAgICB0aGlzLmJhc2VFbmNvZGUgPSBiYXNlRW5jb2RlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgKiBAcmV0dXJucyB7QVBJLk11bHRpYmFzZTxQcmVmaXg+fVxuICAgKi9cbiAgZW5jb2RlIChieXRlcykge1xuICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0ke3RoaXMuYmFzZUVuY29kZShieXRlcyl9YFxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKi9cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50cyBib3RoIEJhc2VEZWNvZGVyIGFuZCBNdWx0aWJhc2VEZWNvZGVyIHNvIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGRlY29kZSBtdWx0aWJhc2VzICh3aXRoIG1hdGNoaW5nIHByZWZpeCkgb3IganVzdCBiYXNlIGRlY29kZSBzdHJpbmdzXG4gKiB3aXRoIGNvcnJlc3BvbmRpbmcgYmFzZSBlbmNvZGluZy5cbiAqXG4gKiBAY2xhc3NcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBCYXNlXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAaW1wbGVtZW50cyB7QVBJLk11bHRpYmFzZURlY29kZXI8UHJlZml4Pn1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuVW5pYmFzZURlY29kZXI8UHJlZml4Pn1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuQmFzZURlY29kZXJ9XG4gKi9cbmNsYXNzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtCYXNlfSBuYW1lXG4gICAqIEBwYXJhbSB7UHJlZml4fSBwcmVmaXhcbiAgICogQHBhcmFtIHsodGV4dDpzdHJpbmcpID0+IFVpbnQ4QXJyYXl9IGJhc2VEZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBwcmVmaXgsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXhcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHByZWZpeC5jb2RlUG9pbnRBdCgwKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJlZml4IGNoYXJhY3RlcicpXG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwcmVmaXguY29kZVBvaW50QXQoMCkpXG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqL1xuICBkZWNvZGUgKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGV4dC5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KHRleHQpfSwgJHt0aGlzLm5hbWV9IGRlY29kZXIgb25seSBzdXBwb3J0cyBpbnB1dHMgcHJlZml4ZWQgd2l0aCAke3RoaXMucHJlZml4fWApXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5iYXNlRGVjb2RlKHRleHQuc2xpY2UodGhpcy5wcmVmaXgubGVuZ3RoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBvbmx5IG11bHRpYmFzZSBkZWNvZGUgc3RyaW5ncycpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBPdGhlclByZWZpeFxuICAgKiBAcGFyYW0ge0FQSS5VbmliYXNlRGVjb2RlcjxPdGhlclByZWZpeD58Q29tcG9zZWREZWNvZGVyPE90aGVyUHJlZml4Pn0gZGVjb2RlclxuICAgKiBAcmV0dXJucyB7Q29tcG9zZWREZWNvZGVyPFByZWZpeHxPdGhlclByZWZpeD59XG4gICAqL1xuICBvciAoZGVjb2Rlcikge1xuICAgIHJldHVybiBvcih0aGlzLCBkZWNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQHR5cGVkZWYge1JlY29yZDxQcmVmaXgsIEFQSS5VbmliYXNlRGVjb2RlcjxQcmVmaXg+Pn0gRGVjb2RlcnNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBpbXBsZW1lbnRzIHtBUEkuTXVsdGliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5Db21ib2Jhc2VEZWNvZGVyPFByZWZpeD59XG4gKi9cbmNsYXNzIENvbXBvc2VkRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlY29kZXJzPFByZWZpeD59IGRlY29kZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2RlcnMpIHtcbiAgICB0aGlzLmRlY29kZXJzID0gZGVjb2RlcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge3N0cmluZ30gT3RoZXJQcmVmaXhcbiAgICogQHBhcmFtIHtBUEkuVW5pYmFzZURlY29kZXI8T3RoZXJQcmVmaXg+fENvbXBvc2VkRGVjb2RlcjxPdGhlclByZWZpeD59IGRlY29kZXJcbiAgICogQHJldHVybnMge0NvbXBvc2VkRGVjb2RlcjxQcmVmaXh8T3RoZXJQcmVmaXg+fVxuICAgKi9cbiAgb3IgKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBkZWNvZGUgKGlucHV0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gLyoqIEB0eXBlIHtQcmVmaXh9ICovIChpbnB1dFswXSlcbiAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5kZWNvZGVyc1twcmVmaXhdXG4gICAgaWYgKGRlY29kZXIpIHtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShpbnB1dClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoaW5wdXQpfSwgb25seSBpbnB1dHMgcHJlZml4ZWQgd2l0aCAke09iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpfSBhcmUgc3VwcG9ydGVkYClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gTFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFJcbiAqIEBwYXJhbSB7QVBJLlVuaWJhc2VEZWNvZGVyPEw+fEFQSS5Db21ib2Jhc2VEZWNvZGVyPEw+fSBsZWZ0XG4gKiBAcGFyYW0ge0FQSS5VbmliYXNlRGVjb2RlcjxSPnxBUEkuQ29tYm9iYXNlRGVjb2RlcjxSPn0gcmlnaHRcbiAqIEByZXR1cm5zIHtDb21wb3NlZERlY29kZXI8THxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG9yID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgQ29tcG9zZWREZWNvZGVyKC8qKiBAdHlwZSB7RGVjb2RlcnM8THxSPn0gKi8oe1xuICAuLi4obGVmdC5kZWNvZGVycyB8fCB7IFsvKiogQHR5cGUgQVBJLlVuaWJhc2VEZWNvZGVyPEw+ICovKGxlZnQpLnByZWZpeF06IGxlZnQgfSksXG4gIC4uLihyaWdodC5kZWNvZGVycyB8fCB7IFsvKiogQHR5cGUgQVBJLlVuaWJhc2VEZWNvZGVyPFI+ICovKHJpZ2h0KS5wcmVmaXhdOiByaWdodCB9KVxufSkpXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gQmFzZVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQGltcGxlbWVudHMge0FQSS5NdWx0aWJhc2VDb2RlYzxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5NdWx0aWJhc2VFbmNvZGVyPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLk11bHRpYmFzZURlY29kZXI8UHJlZml4Pn1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuQmFzZUNvZGVjfVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlRW5jb2Rlcn1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuQmFzZURlY29kZXJ9XG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlYyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2V9IG5hbWVcbiAgICogQHBhcmFtIHtQcmVmaXh9IHByZWZpeFxuICAgKiBAcGFyYW0geyhieXRlczpVaW50OEFycmF5KSA9PiBzdHJpbmd9IGJhc2VFbmNvZGVcbiAgICogQHBhcmFtIHsodGV4dDpzdHJpbmcpID0+IFVpbnQ4QXJyYXl9IGJhc2VEZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXhcbiAgICB0aGlzLmJhc2VFbmNvZGUgPSBiYXNlRW5jb2RlXG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZVxuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSlcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgRGVjb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VEZWNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICAgKi9cbiAgZW5jb2RlIChpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZXIuZW5jb2RlKGlucHV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKi9cbiAgZGVjb2RlIChpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEJhc2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jhc2V9IG9wdGlvbnMubmFtZVxuICogQHBhcmFtIHtQcmVmaXh9IG9wdGlvbnMucHJlZml4XG4gKiBAcGFyYW0geyhieXRlczpVaW50OEFycmF5KSA9PiBzdHJpbmd9IG9wdGlvbnMuZW5jb2RlXG4gKiBAcGFyYW0geyhpbnB1dDpzdHJpbmcpID0+IFVpbnQ4QXJyYXl9IG9wdGlvbnMuZGVjb2RlXG4gKiBAcmV0dXJucyB7Q29kZWM8QmFzZSwgUHJlZml4Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoeyBuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlIH0pID0+XG4gIG5ldyBDb2RlYyhuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBCYXNlXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCYXNlfSBvcHRpb25zLm5hbWVcbiAqIEBwYXJhbSB7UHJlZml4fSBvcHRpb25zLnByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWxwaGFiZXRcbiAqIEByZXR1cm5zIHtDb2RlYzxCYXNlLCBQcmVmaXg+fVxuICovXG5leHBvcnQgY29uc3QgYmFzZVggPSAoeyBwcmVmaXgsIG5hbWUsIGFscGhhYmV0IH0pID0+IHtcbiAgY29uc3QgeyBlbmNvZGUsIGRlY29kZSB9ID0gYmFzZXgoYWxwaGFiZXQsIG5hbWUpXG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKi9cbiAgICBkZWNvZGU6IHRleHQgPT4gY29lcmNlKGRlY29kZSh0ZXh0KSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIsIG5hbWUpID0+IHtcbiAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgY29kZXMgPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaVxuICB9XG5cbiAgLy8gQ291bnQgdGhlIHBhZGRpbmcgYnl0ZXM6XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoXG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kXG4gIH1cblxuICAvLyBBbGxvY2F0ZSB0aGUgb3V0cHV0OlxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApXG5cbiAgLy8gUGFyc2UgdGhlIGRhdGE6XG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBsZXQgd3JpdHRlbiA9IDAgLy8gTmV4dCBieXRlIHRvIHdyaXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAvLyBSZWFkIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RyaW5nOlxuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE5vbi0ke25hbWV9IGNoYXJhY3RlcmApXG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXRzIHRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZVxuICAgIGJpdHMgKz0gYml0c1BlckNoYXJcblxuICAgIC8vIFdyaXRlIG91dCBzb21lIGJpdHMgaWYgdGhlIGJ1ZmZlciBoYXMgYSBieXRlJ3Mgd29ydGg6XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDB4ZmYgJiAoYnVmZmVyID4+IGJpdHMpXG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBqdXN0IGVub3VnaCBiaXRzOlxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAweGZmICYgKGJ1ZmZlciA8PCAoOCAtIGJpdHMpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxXG4gIGxldCBvdXQgPSAnJ1xuXG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBTbHVycCBkYXRhIGludG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgLy8gV3JpdGUgb3V0IGFzIG11Y2ggYXMgd2UgY2FuOlxuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXJcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA+PiBiaXRzKV1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJ0aWFsIGNoYXJhY3RlcjpcbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPDwgKGJpdHNQZXJDaGFyIC0gYml0cykpXVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmcgY2hhcmFjdGVycyB1bnRpbCB3ZSBoaXQgYSBieXRlIGJvdW5kYXJ5OlxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykge1xuICAgICAgb3V0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSRkM0NjQ4IEZhY3RvcnlcbiAqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gQmFzZVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QmFzZX0gb3B0aW9ucy5uYW1lXG4gKiBAcGFyYW0ge1ByZWZpeH0gb3B0aW9ucy5wcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iaXRzUGVyQ2hhclxuICovXG5leHBvcnQgY29uc3QgcmZjNDY0OCA9ICh7IG5hbWUsIHByZWZpeCwgYml0c1BlckNoYXIsIGFscGhhYmV0IH0pID0+IHtcbiAgcmV0dXJuIGZyb20oe1xuICAgIHByZWZpeCxcbiAgICBuYW1lLFxuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSlcbiAgICB9XG4gIH0pXG59XG4iLCJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2UxMCA9IGJhc2VYKHtcbiAgcHJlZml4OiAnOScsXG4gIG5hbWU6ICdiYXNlMTAnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODknXG59KVxuIiwiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnZicsXG4gIG5hbWU6ICdiYXNlMTYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICBiaXRzUGVyQ2hhcjogNFxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UxNnVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ0YnLFxuICBuYW1lOiAnYmFzZTE2dXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUYnLFxuICBiaXRzUGVyQ2hhcjogNFxufSlcbiIsIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJ1xuXG5leHBvcnQgY29uc3QgYmFzZTIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnMCcsXG4gIG5hbWU6ICdiYXNlMicsXG4gIGFscGhhYmV0OiAnMDEnLFxuICBiaXRzUGVyQ2hhcjogMVxufSlcbiIsImltcG9ydCB7IGZyb20gfSBmcm9tICcuL2Jhc2UuanMnXG5cbmNvbnN0IGFscGhhYmV0ID0gQXJyYXkuZnJvbSgn8J+agPCfqpDimITwn5uw8J+MjPCfjJHwn4yS8J+Mk/CfjJTwn4yV8J+MlvCfjJfwn4yY8J+MjfCfjI/wn4yO8J+QieKYgPCfkrvwn5al8J+SvvCfkr/wn5iC4p2k8J+YjfCfpKPwn5iK8J+Zj/CfkpXwn5it8J+YmPCfkY3wn5iF8J+Rj/CfmIHwn5Sl8J+lsPCfkpTwn5KW8J+SmfCfmKLwn6SU8J+YhvCfmYTwn5Kq8J+YieKYuvCfkYzwn6SX8J+SnPCfmJTwn5iO8J+Yh/CfjLnwn6Sm8J+OifCfkp7inIzinKjwn6S38J+YsfCfmIzwn4y48J+ZjPCfmIvwn5KX8J+SmvCfmI/wn5Kb8J+ZgvCfkpPwn6Sp8J+YhPCfmIDwn5ak8J+Yg/Cfkq/wn5mI8J+Rh/Cfjrbwn5iS8J+kreKdo/CfmJzwn5KL8J+RgPCfmKrwn5iR8J+SpfCfmYvwn5ie8J+YqfCfmKHwn6Sq8J+RivCfpbPwn5il8J+kpPCfkYnwn5KD8J+Ys+Kci/CfmJrwn5id8J+YtPCfjJ/wn5is8J+Zg/CfjYDwn4y38J+Yu/CfmJPirZDinIXwn6W68J+MiPCfmIjwn6SY8J+SpuKclPCfmKPwn4+D8J+SkOKYufCfjorwn5KY8J+YoOKYnfCfmJXwn4y68J+OgvCfjLvwn5iQ8J+WlfCfkp3wn5mK8J+YufCfl6Pwn5Kr8J+SgPCfkZHwn4618J+knvCfmJvwn5S08J+YpPCfjLzwn5ir4pq98J+kmeKYlfCfj4bwn6Sr8J+RiPCfmK7wn5mG8J+Nu/CfjYPwn5C28J+SgfCfmLLwn4y/8J+nofCfjoHimqHwn4ye8J+OiOKdjOKcivCfkYvwn5iw8J+kqPCfmLbwn6Sd8J+atvCfkrDwn42T8J+SovCfpJ/wn5mB8J+aqPCfkqjwn6Ss4pyI8J+OgPCfjbrwn6ST8J+YmfCfkp/wn4yx8J+YlvCfkbbwn6W04pa24p6h4p2T8J+SjvCfkrjirIfwn5io8J+MmvCfpovwn5i38J+VuuKaoPCfmYXwn5if8J+YtfCfkY7wn6Sy8J+koPCfpKfwn5OM8J+UtfCfkoXwn6eQ8J+QvvCfjZLwn5iX8J+kkfCfjIrwn6Sv8J+Qt+KYjvCfkqfwn5iv8J+ShvCfkYbwn46k8J+Zh/CfjZHinYTwn4y08J+So/CfkLjwn5KM8J+TjfCfpYDwn6Si8J+RhfCfkqHwn5Kp8J+RkPCfk7jwn5G78J+kkPCfpK7wn4688J+ltfCfmqnwn42O8J+NivCfkbzwn5KN8J+To/CfpYInKVxuY29uc3QgYWxwaGFiZXRCeXRlc1RvQ2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAoYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7IHBbaV0gPSBjOyByZXR1cm4gcCB9LCAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyhbXSkpKVxuY29uc3QgYWxwaGFiZXRDaGFyc1RvQnl0ZXMgPSAvKiogQHR5cGUge251bWJlcltdfSAqLyAoYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7IHBbLyoqIEB0eXBlIHtudW1iZXJ9ICovIChjLmNvZGVQb2ludEF0KDApKV0gPSBpOyByZXR1cm4gcCB9LCAvKiogQHR5cGUge251bWJlcltdfSAqLyhbXSkpKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChkYXRhKSB7XG4gIHJldHVybiBkYXRhLnJlZHVjZSgocCwgYykgPT4ge1xuICAgIHAgKz0gYWxwaGFiZXRCeXRlc1RvQ2hhcnNbY11cbiAgICByZXR1cm4gcFxuICB9LCAnJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChzdHIpIHtcbiAgY29uc3QgYnl0cyA9IFtdXG4gIGZvciAoY29uc3QgY2hhciBvZiBzdHIpIHtcbiAgICBjb25zdCBieXQgPSBhbHBoYWJldENoYXJzVG9CeXRlc1svKiogQHR5cGUge251bWJlcn0gKi8gKGNoYXIuY29kZVBvaW50QXQoMCkpXVxuICAgIGlmIChieXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24tYmFzZTI1NmVtb2ppIGNoYXJhY3RlcjogJHtjaGFyfWApXG4gICAgfVxuICAgIGJ5dHMucHVzaChieXQpXG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dHMpXG59XG5cbmV4cG9ydCBjb25zdCBiYXNlMjU2ZW1vamkgPSBmcm9tKHtcbiAgcHJlZml4OiAn8J+agCcsXG4gIG5hbWU6ICdiYXNlMjU2ZW1vamknLFxuICBlbmNvZGUsXG4gIGRlY29kZVxufSlcbiIsImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlMzIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnYicsXG4gIG5hbWU6ICdiYXNlMzInLFxuICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJ1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdCJyxcbiAgbmFtZTogJ2Jhc2UzMnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMycGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2MnLFxuICBuYW1lOiAnYmFzZTMycGFkJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMnBhZHVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ0MnLFxuICBuYW1lOiAnYmFzZTMycGFkdXBwZXInLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3YnLFxuICBuYW1lOiAnYmFzZTMyaGV4JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVicsXG4gIG5hbWU6ICdiYXNlMzJoZXh1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMmhleHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd0JyxcbiAgbmFtZTogJ2Jhc2UzMmhleHBhZCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhwYWR1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdUJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMnogPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnaCcsXG4gIG5hbWU6ICdiYXNlMzJ6JyxcbiAgYWxwaGFiZXQ6ICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuIiwiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlMzYgPSBiYXNlWCh7XG4gIHByZWZpeDogJ2snLFxuICBuYW1lOiAnYmFzZTM2JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTM2dXBwZXIgPSBiYXNlWCh7XG4gIHByZWZpeDogJ0snLFxuICBuYW1lOiAnYmFzZTM2dXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWidcbn0pXG4iLCJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2U1OGJ0YyA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGJ0YycsXG4gIHByZWZpeDogJ3onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gYmFzZVgoe1xuICBuYW1lOiAnYmFzZTU4ZmxpY2tyJyxcbiAgcHJlZml4OiAnWicsXG4gIGFscGhhYmV0OiAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWidcbn0pXG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdtJyxcbiAgbmFtZTogJ2Jhc2U2NCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG4gIGJpdHNQZXJDaGFyOiA2XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTY0cGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ00nLFxuICBuYW1lOiAnYmFzZTY0cGFkJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPScsXG4gIGJpdHNQZXJDaGFyOiA2XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3UnLFxuICBuYW1lOiAnYmFzZTY0dXJsJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVScsXG4gIG5hbWU6ICdiYXNlNjR1cmxwYWQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89JyxcbiAgYml0c1BlckNoYXI6IDZcbn0pXG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2U4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJzcnLFxuICBuYW1lOiAnYmFzZTgnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDNcbn0pXG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vYmFzZS5qcydcbmltcG9ydCB7IGZyb21TdHJpbmcsIHRvU3RyaW5nIH0gZnJvbSAnLi4vYnl0ZXMuanMnXG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IGZyb20oe1xuICBwcmVmaXg6ICdcXHgwMCcsXG4gIG5hbWU6ICdpZGVudGl0eScsXG4gIGVuY29kZTogKGJ1ZikgPT4gdG9TdHJpbmcoYnVmKSxcbiAgZGVjb2RlOiAoc3RyKSA9PiBmcm9tU3RyaW5nKHN0cilcbn0pXG4iLCIvLyB0aGlzIGlzIGR1bW15IG1vZHVsZSBvdmVybGF5ZWQgYnkgaW50ZXJmYWNlLnRzXG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0ICogYXMgaWRlbnRpdHlCYXNlIGZyb20gJy4vYmFzZXMvaWRlbnRpdHkuanMnXG5pbXBvcnQgKiBhcyBiYXNlMiBmcm9tICcuL2Jhc2VzL2Jhc2UyLmpzJ1xuaW1wb3J0ICogYXMgYmFzZTggZnJvbSAnLi9iYXNlcy9iYXNlOC5qcydcbmltcG9ydCAqIGFzIGJhc2UxMCBmcm9tICcuL2Jhc2VzL2Jhc2UxMC5qcydcbmltcG9ydCAqIGFzIGJhc2UxNiBmcm9tICcuL2Jhc2VzL2Jhc2UxNi5qcydcbmltcG9ydCAqIGFzIGJhc2UzMiBmcm9tICcuL2Jhc2VzL2Jhc2UzMi5qcydcbmltcG9ydCAqIGFzIGJhc2UzNiBmcm9tICcuL2Jhc2VzL2Jhc2UzNi5qcydcbmltcG9ydCAqIGFzIGJhc2U1OCBmcm9tICcuL2Jhc2VzL2Jhc2U1OC5qcydcbmltcG9ydCAqIGFzIGJhc2U2NCBmcm9tICcuL2Jhc2VzL2Jhc2U2NC5qcydcbmltcG9ydCAqIGFzIGJhc2UyNTZlbW9qaSBmcm9tICcuL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcydcbmltcG9ydCAqIGFzIHNoYTIgZnJvbSAnLi9oYXNoZXMvc2hhMi5qcydcbmltcG9ydCAqIGFzIGlkZW50aXR5IGZyb20gJy4vaGFzaGVzL2lkZW50aXR5LmpzJ1xuXG5pbXBvcnQgKiBhcyByYXcgZnJvbSAnLi9jb2RlY3MvcmF3LmpzJ1xuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL2NvZGVjcy9qc29uLmpzJ1xuXG5pbXBvcnQgeyBDSUQsIGhhc2hlciwgZGlnZXN0LCB2YXJpbnQsIGJ5dGVzIH0gZnJvbSAnLi9pbmRleC5qcydcblxuY29uc3QgYmFzZXMgPSB7IC4uLmlkZW50aXR5QmFzZSwgLi4uYmFzZTIsIC4uLmJhc2U4LCAuLi5iYXNlMTAsIC4uLmJhc2UxNiwgLi4uYmFzZTMyLCAuLi5iYXNlMzYsIC4uLmJhc2U1OCwgLi4uYmFzZTY0LCAuLi5iYXNlMjU2ZW1vamkgfVxuY29uc3QgaGFzaGVzID0geyAuLi5zaGEyLCAuLi5pZGVudGl0eSB9XG5jb25zdCBjb2RlY3MgPSB7IHJhdywganNvbiB9XG5cbmV4cG9ydCB7IENJRCwgaGFzaGVyLCBkaWdlc3QsIHZhcmludCwgYnl0ZXMsIGhhc2hlcywgYmFzZXMsIGNvZGVjcyB9XG4iLCJjb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KDApXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkXG4gKi9cbmNvbnN0IHRvSGV4ID0gZCA9PiBkLnJlZHVjZSgoaGV4LCBieXRlKSA9PiBoZXggKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKi9cbmNvbnN0IGZyb21IZXggPSBoZXggPT4ge1xuICBjb25zdCBoZXhlcyA9IGhleC5tYXRjaCgvLi4vZylcbiAgcmV0dXJuIGhleGVzID8gbmV3IFVpbnQ4QXJyYXkoaGV4ZXMubWFwKGIgPT4gcGFyc2VJbnQoYiwgMTYpKSkgOiBlbXB0eVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYWFcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYmJcbiAqL1xuY29uc3QgZXF1YWxzID0gKGFhLCBiYikgPT4ge1xuICBpZiAoYWEgPT09IGJiKSByZXR1cm4gdHJ1ZVxuICBpZiAoYWEuYnl0ZUxlbmd0aCAhPT0gYmIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFhLmJ5dGVMZW5ndGg7IGlpKyspIHtcbiAgICBpZiAoYWFbaWldICE9PSBiYltpaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ8VWludDhBcnJheX0gb1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGNvZXJjZSA9IG8gPT4ge1xuICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgby5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpIHJldHVybiBvXG4gIGlmIChvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHJldHVybiBuZXcgVWludDhBcnJheShvKVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG8pKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLCBvLmJ5dGVPZmZzZXQsIG8uYnl0ZUxlbmd0aClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9cbiAqIEByZXR1cm5zIHtvIGlzIEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld31cbiAqL1xuY29uc3QgaXNCaW5hcnkgPSBvID0+XG4gIG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcobylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZnJvbVN0cmluZyA9IHN0ciA9PiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShzdHIpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCB0b1N0cmluZyA9IGIgPT4gKG5ldyBUZXh0RGVjb2RlcigpKS5kZWNvZGUoYilcblxuZXhwb3J0IHsgZXF1YWxzLCBjb2VyY2UsIGlzQmluYXJ5LCBmcm9tSGV4LCB0b0hleCwgZnJvbVN0cmluZywgdG9TdHJpbmcsIGVtcHR5IH1cbiIsImltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuL3ZhcmludC5qcydcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2hhc2hlcy9kaWdlc3QuanMnXG5pbXBvcnQgeyBiYXNlNThidGMgfSBmcm9tICcuL2Jhc2VzL2Jhc2U1OC5qcydcbmltcG9ydCB7IGJhc2UzMiB9IGZyb20gJy4vYmFzZXMvYmFzZTMyLmpzJ1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi9ieXRlcy5qcydcbi8vIExpbnRlciBjYW4gc2VlIHRoYXQgQVBJIGlzIHVzZWQgaW4gdHlwZXMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmltcG9ydCAqIGFzIEFQSSBmcm9tIFwiLi9saW5rL2ludGVyZmFjZS5qc1wiXG5cbi8vIFRoaXMgd2F5IFRTIHdpbGwgYWxzbyBleHBvc2UgYWxsIHRoZSB0eXBlcyBmcm9tIG1vZHVsZVxuZXhwb3J0ICogZnJvbSAnLi9saW5rL2ludGVyZmFjZS5qcydcblxuLyoqXG4gKiBAdGVtcGxhdGUge0FQSS5MaW5rPHVua25vd24sIG51bWJlciwgbnVtYmVyLCBBUEkuVmVyc2lvbj59IFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBwYXJhbSB7VH0gbGlua1xuICogQHBhcmFtIHtBUEkuTXVsdGliYXNlRW5jb2RlcjxQcmVmaXg+fSBbYmFzZV1cbiAqIEByZXR1cm5zIHtBUEkuVG9TdHJpbmc8VCwgUHJlZml4Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IChsaW5rLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHsgYnl0ZXMsIHZlcnNpb24gfSA9IGxpbmtcbiAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjAoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBiYXNlQ2FjaGUobGluayksXG4gICAgICAgIC8qKiBAdHlwZSB7QVBJLk11bHRpYmFzZUVuY29kZXI8XCJ6XCI+fSAqLyAoYmFzZSkgfHwgYmFzZTU4YnRjLmVuY29kZXJcbiAgICAgIClcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjEoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBiYXNlQ2FjaGUobGluayksXG4gICAgICAgIC8qKiBAdHlwZSB7QVBJLk11bHRpYmFzZUVuY29kZXI8UHJlZml4Pn0gKi8gKGJhc2UgfHwgYmFzZTMyLmVuY29kZXIpXG4gICAgICApXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtXZWFrTWFwPEFQSS5Vbmtub3duTGluaywgTWFwPHN0cmluZywgc3RyaW5nPj59ICovXG5jb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwKClcblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5Vbmtub3duTGlua30gY2lkXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgYmFzZUNhY2hlID0gY2lkID0+IHtcbiAgY29uc3QgYmFzZUNhY2hlID0gY2FjaGUuZ2V0KGNpZClcbiAgaWYgKGJhc2VDYWNoZSA9PSBudWxsKSB7XG4gICAgY29uc3QgYmFzZUNhY2hlID0gbmV3IE1hcCgpXG4gICAgY2FjaGUuc2V0KGNpZCwgYmFzZUNhY2hlKVxuICAgIHJldHVybiBiYXNlQ2FjaGVcbiAgfVxuICByZXR1cm4gYmFzZUNhY2hlXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHt1bmtub3dufSBbRGF0YT11bmtub3duXVxuICogQHRlbXBsYXRlIHtudW1iZXJ9IFtGb3JtYXQ9bnVtYmVyXVxuICogQHRlbXBsYXRlIHtudW1iZXJ9IFtBbGc9bnVtYmVyXVxuICogQHRlbXBsYXRlIHtBUEkuVmVyc2lvbn0gW1ZlcnNpb249QVBJLlZlcnNpb25dXG4gKiBAaW1wbGVtZW50cyB7QVBJLkxpbms8RGF0YSwgRm9ybWF0LCBBbGcsIFZlcnNpb24+fVxuICovXG5cbmV4cG9ydCBjbGFzcyBDSUQge1xuICAvKipcbiAgICogQHBhcmFtIHtWZXJzaW9ufSB2ZXJzaW9uIC0gVmVyc2lvbiBvZiB0aGUgQ0lEXG4gICAqIEBwYXJhbSB7Rm9ybWF0fSBjb2RlIC0gQ29kZSBvZiB0aGUgY29kZWMgY29udGVudCBpcyBlbmNvZGVkIGluLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWNvZGVjL2Jsb2IvbWFzdGVyL3RhYmxlLmNzdlxuICAgKiBAcGFyYW0ge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QWxnPn0gbXVsdGloYXNoIC0gKE11bHRpKWhhc2ggb2YgdGhlIG9mIHRoZSBjb250ZW50LlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcykge1xuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgLyoqIEByZWFkb25seSAqL1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb25cbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWhhc2hcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzXG5cbiAgICAvLyBBcnJheUJ1ZmZlclZpZXdcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldFxuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoXG5cbiAgICAvLyBDaXJjdWxhciByZWZlcmVuY2VcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5hc0NJRCA9IHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q0lEPERhdGEsIEFQSS5EQUdfUEIsIEFQSS5TSEFfMjU2LCAwPn1cbiAgICovXG4gIHRvVjAgKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7Q0lEPERhdGEsIEFQSS5EQUdfUEIsIEFQSS5TSEFfMjU2LCAwPn0gKi8gKHRoaXMpXG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgY29uc3QgeyBjb2RlLCBtdWx0aWhhc2ggfSA9IHRoaXNcblxuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhMi0yNTZcbiAgICAgICAgaWYgKG11bHRpaGFzaC5jb2RlICE9PSBTSEFfMjU2X0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG5vbiBzaGEyLTI1NiBtdWx0aWhhc2ggQ0lEIHRvIENJRHYwJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0NJRDxEYXRhLCBBUEkuREFHX1BCLCBBUEkuU0hBXzI1NiwgMD59ICovIChcbiAgICAgICAgICBDSUQuY3JlYXRlVjAoXG4gICAgICAgICAgICAvKiogQHR5cGUge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QVBJLlNIQV8yNTY+fSAqLyAobXVsdGloYXNoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgQ2FuIG5vdCBjb252ZXJ0IENJRCB2ZXJzaW9uICR7dGhpcy52ZXJzaW9ufSB0byB2ZXJzaW9uIDAuIFRoaXMgaXMgYSBidWcgcGxlYXNlIHJlcG9ydGBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q0lEPERhdGEsIEZvcm1hdCwgQWxnLCAxPn1cbiAgICovXG4gIHRvVjEgKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgY29uc3QgeyBjb2RlLCBkaWdlc3QgfSA9IHRoaXMubXVsdGloYXNoXG4gICAgICAgIGNvbnN0IG11bHRpaGFzaCA9IERpZ2VzdC5jcmVhdGUoY29kZSwgZGlnZXN0KVxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtDSUQ8RGF0YSwgRm9ybWF0LCBBbGcsIDE+fSAqLyAoXG4gICAgICAgICAgQ0lELmNyZWF0ZVYxKHRoaXMuY29kZSwgbXVsdGloYXNoKVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7Q0lEPERhdGEsIEZvcm1hdCwgQWxnLCAxPn0gKi8gKHRoaXMpXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBDYW4gbm90IGNvbnZlcnQgQ0lEIHZlcnNpb24gJHt0aGlzLnZlcnNpb259IHRvIHZlcnNpb24gMS4gVGhpcyBpcyBhIGJ1ZyBwbGVhc2UgcmVwb3J0YFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gb3RoZXJcbiAgICogQHJldHVybnMge290aGVyIGlzIENJRDxEYXRhLCBGb3JtYXQsIEFsZywgVmVyc2lvbj59XG4gICAqL1xuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIENJRC5lcXVhbHModGhpcywgb3RoZXIpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBEYXRhXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBGb3JtYXRcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEFsZ1xuICAgKiBAdGVtcGxhdGUge0FQSS5WZXJzaW9ufSBWZXJzaW9uXG4gICAqIEBwYXJhbSB7QVBJLkxpbms8RGF0YSwgRm9ybWF0LCBBbGcsIFZlcnNpb24+fSBzZWxmXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gb3RoZXJcbiAgICogQHJldHVybnMge290aGVyIGlzIENJRH1cbiAgICovXG4gIHN0YXRpYyBlcXVhbHMgKHNlbGYsIG90aGVyKSB7XG4gICAgY29uc3QgdW5rbm93biA9XG4gICAgICAvKiogQHR5cGUge3tjb2RlPzp1bmtub3duLCB2ZXJzaW9uPzp1bmtub3duLCBtdWx0aWhhc2g/OnVua25vd259fSAqLyAoXG4gICAgICAgIG90aGVyXG4gICAgICApXG4gICAgcmV0dXJuIChcbiAgICAgIHVua25vd24gJiZcbiAgICAgIHNlbGYuY29kZSA9PT0gdW5rbm93bi5jb2RlICYmXG4gICAgICBzZWxmLnZlcnNpb24gPT09IHVua25vd24udmVyc2lvbiAmJlxuICAgICAgRGlnZXN0LmVxdWFscyhzZWxmLm11bHRpaGFzaCwgdW5rbm93bi5tdWx0aWhhc2gpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QVBJLk11bHRpYmFzZUVuY29kZXI8c3RyaW5nPn0gW2Jhc2VdXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoYmFzZSkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcywgYmFzZSlcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoLmJ5dGVzXG4gICAgfVxuICB9XG5cbiAgbGluayAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdDSUQnXG4gIH1cblxuICAvLyBMZWdhY3lcblxuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gKCkge1xuICAgIHJldHVybiBgQ0lEKCR7dGhpcy50b1N0cmluZygpfSlgXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYW55IGlucHV0IGB2YWx1ZWAgYW5kIHJldHVybnMgYSBgQ0lEYCBpbnN0YW5jZSBpZiBpdCB3YXNcbiAgICogYSBgQ0lEYCBvdGhlcndpc2UgcmV0dXJucyBgbnVsbGAuIElmIGB2YWx1ZWAgaXMgaW5zdGFuY2VvZiBgQ0lEYFxuICAgKiBpdCB3aWxsIHJldHVybiB2YWx1ZSBiYWNrLiBJZiBgdmFsdWVgIGlzIG5vdCBpbnN0YW5jZSBvZiB0aGlzIENJRFxuICAgKiBjbGFzcywgYnV0IGlzIGNvbXBhdGlibGUgQ0lEIGl0IHdpbGwgcmV0dXJuIG5ldyBpbnN0YW5jZSBvZiB0aGlzXG4gICAqIGBDSURgIGNsYXNzLiBPdGhlcndpc2UgcmV0dXJzIG51bGwuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHR3byBkaWZmZXJlbnQgaW5jb21wYXRpYmxlIHZlcnNpb25zIG9mIENJRCBsaWJyYXJ5IHRvXG4gICAqIGNvLWV4aXN0IGFuZCBpbnRlcm9wIGFzIGxvbmcgYXMgYmluYXJ5IGludGVyZmFjZSBpcyBjb21wYXRpYmxlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEZvcm1hdFxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQWxnXG4gICAqIEB0ZW1wbGF0ZSB7QVBJLlZlcnNpb259IFZlcnNpb25cbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBVXG4gICAqIEBwYXJhbSB7QVBJLkxpbms8RGF0YSwgRm9ybWF0LCBBbGcsIFZlcnNpb24+fFV9IGlucHV0XG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgRm9ybWF0LCBBbGcsIFZlcnNpb24+fG51bGx9XG4gICAqL1xuICBzdGF0aWMgYXNDSUQgKGlucHV0KSB7XG4gICAgY29uc3QgdmFsdWUgPSAvKiogQHR5cGUge2FueX0gKi8gKGlucHV0KVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENJRCkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgaW5zdGFuY2Ugb2YgQ0lEIHRoZW4gd2UncmUgYWxsIHNldC5cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzbid0IGluc3RhbmNlIG9mIHRoaXMgQ0lEIGNsYXNzIGJ1dCBgdGhpcy5hc0NJRCA9PT0gdGhpc2AgaXNcbiAgICAgIC8vIHRydWUgaXQgaXMgQ0lEIGluc3RhbmNlIGNvbWluZyBmcm9tIGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIChkaWZmXG4gICAgICAvLyB2ZXJzaW9uIG9yIGR1cGxpY2F0ZSkuIEluIHRoYXQgY2FzZSB3ZSByZWJhc2UgaXQgdG8gdGhpcyBgQ0lEYFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gc28gY2FsbGVyIGlzIGd1YXJhbnRlZWQgdG8gZ2V0IGluc3RhbmNlIHdpdGggZXhwZWN0ZWRcbiAgICAgIC8vIEFQSS5cbiAgICAgIGNvbnN0IHsgdmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcyB9ID0gdmFsdWVcbiAgICAgIHJldHVybiBuZXcgQ0lEKFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBjb2RlLFxuICAgICAgICAvKiogQHR5cGUge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QWxnPn0gKi8gKG11bHRpaGFzaCksXG4gICAgICAgIGJ5dGVzIHx8IGVuY29kZUNJRCh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2guYnl0ZXMpXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2NpZFN5bWJvbF0gPT09IHRydWUpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzIGEgQ0lEIGZyb20gb2xkZXIgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VkIHRvIGJlIHRhZ2dlZCB2aWFcbiAgICAgIC8vIHN5bWJvbCB3ZSBzdGlsbCByZWJhc2UgaXQgdG8gdGhlIHRoaXMgYENJRGAgaW1wbGVtZW50YXRpb24gYnlcbiAgICAgIC8vIGRlbGVnYXRpbmcgdGhhdCB0byBhIGNvbnN0cnVjdG9yLlxuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBtdWx0aWhhc2gsIGNvZGUgfSA9IHZhbHVlXG4gICAgICBjb25zdCBkaWdlc3QgPVxuICAgICAgICAvKiogQHR5cGUge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QWxnPn0gKi9cbiAgICAgICAgKERpZ2VzdC5kZWNvZGUobXVsdGloYXNoKSlcbiAgICAgIHJldHVybiBDSUQuY3JlYXRlKHZlcnNpb24sIGNvZGUsIGRpZ2VzdClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIHZhbHVlIGlzIG5vdCBhIENJRCAob3IgYW4gaW5jb21wYXRpYmxlIHZlcnNpb24gb2YgaXQpIGluXG4gICAgICAvLyB3aGljaCBjYXNlIHdlIHJldHVybiBgbnVsbGAuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEZvcm1hdFxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQWxnXG4gICAqIEB0ZW1wbGF0ZSB7QVBJLlZlcnNpb259IFZlcnNpb25cbiAgICogQHBhcmFtIHtWZXJzaW9ufSB2ZXJzaW9uIC0gVmVyc2lvbiBvZiB0aGUgQ0lEXG4gICAqIEBwYXJhbSB7Rm9ybWF0fSBjb2RlIC0gQ29kZSBvZiB0aGUgY29kZWMgY29udGVudCBpcyBlbmNvZGVkIGluLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWNvZGVjL2Jsb2IvbWFzdGVyL3RhYmxlLmNzdlxuICAgKiBAcGFyYW0ge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QWxnPn0gZGlnZXN0IC0gKE11bHRpKWhhc2ggb2YgdGhlIG9mIHRoZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7Q0lEPERhdGEsIEZvcm1hdCwgQWxnLCBWZXJzaW9uPn1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUgKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCkge1xuICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIGNvZGVjcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZCcpXG4gICAgfVxuXG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgaWYgKGNvZGUgIT09IERBR19QQl9DT0RFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFZlcnNpb24gMCBDSUQgbXVzdCB1c2UgZGFnLXBiIChjb2RlOiAke0RBR19QQl9DT0RFfSkgYmxvY2sgZW5jb2RpbmdgXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgZGlnZXN0LmJ5dGVzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LmJ5dGVzKVxuICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGJ5dGVzKVxuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgY3JlYXRlYCBmb3IgQ0lEdjAuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gW1Q9dW5rbm93bl1cbiAgICogQHBhcmFtIHtBUEkuTXVsdGloYXNoRGlnZXN0PHR5cGVvZiBTSEFfMjU2X0NPREU+fSBkaWdlc3QgLSBNdWx0aWhhc2guXG4gICAqIEByZXR1cm5zIHtDSUQ8VCwgdHlwZW9mIERBR19QQl9DT0RFLCB0eXBlb2YgU0hBXzI1Nl9DT0RFLCAwPn1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVWMCAoZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMCwgREFHX1BCX0NPREUsIGRpZ2VzdClcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGlmaWVkIHZlcnNpb24gb2YgYGNyZWF0ZWAgZm9yIENJRHYxLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEFsZ1xuICAgKiBAcGFyYW0ge0NvZGV9IGNvZGUgLSBDb250ZW50IGVuY29kaW5nIGZvcm1hdCBjb2RlLlxuICAgKiBAcGFyYW0ge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QWxnPn0gZGlnZXN0IC0gTWlsdGloYXNoIG9mIHRoZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7Q0lEPERhdGEsIENvZGUsIEFsZywgMT59XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVjEgKGNvZGUsIGRpZ2VzdCkge1xuICAgIHJldHVybiBDSUQuY3JlYXRlKDEsIGNvZGUsIGRpZ2VzdClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVkIGEgQ0lEIGZyb20gaXRzIGJpbmFyeSByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGUgYXJyYXkgbXVzdCBjb250YWluXG4gICAqIG9ubHkgdGhlIENJRCB3aXRoIG5vIGFkZGl0aW9uYWwgYnl0ZXMuXG4gICAqXG4gICAqIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIHRoZSBieXRlcyBwcm92aWRlZCBkbyBub3QgY29udGFpbiBhIHZhbGlkXG4gICAqIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIENJRC5cbiAgICpcbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBEYXRhXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBDb2RlXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBbGdcbiAgICogQHRlbXBsYXRlIHtBUEkuVmVyc2lvbn0gVmVyXG4gICAqIEBwYXJhbSB7QVBJLkJ5dGVWaWV3PEFQSS5MaW5rPERhdGEsIENvZGUsIEFsZywgVmVyPj59IGJ5dGVzXG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgQ29kZSwgQWxnLCBWZXI+fVxuICAgKi9cbiAgc3RhdGljIGRlY29kZSAoYnl0ZXMpIHtcbiAgICBjb25zdCBbY2lkLCByZW1haW5kZXJdID0gQ0lELmRlY29kZUZpcnN0KGJ5dGVzKVxuICAgIGlmIChyZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKVxuICAgIH1cbiAgICByZXR1cm4gY2lkXG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlZCBhIENJRCBmcm9tIGl0cyBiaW5hcnkgcmVwcmVzZW50YXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiBhIGJ5dGVcbiAgICogYXJyYXkuXG4gICAqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluaW5nIHRoZSBDSUQgYW5kIHRoZSBzZWNvbmRcbiAgICogZWxlbWVudCBjb250YWluaW5nIHRoZSByZW1haW5kZXIgb2YgdGhlIG9yaWdpbmFsIGJ5dGUgYXJyYXkuIFRoZSByZW1haW5kZXJcbiAgICogd2lsbCBiZSBhIHplcm8tbGVuZ3RoIGJ5dGUgYXJyYXkgaWYgdGhlIHByb3ZpZGVkIGJ5dGVzIG9ubHkgY29udGFpbmVkIGFcbiAgICogYmluYXJ5IENJRCByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBUXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBDXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBXG4gICAqIEB0ZW1wbGF0ZSB7QVBJLlZlcnNpb259IFZcbiAgICogQHBhcmFtIHtBUEkuQnl0ZVZpZXc8QVBJLkxpbms8VCwgQywgQSwgVj4+fSBieXRlc1xuICAgKiBAcmV0dXJucyB7W0NJRDxULCBDLCBBLCBWPiwgVWludDhBcnJheV19XG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRmlyc3QgKGJ5dGVzKSB7XG4gICAgY29uc3Qgc3BlY3MgPSBDSUQuaW5zcGVjdEJ5dGVzKGJ5dGVzKVxuICAgIGNvbnN0IHByZWZpeFNpemUgPSBzcGVjcy5zaXplIC0gc3BlY3MubXVsdGloYXNoU2l6ZVxuICAgIGNvbnN0IG11bHRpaGFzaEJ5dGVzID0gY29lcmNlKFxuICAgICAgYnl0ZXMuc3ViYXJyYXkocHJlZml4U2l6ZSwgcHJlZml4U2l6ZSArIHNwZWNzLm11bHRpaGFzaFNpemUpXG4gICAgKVxuICAgIGlmIChtdWx0aWhhc2hCeXRlcy5ieXRlTGVuZ3RoICE9PSBzcGVjcy5tdWx0aWhhc2hTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKVxuICAgIH1cbiAgICBjb25zdCBkaWdlc3RCeXRlcyA9IG11bHRpaGFzaEJ5dGVzLnN1YmFycmF5KFxuICAgICAgc3BlY3MubXVsdGloYXNoU2l6ZSAtIHNwZWNzLmRpZ2VzdFNpemVcbiAgICApXG4gICAgY29uc3QgZGlnZXN0ID0gbmV3IERpZ2VzdC5EaWdlc3QoXG4gICAgICBzcGVjcy5tdWx0aWhhc2hDb2RlLFxuICAgICAgc3BlY3MuZGlnZXN0U2l6ZSxcbiAgICAgIGRpZ2VzdEJ5dGVzLFxuICAgICAgbXVsdGloYXNoQnl0ZXNcbiAgICApXG4gICAgY29uc3QgY2lkID1cbiAgICAgIHNwZWNzLnZlcnNpb24gPT09IDBcbiAgICAgICAgPyBDSUQuY3JlYXRlVjAoLyoqIEB0eXBlIHtBUEkuTXVsdGloYXNoRGlnZXN0PEFQSS5TSEFfMjU2Pn0gKi8gKGRpZ2VzdCkpXG4gICAgICAgIDogQ0lELmNyZWF0ZVYxKHNwZWNzLmNvZGVjLCBkaWdlc3QpXG4gICAgcmV0dXJuIFsvKiogQHR5cGUge0NJRDxULCBDLCBBLCBWPn0gKi8oY2lkKSwgYnl0ZXMuc3ViYXJyYXkoc3BlY3Muc2l6ZSldXG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCB0aGUgaW5pdGlhbCBieXRlcyBvZiBhIENJRCB0byBkZXRlcm1pbmUgaXRzIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEludm9sdmVzIGRlY29kaW5nIHVwIHRvIDQgdmFyaW50cy4gVHlwaWNhbGx5IHRoaXMgd2lsbCByZXF1aXJlIG9ubHkgNCB0byA2XG4gICAqIGJ5dGVzIGJ1dCBmb3IgbGFyZ2VyIG11bHRpY29kZWMgY29kZSB2YWx1ZXMgYW5kIGxhcmdlciBtdWx0aWhhc2ggZGlnZXN0XG4gICAqIGxlbmd0aHMgdGhlc2UgdmFyaW50cyBjYW4gYmUgcXVpdGUgbGFyZ2UuIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYXQgbGVhc3RcbiAgICogMTAgYnl0ZXMgYmUgbWFkZSBhdmFpbGFibGUgaW4gdGhlIGBpbml0aWFsQnl0ZXNgIGFyZ3VtZW50IGZvciBhIGNvbXBsZXRlXG4gICAqIGluc3BlY3Rpb24uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gVFxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQ1xuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQVxuICAgKiBAdGVtcGxhdGUge0FQSS5WZXJzaW9ufSBWXG4gICAqIEBwYXJhbSB7QVBJLkJ5dGVWaWV3PEFQSS5MaW5rPFQsIEMsIEEsIFY+Pn0gaW5pdGlhbEJ5dGVzXG4gICAqIEByZXR1cm5zIHt7IHZlcnNpb246ViwgY29kZWM6QywgbXVsdGloYXNoQ29kZTpBLCBkaWdlc3RTaXplOm51bWJlciwgbXVsdGloYXNoU2l6ZTpudW1iZXIsIHNpemU6bnVtYmVyIH19XG4gICAqL1xuICBzdGF0aWMgaW5zcGVjdEJ5dGVzIChpbml0aWFsQnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMFxuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBbaSwgbGVuZ3RoXSA9IHZhcmludC5kZWNvZGUoaW5pdGlhbEJ5dGVzLnN1YmFycmF5KG9mZnNldCkpXG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoXG4gICAgICByZXR1cm4gaVxuICAgIH1cblxuICAgIGxldCB2ZXJzaW9uID0gLyoqIEB0eXBlIHtWfSAqLyAobmV4dCgpKVxuICAgIGxldCBjb2RlYyA9IC8qKiBAdHlwZSB7Q30gKi8gKERBR19QQl9DT0RFKVxuICAgIGlmICgvKiogQHR5cGUge251bWJlcn0gKi8odmVyc2lvbikgPT09IDE4KSB7XG4gICAgICAvLyBDSUR2MFxuICAgICAgdmVyc2lvbiA9IC8qKiBAdHlwZSB7Vn0gKi8gKDApXG4gICAgICBvZmZzZXQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVjID0gLyoqIEB0eXBlIHtDfSAqLyAobmV4dCgpKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICE9PSAwICYmIHZlcnNpb24gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIENJRCB2ZXJzaW9uICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeFNpemUgPSBvZmZzZXRcbiAgICBjb25zdCBtdWx0aWhhc2hDb2RlID0gLyoqIEB0eXBlIHtBfSAqLyAobmV4dCgpKSAvLyBtdWx0aWhhc2ggY29kZVxuICAgIGNvbnN0IGRpZ2VzdFNpemUgPSBuZXh0KCkgLy8gbXVsdGloYXNoIGxlbmd0aFxuICAgIGNvbnN0IHNpemUgPSBvZmZzZXQgKyBkaWdlc3RTaXplXG4gICAgY29uc3QgbXVsdGloYXNoU2l6ZSA9IHNpemUgLSBwcmVmaXhTaXplXG5cbiAgICByZXR1cm4geyB2ZXJzaW9uLCBjb2RlYywgbXVsdGloYXNoQ29kZSwgZGlnZXN0U2l6ZSwgbXVsdGloYXNoU2l6ZSwgc2l6ZSB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgY2lkIGluIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFuZCBjcmVhdGVzIGFuIGluc3RhbmNlLiBJZiBgYmFzZWBcbiAgICogZGVjb2RlciBpcyBub3QgcHJvdmlkZWQgd2lsbCB1c2UgYSBkZWZhdWx0IGZyb20gdGhlIGNvbmZpZ3VyYXRpb24uIEl0IHdpbGxcbiAgICogdGhyb3cgYW4gZXJyb3IgaWYgZW5jb2Rpbmcgb2YgdGhlIENJRCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHN1cHBsaWVkIChvclxuICAgKiBhIGRlZmF1bHQgZGVjb2RlcikuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBEYXRhXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBDb2RlXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBbGdcbiAgICogQHRlbXBsYXRlIHtBUEkuVmVyc2lvbn0gVmVyXG4gICAqIEBwYXJhbSB7QVBJLlRvU3RyaW5nPEFQSS5MaW5rPERhdGEsIENvZGUsIEFsZywgVmVyPiwgUHJlZml4Pn0gc291cmNlXG4gICAqIEBwYXJhbSB7QVBJLk11bHRpYmFzZURlY29kZXI8UHJlZml4Pn0gW2Jhc2VdXG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgQ29kZSwgQWxnLCBWZXI+fVxuICAgKi9cbiAgc3RhdGljIHBhcnNlIChzb3VyY2UsIGJhc2UpIHtcbiAgICBjb25zdCBbcHJlZml4LCBieXRlc10gPSBwYXJzZUNJRHRvQnl0ZXMoc291cmNlLCBiYXNlKVxuXG4gICAgY29uc3QgY2lkID0gQ0lELmRlY29kZShieXRlcylcblxuICAgIC8vIENhY2hlIHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBhdm9pZCBjb21wdXRpbmcgaXQgb24gYHRoaXMudG9TdHJpbmcoKWBcbiAgICBiYXNlQ2FjaGUoY2lkKS5zZXQocHJlZml4LCBzb3VyY2UpXG5cbiAgICByZXR1cm4gY2lkXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBDb2RlXG4gKiBAdGVtcGxhdGUge251bWJlcn0gQWxnXG4gKiBAdGVtcGxhdGUge0FQSS5WZXJzaW9ufSBWZXJcbiAqIEBwYXJhbSB7QVBJLlRvU3RyaW5nPEFQSS5MaW5rPERhdGEsIENvZGUsIEFsZywgVmVyPiwgUHJlZml4Pn0gc291cmNlXG4gKiBAcGFyYW0ge0FQSS5NdWx0aWJhc2VEZWNvZGVyPFByZWZpeD59IFtiYXNlXVxuICogQHJldHVybnMge1tQcmVmaXgsIEFQSS5CeXRlVmlldzxBUEkuTGluazxEYXRhLCBDb2RlLCBBbGcsIFZlcj4+XX1cbiAqL1xuY29uc3QgcGFyc2VDSUR0b0J5dGVzID0gKHNvdXJjZSwgYmFzZSkgPT4ge1xuICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgIC8vIENJRHYwIGlzIHBhcnNlZCBkaWZmZXJlbnRseVxuICAgIGNhc2UgJ1EnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGNcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8qKiBAdHlwZSB7UHJlZml4fSAqLyAoYmFzZTU4YnRjLnByZWZpeCksXG4gICAgICAgIGRlY29kZXIuZGVjb2RlKGAke2Jhc2U1OGJ0Yy5wcmVmaXh9JHtzb3VyY2V9YClcbiAgICAgIF1cbiAgICB9XG4gICAgY2FzZSBiYXNlNThidGMucHJlZml4OiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGNcbiAgICAgIHJldHVybiBbLyoqIEB0eXBlIHtQcmVmaXh9ICovKGJhc2U1OGJ0Yy5wcmVmaXgpLCBkZWNvZGVyLmRlY29kZShzb3VyY2UpXVxuICAgIH1cbiAgICBjYXNlIGJhc2UzMi5wcmVmaXg6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2UzMlxuICAgICAgcmV0dXJuIFsvKiogQHR5cGUge1ByZWZpeH0gKi8oYmFzZTMyLnByZWZpeCksIGRlY29kZXIuZGVjb2RlKHNvdXJjZSldXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ1RvIHBhcnNlIG5vbiBiYXNlMzIgb3IgYmFzZTU4YnRjIGVuY29kZWQgQ0lEIG11bHRpYmFzZSBkZWNvZGVyIG11c3QgYmUgcHJvdmlkZWQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBbLyoqIEB0eXBlIHtQcmVmaXh9ICovKHNvdXJjZVswXSksIGJhc2UuZGVjb2RlKHNvdXJjZSldXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nPn0gY2FjaGVcbiAqIEBwYXJhbSB7QVBJLk11bHRpYmFzZUVuY29kZXI8J3onPn0gYmFzZVxuICovXG5jb25zdCB0b1N0cmluZ1YwID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7IHByZWZpeCB9ID0gYmFzZVxuICBpZiAocHJlZml4ICE9PSBiYXNlNThidGMucHJlZml4KSB7XG4gICAgdGhyb3cgRXJyb3IoYENhbm5vdCBzdHJpbmcgZW5jb2RlIFYwIGluICR7YmFzZS5uYW1lfSBlbmNvZGluZ2ApXG4gIH1cblxuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KVxuICBpZiAoY2lkID09IG51bGwpIHtcbiAgICBjb25zdCBjaWQgPSBiYXNlLmVuY29kZShieXRlcykuc2xpY2UoMSlcbiAgICBjYWNoZS5zZXQocHJlZml4LCBjaWQpXG4gICAgcmV0dXJuIGNpZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaWRcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nPn0gY2FjaGVcbiAqIEBwYXJhbSB7QVBJLk11bHRpYmFzZUVuY29kZXI8UHJlZml4Pn0gYmFzZVxuICovXG5jb25zdCB0b1N0cmluZ1YxID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7IHByZWZpeCB9ID0gYmFzZVxuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KVxuICBpZiAoY2lkID09IG51bGwpIHtcbiAgICBjb25zdCBjaWQgPSBiYXNlLmVuY29kZShieXRlcylcbiAgICBjYWNoZS5zZXQocHJlZml4LCBjaWQpXG4gICAgcmV0dXJuIGNpZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaWRcbiAgfVxufVxuXG5jb25zdCBEQUdfUEJfQ09ERSA9IDB4NzBcbmNvbnN0IFNIQV8yNTZfQ09ERSA9IDB4MTJcblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5WZXJzaW9ufSB2ZXJzaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVDSUQgPSAodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoKSA9PiB7XG4gIGNvbnN0IGNvZGVPZmZzZXQgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmVyc2lvbilcbiAgY29uc3QgaGFzaE9mZnNldCA9IGNvZGVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSlcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoT2Zmc2V0ICsgbXVsdGloYXNoLmJ5dGVMZW5ndGgpXG4gIHZhcmludC5lbmNvZGVUbyh2ZXJzaW9uLCBieXRlcywgMClcbiAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCBjb2RlT2Zmc2V0KVxuICBieXRlcy5zZXQobXVsdGloYXNoLCBoYXNoT2Zmc2V0KVxuICByZXR1cm4gYnl0ZXNcbn1cblxuY29uc3QgY2lkU3ltYm9sID0gU3ltYm9sLmZvcignQGlwbGQvanMtY2lkL0NJRCcpXG4iLCIvLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9pbnRlcmZhY2UuanMnKS5CeXRlVmlldzxUPn0gQnl0ZVZpZXdcbiAqL1xuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbmV4cG9ydCBjb25zdCBuYW1lID0gJ2pzb24nXG5leHBvcnQgY29uc3QgY29kZSA9IDB4MDIwMFxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IG5vZGVcbiAqIEByZXR1cm5zIHtCeXRlVmlldzxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IChub2RlKSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobm9kZSkpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7Qnl0ZVZpZXc8VD59IGRhdGFcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gKGRhdGEpID0+IEpTT04ucGFyc2UodGV4dERlY29kZXIuZGVjb2RlKGRhdGEpKVxuIiwiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJ1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2ludGVyZmFjZS5qcycpLkJ5dGVWaWV3PFQ+fSBCeXRlVmlld1xuICovXG5cbmV4cG9ydCBjb25zdCBuYW1lID0gJ3JhdydcbmV4cG9ydCBjb25zdCBjb2RlID0gMHg1NVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbm9kZVxuICogQHJldHVybnMge0J5dGVWaWV3PFVpbnQ4QXJyYXk+fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKG5vZGUpID0+IGNvZXJjZShub2RlKVxuXG4vKipcbiAqIEBwYXJhbSB7Qnl0ZVZpZXc8VWludDhBcnJheT59IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gKGRhdGEpID0+IGNvZXJjZShkYXRhKVxuIiwiaW1wb3J0IHsgY29lcmNlLCBlcXVhbHMgYXMgZXF1YWxCeXRlcyB9IGZyb20gJy4uL2J5dGVzLmpzJ1xuaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4uL3ZhcmludC5qcydcblxuLyoqXG4gKiBDcmVhdGVzIGEgbXVsdGloYXNoIGRpZ2VzdC5cbiAqXG4gKiBAdGVtcGxhdGUge251bWJlcn0gQ29kZVxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRpZ2VzdFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGNvZGUsIGRpZ2VzdCkgPT4ge1xuICBjb25zdCBzaXplID0gZGlnZXN0LmJ5dGVMZW5ndGhcbiAgY29uc3Qgc2l6ZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aChjb2RlKVxuICBjb25zdCBkaWdlc3RPZmZzZXQgPSBzaXplT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHNpemUpXG5cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShkaWdlc3RPZmZzZXQgKyBzaXplKVxuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIDApXG4gIHZhcmludC5lbmNvZGVUbyhzaXplLCBieXRlcywgc2l6ZU9mZnNldClcbiAgYnl0ZXMuc2V0KGRpZ2VzdCwgZGlnZXN0T2Zmc2V0KVxuXG4gIHJldHVybiBuZXcgRGlnZXN0KGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpXG59XG5cbi8qKlxuICogVHVybnMgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgbXVsdGloYXNoIGRpZ2VzdCBpbnRvIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbXVsdGloYXNoXG4gKiBAcmV0dXJucyB7TXVsdGloYXNoRGlnZXN0fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gKG11bHRpaGFzaCkgPT4ge1xuICBjb25zdCBieXRlcyA9IGNvZXJjZShtdWx0aWhhc2gpXG4gIGNvbnN0IFtjb2RlLCBzaXplT2Zmc2V0XSA9IHZhcmludC5kZWNvZGUoYnl0ZXMpXG4gIGNvbnN0IFtzaXplLCBkaWdlc3RPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcy5zdWJhcnJheShzaXplT2Zmc2V0KSlcbiAgY29uc3QgZGlnZXN0ID0gYnl0ZXMuc3ViYXJyYXkoc2l6ZU9mZnNldCArIGRpZ2VzdE9mZnNldClcblxuICBpZiAoZGlnZXN0LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBEaWdlc3QoY29kZSwgc2l6ZSwgZGlnZXN0LCBieXRlcylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge011bHRpaGFzaERpZ2VzdH0gYVxuICogQHBhcmFtIHt1bmtub3dufSBiXG4gKiBAcmV0dXJucyB7YiBpcyBNdWx0aWhhc2hEaWdlc3R9XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbHMgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IC8qKiBAdHlwZSB7e2NvZGU/OnVua25vd24sIHNpemU/OnVua25vd24sIGJ5dGVzPzp1bmtub3dufX0gKi8oYilcblxuICAgIHJldHVybiAoXG4gICAgICBhLmNvZGUgPT09IGRhdGEuY29kZSAmJlxuICAgICAgYS5zaXplID09PSBkYXRhLnNpemUgJiZcbiAgICAgIGRhdGEuYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmXG4gICAgICBlcXVhbEJ5dGVzKGEuYnl0ZXMsIGRhdGEuYnl0ZXMpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9pbnRlcmZhY2UuanMnKS5NdWx0aWhhc2hEaWdlc3R9IE11bHRpaGFzaERpZ2VzdFxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG11bHRpaGFzaCBkaWdlc3Qgd2hpY2ggY2FycmllcyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAqIGhhc2hpbmcgYWxvZ3JpdGhtIGFuZCBhbiBhY3R1YWwgaGFzaCBkaWdlc3QuXG4gKlxuICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBTaXplXG4gKiBAY2xhc3NcbiAqIEBpbXBsZW1lbnRzIHtNdWx0aWhhc2hEaWdlc3R9XG4gKi9cbmV4cG9ydCBjbGFzcyBEaWdlc3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG11bHRpaGFzaCBkaWdlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICAgKiBAcGFyYW0ge1NpemV9IHNpemVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkaWdlc3RcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5zaXplID0gc2l6ZVxuICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0XG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcydcblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gTmFtZVxuICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge05hbWV9IG9wdGlvbnMubmFtZVxuICogQHBhcmFtIHtDb2RlfSBvcHRpb25zLmNvZGVcbiAqIEBwYXJhbSB7KGlucHV0OiBVaW50OEFycmF5KSA9PiBBd2FpdDxVaW50OEFycmF5Pn0gb3B0aW9ucy5lbmNvZGVcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoeyBuYW1lLCBjb2RlLCBlbmNvZGUgfSkgPT4gbmV3IEhhc2hlcihuYW1lLCBjb2RlLCBlbmNvZGUpXG5cbi8qKlxuICogSGFzaGVyIHJlcHJlc2VudHMgYSBoYXNoaW5nIGFsZ29yaXRobSBpbXBsZW1lbnRhdGlvbiB0aGF0IHByb2R1Y2VzIGFzXG4gKiBgTXVsdGloYXNoRGlnZXN0YC5cbiAqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gTmFtZVxuICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAqIEBjbGFzc1xuICogQGltcGxlbWVudHMge011bHRpaGFzaEhhc2hlcjxDb2RlPn1cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hlciB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge05hbWV9IG5hbWVcbiAgICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gICAqIEBwYXJhbSB7KGlucHV0OiBVaW50OEFycmF5KSA9PiBBd2FpdDxVaW50OEFycmF5Pn0gZW5jb2RlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgY29kZSwgZW5jb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICogQHJldHVybnMge0F3YWl0PERpZ2VzdC5EaWdlc3Q8Q29kZSwgbnVtYmVyPj59XG4gICAqL1xuICBkaWdlc3QgKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbmNvZGUoaW5wdXQpXG4gICAgICByZXR1cm4gcmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICA/IERpZ2VzdC5jcmVhdGUodGhpcy5jb2RlLCByZXN1bHQpXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDEgKi9cbiAgICAgICAgOiByZXN1bHQudGhlbihkaWdlc3QgPT4gRGlnZXN0LmNyZWF0ZSh0aGlzLmNvZGUsIGRpZ2VzdCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKVxuICAgICAgLyogYzggaWdub3JlIG5leHQgMSAqL1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBbGdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaW50ZXJmYWNlLmpzJykuTXVsdGloYXNoSGFzaGVyfSBNdWx0aWhhc2hIYXNoZXJcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7UHJvbWlzZTxUPnxUfSBBd2FpdFxuICovXG4iLCJpbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuLi9ieXRlcy5qcydcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcydcblxuY29uc3QgY29kZSA9IDB4MFxuY29uc3QgbmFtZSA9ICdpZGVudGl0eSdcblxuLyoqIEB0eXBlIHsoaW5wdXQ6VWludDhBcnJheSkgPT4gVWludDhBcnJheX0gKi9cbmNvbnN0IGVuY29kZSA9IGNvZXJjZVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAqIEByZXR1cm5zIHtEaWdlc3QuRGlnZXN0PHR5cGVvZiBjb2RlLCBudW1iZXI+fVxuICovXG5jb25zdCBkaWdlc3QgPSAoaW5wdXQpID0+IERpZ2VzdC5jcmVhdGUoY29kZSwgZW5jb2RlKGlucHV0KSlcblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0geyBjb2RlLCBuYW1lLCBlbmNvZGUsIGRpZ2VzdCB9XG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nXG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9oYXNoZXIuanMnXG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuLi9ieXRlcy5qcydcblxuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IGZyb20oe1xuICBuYW1lOiAnc2hhMi0yNTYnLFxuICBjb2RlOiAweDEyLFxuICBlbmNvZGU6IChpbnB1dCkgPT4gY29lcmNlKGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSlcblxuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IGZyb20oe1xuICBuYW1lOiAnc2hhMi01MTInLFxuICBjb2RlOiAweDEzLFxuICBlbmNvZGU6IGlucHV0ID0+IGNvZXJjZShjcnlwdG8uY3JlYXRlSGFzaCgnc2hhNTEyJykudXBkYXRlKGlucHV0KS5kaWdlc3QoKSlcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICcuL2NpZC5qcydcbmltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuL3ZhcmludC5qcydcbmltcG9ydCAqIGFzIGJ5dGVzIGZyb20gJy4vYnl0ZXMuanMnXG5pbXBvcnQgKiBhcyBoYXNoZXIgZnJvbSAnLi9oYXNoZXMvaGFzaGVyLmpzJ1xuaW1wb3J0ICogYXMgZGlnZXN0IGZyb20gJy4vaGFzaGVzL2RpZ2VzdC5qcydcbi8vIFRoaXMgd2F5IFRTIHdpbGwgYWxzbyBleHBvc2UgYWxsIHRoZSB0eXBlcyBmcm9tIG1vZHVsZVxuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2UuanMnXG5cbmV4cG9ydCB7IENJRCwgaGFzaGVyLCBkaWdlc3QsIHZhcmludCwgYnl0ZXMgfVxuIiwiLy8gdGhpcyBpcyBkdW1teSBtb2R1bGUgb3ZlcmxheWVkIGJ5IGludGVyZmFjZS50c1xuIiwiLy8gdGhpcyBpcyBkdW1teSBtb2R1bGUgb3ZlcmxheWVkIGJ5IGludGVyZmFjZS50c1xuIiwiaW1wb3J0IHZhcmludCBmcm9tICcuLi92ZW5kb3IvdmFyaW50LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF1cbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXJdfVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gKGRhdGEsIG9mZnNldCA9IDApID0+IHtcbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoZGF0YSwgb2Zmc2V0KVxuICByZXR1cm4gW2NvZGUsIHZhcmludC5kZWNvZGUuYnl0ZXNdXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGludFxuICogQHBhcmFtIHtVaW50OEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUbyA9IChpbnQsIHRhcmdldCwgb2Zmc2V0ID0gMCkgPT4ge1xuICB2YXJpbnQuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpXG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RpbmdMZW5ndGggPSAoaW50KSA9PiB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaW50KVxufVxuIiwiLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCwgbmFtZSkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKTtcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGk7XG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGg7XG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMCk7XG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1Nik7IC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpOyAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSA7IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIHBiZWdpbiA9IDA7XG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrO1xuICAgICAgemVyb2VzKys7XG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwO1xuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl07XG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwO1xuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcGJlZ2luKys7XG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKys7XG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pOyB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKSB9XG4gICAgdmFyIHBzeiA9IDA7XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyBzcGFjZXMuXG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHsgcmV0dXJuIH1cbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrKztcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwOyAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDA7XG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCB0cmFpbGluZyBzcGFjZXMuXG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHsgcmV0dXJuIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrKztcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSk7XG4gICAgdmFyIGogPSB6ZXJvZXM7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpO1xuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHtuYW1lfSBjaGFyYWN0ZXJgKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxudmFyIHNyYyA9IGJhc2U7XG5cbnZhciBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYID0gc3JjO1xuXG5leHBvcnQgZGVmYXVsdCBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYO1xuIiwidmFyIGVuY29kZV8xID0gZW5jb2RlO1xuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSk7XG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIG91dCA9IG91dCB8fCBbXTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0I7XG4gICAgbnVtIC89IDEyODtcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCO1xuICAgIG51bSA+Pj49IDc7XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwO1xuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMTtcbiAgXG4gIHJldHVybiBvdXRcbn1cblxudmFyIGRlY29kZSA9IHJlYWQ7XG5cbnZhciBNU0IkMSA9IDB4ODBcbiAgLCBSRVNUJDEgPSAweDdGO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwO1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdO1xuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCQxKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QkMSkgKiBNYXRoLnBvdygyLCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gNztcbiAgfSB3aGlsZSAoYiA+PSBNU0IkMSlcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldDtcblxuICByZXR1cm4gcmVzXG59XG5cbnZhciBOMSA9IE1hdGgucG93KDIsICA3KTtcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KTtcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKTtcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KTtcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KTtcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKTtcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KTtcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KTtcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKTtcblxudmFyIGxlbmd0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59O1xuXG52YXIgdmFyaW50ID0ge1xuICAgIGVuY29kZTogZW5jb2RlXzFcbiAgLCBkZWNvZGU6IGRlY29kZVxuICAsIGVuY29kaW5nTGVuZ3RoOiBsZW5ndGhcbn07XG5cbnZhciBfYnJycF92YXJpbnQgPSB2YXJpbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IF9icnJwX3ZhcmludDtcbiIsIi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcGFzc2VkIFVpbnQ4QXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWxzLmpzLm1hcCIsImltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJztcbmNvbnN0IHJlZHVjZVZhbHVlID0gKF8sIHYpID0+IHY7XG5jb25zdCB0Y3BVcmkgPSAoc3RyLCBwb3J0LCBwYXJ0cywgb3B0cykgPT4ge1xuICAgIC8vIHJldHVybiB0Y3Agd2hlbiBleHBsaWNpdGx5IHJlcXVlc3RlZFxuICAgIGlmICgob3B0cyAhPSBudWxsKSAmJiBvcHRzLmFzc3VtZUh0dHAgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gYHRjcDovLyR7c3RyfToke3BvcnR9YDtcbiAgICAvLyBjaGVjayBpZiB0Y3AgaXMgdGhlIGxhc3QgcHJvdG9jb2wgaW4gbXVsdGlhZGRyXG4gICAgbGV0IHByb3RvY29sID0gJ3RjcCc7XG4gICAgbGV0IGV4cGxpY2l0UG9ydCA9IGA6JHtwb3J0fWA7XG4gICAgY29uc3QgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0LnByb3RvY29sID09PSAndGNwJykge1xuICAgICAgICAvLyBhc3N1bWUgaHR0cCBhbmQgcHJvZHVjZSBjbGVhbiB1cmxzXG4gICAgICAgIHByb3RvY29sID0gcG9ydCA9PT0gJzQ0MycgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgICAgICBleHBsaWNpdFBvcnQgPSBwb3J0ID09PSAnNDQzJyB8fCBwb3J0ID09PSAnODAnID8gJycgOiBleHBsaWNpdFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke3N0cn0ke2V4cGxpY2l0UG9ydH1gO1xufTtcbmNvbnN0IFJlZHVjZXJzID0ge1xuICAgIGlwNDogcmVkdWNlVmFsdWUsXG4gICAgaXA2OiAoc3RyLCBjb250ZW50LCBpLCBwYXJ0cykgPT4gKHBhcnRzLmxlbmd0aCA9PT0gMSAmJiBwYXJ0c1swXS5wcm90b2NvbCA9PT0gJ2lwNidcbiAgICAgICAgPyBjb250ZW50XG4gICAgICAgIDogYFske2NvbnRlbnR9XWApLFxuICAgIHRjcDogKHN0ciwgY29udGVudCwgaSwgcGFydHMsIG9wdHMpID0+IChwYXJ0cy5zb21lKHAgPT4gWydodHRwJywgJ2h0dHBzJywgJ3dzJywgJ3dzcyddLmluY2x1ZGVzKHAucHJvdG9jb2wpKVxuICAgICAgICA/IGAke3N0cn06JHtjb250ZW50fWBcbiAgICAgICAgOiB0Y3BVcmkoc3RyLCBjb250ZW50LCBwYXJ0cywgb3B0cykpLFxuICAgIHVkcDogKHN0ciwgY29udGVudCkgPT4gYHVkcDovLyR7c3RyfToke2NvbnRlbnR9YCxcbiAgICBkbnNhZGRyOiByZWR1Y2VWYWx1ZSxcbiAgICBkbnM0OiByZWR1Y2VWYWx1ZSxcbiAgICBkbnM2OiByZWR1Y2VWYWx1ZSxcbiAgICBpcGZzOiAoc3RyLCBjb250ZW50KSA9PiBgJHtzdHJ9L2lwZnMvJHtjb250ZW50fWAsXG4gICAgcDJwOiAoc3RyLCBjb250ZW50KSA9PiBgJHtzdHJ9L3AycC8ke2NvbnRlbnR9YCxcbiAgICBodHRwOiBzdHIgPT4gYGh0dHA6Ly8ke3N0cn1gLFxuICAgIGh0dHBzOiBzdHIgPT4gYGh0dHBzOi8vJHtzdHJ9YCxcbiAgICB3czogc3RyID0+IGB3czovLyR7c3RyfWAsXG4gICAgd3NzOiBzdHIgPT4gYHdzczovLyR7c3RyfWAsXG4gICAgJ3AycC13ZWJzb2NrZXQtc3Rhcic6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJzb2NrZXQtc3RhcmAsXG4gICAgJ3AycC13ZWJydGMtc3Rhcic6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJydGMtc3RhcmAsXG4gICAgJ3AycC13ZWJydGMtZGlyZWN0Jzogc3RyID0+IGAke3N0cn0vcDJwLXdlYnJ0Yy1kaXJlY3RgXG59O1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpYWRkclRvVXJpKGlucHV0LCBvcHRzKSB7XG4gICAgY29uc3QgbWEgPSBtdWx0aWFkZHIoaW5wdXQpO1xuICAgIGNvbnN0IHBhcnRzID0gbWEudG9TdHJpbmcoKS5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICAgIHJldHVybiBtYVxuICAgICAgICAudHVwbGVzKClcbiAgICAgICAgLm1hcCh0dXBsZSA9PiAoe1xuICAgICAgICBwcm90b2NvbDogcGFydHMuc2hpZnQoKSA/PyAnJyxcbiAgICAgICAgY29udGVudDogKHR1cGxlWzFdICE9IG51bGwpID8gcGFydHMuc2hpZnQoKSA/PyAnJyA6ICcnXG4gICAgfSkpXG4gICAgICAgIC5yZWR1Y2UoKHN0ciwgcGFydCwgaSwgcGFydHMpID0+IHtcbiAgICAgICAgY29uc3QgcmVkdWNlID0gUmVkdWNlcnNbcGFydC5wcm90b2NvbF07XG4gICAgICAgIGlmIChyZWR1Y2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm90b2NvbCAke3BhcnQucHJvdG9jb2x9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZHVjZShzdHIsIHBhcnQuY29udGVudCwgaSwgcGFydHMsIG9wdHMpO1xuICAgIH0sICcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGNvbnZlcnRUb0J5dGVzLCBjb252ZXJ0VG9TdHJpbmcgfSBmcm9tICcuL2NvbnZlcnQuanMnO1xuaW1wb3J0IHsgZ2V0UHJvdG9jb2wgfSBmcm9tICcuL3Byb3RvY29scy10YWJsZS5qcyc7XG5pbXBvcnQgdmFyaW50IGZyb20gJ3ZhcmludCc7XG5pbXBvcnQgeyBjb25jYXQgYXMgdWludDhBcnJheUNvbmNhdCB9IGZyb20gJ3VpbnQ4YXJyYXlzL2NvbmNhdCc7XG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnO1xuLyoqXG4gKiBzdHJpbmcgLT4gW1tzdHIgbmFtZSwgc3RyIGFkZHJdLi4uIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvU3RyaW5nVHVwbGVzKHN0cikge1xuICAgIGNvbnN0IHR1cGxlcyA9IFtdO1xuICAgIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KCcvJykuc2xpY2UoMSk7IC8vIHNraXAgZmlyc3QgZW1wdHkgZWxlbVxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEgJiYgcGFydHNbMF0gPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXJ0cy5sZW5ndGg7IHArKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbcF07XG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG9jb2wocGFydCk7XG4gICAgICAgIGlmIChwcm90by5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0dXBsZXMucHVzaChbcGFydF0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcCsrOyAvLyBhZHZhbmNlIGFkZHIgcGFydFxuICAgICAgICBpZiAocCA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IFBhcnNlRXJyb3IoJ2ludmFsaWQgYWRkcmVzczogJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXQncyBhIHBhdGggcHJvdG8sIHRha2UgdGhlIHJlc3RcbiAgICAgICAgaWYgKHByb3RvLnBhdGggPT09IHRydWUpIHtcbiAgICAgICAgICAgIHR1cGxlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBuZWVkIHRvIGNoZWNrIGVhY2ggcGF0aCBwYXJ0IHRvIHNlZSBpZiBpdCdzIGEgcHJvdG8/XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3VsZCBhbGxvdyBmb3Igb3RoZXIgcHJvdG9jb2xzIHRvIGJlIGFkZGVkIGFmdGVyIGEgdW5peCBwYXRoLFxuICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIgaXQgd291bGQgaGF2ZSBpc3N1ZXMgaWYgdGhlIHBhdGggaGFkIGEgcHJvdG9jb2wgbmFtZSBpbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgIGNsZWFuUGF0aChwYXJ0cy5zbGljZShwKS5qb2luKCcvJykpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHR1cGxlcy5wdXNoKFtwYXJ0LCBwYXJ0c1twXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdHVwbGVzO1xufVxuLyoqXG4gKiBbW3N0ciBuYW1lLCBzdHIgYWRkcl0uLi4gXSAtPiBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1R1cGxlc1RvU3RyaW5nKHR1cGxlcykge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgdHVwbGVzLm1hcCgodHVwKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gcHJvdG9Gcm9tVHVwbGUodHVwKTtcbiAgICAgICAgcGFydHMucHVzaChwcm90by5uYW1lKTtcbiAgICAgICAgaWYgKHR1cC5sZW5ndGggPiAxICYmIHR1cFsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHR1cFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuUGF0aChwYXJ0cy5qb2luKCcvJykpO1xufVxuLyoqXG4gKiBbW3N0ciBuYW1lLCBzdHIgYWRkcl0uLi4gXSAtPiBbW2ludCBjb2RlLCBVaW50OEFycmF5XS4uLiBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUdXBsZXNUb1R1cGxlcyh0dXBsZXMpIHtcbiAgICByZXR1cm4gdHVwbGVzLm1hcCgodHVwKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0dXApKSB7XG4gICAgICAgICAgICB0dXAgPSBbdHVwXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cCk7XG4gICAgICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcm90by5jb2RlLCBjb252ZXJ0VG9CeXRlcyhwcm90by5jb2RlLCB0dXBbMV0pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Byb3RvLmNvZGVdO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0IHR1cGxlcyB0byBzdHJpbmcgdHVwbGVzXG4gKlxuICogW1tpbnQgY29kZSwgVWludDhBcnJheV0uLi4gXSAtPiBbW2ludCBjb2RlLCBzdHIgYWRkcl0uLi4gXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHVwbGVzVG9TdHJpbmdUdXBsZXModHVwbGVzKSB7XG4gICAgcmV0dXJuIHR1cGxlcy5tYXAodHVwID0+IHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBwcm90b0Zyb21UdXBsZSh0dXApO1xuICAgICAgICBpZiAodHVwWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbcHJvdG8uY29kZSwgY29udmVydFRvU3RyaW5nKHByb3RvLmNvZGUsIHR1cFsxXSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcHJvdG8uY29kZV07XG4gICAgfSk7XG59XG4vKipcbiAqIFtbaW50IGNvZGUsIFVpbnQ4QXJyYXkgXS4uLiBdIC0+IFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlc1RvQnl0ZXModHVwbGVzKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyh1aW50OEFycmF5Q29uY2F0KHR1cGxlcy5tYXAoKHR1cCkgPT4ge1xuICAgICAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cCk7XG4gICAgICAgIGxldCBidWYgPSBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZShwcm90by5jb2RlKSk7XG4gICAgICAgIGlmICh0dXAubGVuZ3RoID4gMSAmJiB0dXBbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmID0gdWludDhBcnJheUNvbmNhdChbYnVmLCB0dXBbMV1dKTsgLy8gYWRkIGFkZHJlc3MgYnVmZmVyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9KSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVGb3JBZGRyKHAsIGFkZHIpIHtcbiAgICBpZiAocC5zaXplID4gMCkge1xuICAgICAgICByZXR1cm4gcC5zaXplIC8gODtcbiAgICB9XG4gICAgZWxzZSBpZiAocC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHZhcmludC5kZWNvZGUoYWRkcik7XG4gICAgICAgIHJldHVybiBzaXplICsgdmFyaW50LmRlY29kZS5ieXRlcztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1R1cGxlcyhidWYpIHtcbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZiwgaSk7XG4gICAgICAgIGNvbnN0IG4gPSB2YXJpbnQuZGVjb2RlLmJ5dGVzO1xuICAgICAgICBjb25zdCBwID0gZ2V0UHJvdG9jb2woY29kZSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBzaXplRm9yQWRkcihwLCBidWYuc2xpY2UoaSArIG4pKTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHR1cGxlcy5wdXNoKFtjb2RlXSk7XG4gICAgICAgICAgICBpICs9IG47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyID0gYnVmLnNsaWNlKGkgKyBuLCBpICsgbiArIHNpemUpO1xuICAgICAgICBpICs9IChzaXplICsgbik7XG4gICAgICAgIGlmIChpID4gYnVmLmxlbmd0aCkgeyAvLyBkaWQgbm90IGVuZCBfZXhhY3RseV8gYXQgYnVmZmVyLmxlbmd0aFxuICAgICAgICAgICAgdGhyb3cgUGFyc2VFcnJvcignSW52YWxpZCBhZGRyZXNzIFVpbnQ4QXJyYXk6ICcgKyB1aW50OEFycmF5VG9TdHJpbmcoYnVmLCAnYmFzZTE2JykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9rLCB0dXBsZSBzZWVtcyBnb29kLlxuICAgICAgICB0dXBsZXMucHVzaChbY29kZSwgYWRkcl0pO1xuICAgIH1cbiAgICByZXR1cm4gdHVwbGVzO1xufVxuLyoqXG4gKiBVaW50OEFycmF5IC0+IFN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhidWYpIHtcbiAgICBjb25zdCBhID0gYnl0ZXNUb1R1cGxlcyhidWYpO1xuICAgIGNvbnN0IGIgPSB0dXBsZXNUb1N0cmluZ1R1cGxlcyhhKTtcbiAgICByZXR1cm4gc3RyaW5nVHVwbGVzVG9TdHJpbmcoYik7XG59XG4vKipcbiAqIFN0cmluZyAtPiBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICAgIHN0ciA9IGNsZWFuUGF0aChzdHIpO1xuICAgIGNvbnN0IGEgPSBzdHJpbmdUb1N0cmluZ1R1cGxlcyhzdHIpO1xuICAgIGNvbnN0IGIgPSBzdHJpbmdUdXBsZXNUb1R1cGxlcyhhKTtcbiAgICByZXR1cm4gdHVwbGVzVG9CeXRlcyhiKTtcbn1cbi8qKlxuICogU3RyaW5nIC0+IFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoc3RyKTtcbn1cbi8qKlxuICogVWludDhBcnJheSAtPiBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnVmKSB7XG4gICAgY29uc3QgZXJyID0gdmFsaWRhdGVCeXRlcyhidWYpO1xuICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmKTsgLy8gY29weVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQnl0ZXMoYnVmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYnl0ZXNUb1R1cGxlcyhidWYpOyAvLyB0cnkgdG8gcGFyc2UuIHdpbGwgdGhyb3cgaWYgYnJlYWtzXG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEJ5dGVzKGJ1Zikge1xuICAgIHJldHVybiB2YWxpZGF0ZUJ5dGVzKGJ1ZikgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblBhdGgoc3RyKSB7XG4gICAgcmV0dXJuICcvJyArIHN0ci50cmltKCkuc3BsaXQoJy8nKS5maWx0ZXIoKGEpID0+IGEpLmpvaW4oJy8nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUVycm9yKHN0cikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgYWRkcmVzczogJyArIHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvdG9Gcm9tVHVwbGUodHVwKSB7XG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90b2NvbCh0dXBbMF0pO1xuICAgIHJldHVybiBwcm90bztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImltcG9ydCAqIGFzIGlwIGZyb20gJy4vaXAuanMnO1xuaW1wb3J0IHsgZ2V0UHJvdG9jb2wgfSBmcm9tICcuL3Byb3RvY29scy10YWJsZS5qcyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGJhc2UzMiB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNlcy9iYXNlMzInO1xuaW1wb3J0IHsgYmFzZTU4YnRjIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jhc2VzL2Jhc2U1OCc7XG5pbXBvcnQgeyBiYXNlcyB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNpY3MnO1xuaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvZGlnZXN0JztcbmltcG9ydCB2YXJpbnQgZnJvbSAndmFyaW50JztcbmltcG9ydCB7IHRvU3RyaW5nIGFzIHVpbnQ4QXJyYXlUb1N0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZyc7XG5pbXBvcnQgeyBmcm9tU3RyaW5nIGFzIHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvZnJvbS1zdHJpbmcnO1xuaW1wb3J0IHsgY29uY2F0IGFzIHVpbnQ4QXJyYXlDb25jYXQgfSBmcm9tICd1aW50OGFycmF5cy9jb25jYXQnO1xuLyoqXG4gKiBjb252ZXJ0cyAoc2VyaWFsaXplcykgYWRkcmVzc2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KHByb3RvLCBhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdHJpbmcocHJvdG8sIGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb0J5dGVzKHByb3RvLCBhKTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnQgW2NvZGUsVWludDhBcnJheV0gdG8gc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9TdHJpbmcocHJvdG8sIGJ1Zikge1xuICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wocHJvdG8pO1xuICAgIHN3aXRjaCAocHJvdG9jb2wuY29kZSkge1xuICAgICAgICBjYXNlIDQ6IC8vIGlwdjRcbiAgICAgICAgY2FzZSA0MTogLy8gaXB2NlxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzMmlwKGJ1Zik7XG4gICAgICAgIGNhc2UgNjogLy8gdGNwXG4gICAgICAgIGNhc2UgMjczOiAvLyB1ZHBcbiAgICAgICAgY2FzZSAzMzogLy8gZGNjcFxuICAgICAgICBjYXNlIDEzMjogLy8gc2N0cFxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzMnBvcnQoYnVmKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIDUzOiAvLyBkbnNcbiAgICAgICAgY2FzZSA1NDogLy8gZG5zNFxuICAgICAgICBjYXNlIDU1OiAvLyBkbnM2XG4gICAgICAgIGNhc2UgNTY6IC8vIGRuc2FkZHJcbiAgICAgICAgY2FzZSA0MDA6IC8vIHVuaXhcbiAgICAgICAgY2FzZSA3Nzc6IC8vIG1lbW9yeVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzMnN0cihidWYpO1xuICAgICAgICBjYXNlIDQyMTogLy8gaXBmc1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzMm1oKGJ1Zik7XG4gICAgICAgIGNhc2UgNDQ0OiAvLyBvbmlvblxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzMm9uaW9uKGJ1Zik7XG4gICAgICAgIGNhc2UgNDQ1OiAvLyBvbmlvbjNcbiAgICAgICAgICAgIHJldHVybiBieXRlczJvbmlvbihidWYpO1xuICAgICAgICBjYXNlIDQ2NjogLy8gY2VydGhhc2hcbiAgICAgICAgICAgIHJldHVybiBieXRlczJtYihidWYpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhidWYsICdiYXNlMTYnKTsgLy8gbm8gY2x1ZS4gY29udmVydCB0byBoZXhcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvQnl0ZXMocHJvdG8sIHN0cikge1xuICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wocHJvdG8pO1xuICAgIHN3aXRjaCAocHJvdG9jb2wuY29kZSkge1xuICAgICAgICBjYXNlIDQ6IC8vIGlwdjRcbiAgICAgICAgICAgIHJldHVybiBpcDJieXRlcyhzdHIpO1xuICAgICAgICBjYXNlIDQxOiAvLyBpcHY2XG4gICAgICAgICAgICByZXR1cm4gaXAyYnl0ZXMoc3RyKTtcbiAgICAgICAgY2FzZSA2OiAvLyB0Y3BcbiAgICAgICAgY2FzZSAyNzM6IC8vIHVkcFxuICAgICAgICBjYXNlIDMzOiAvLyBkY2NwXG4gICAgICAgIGNhc2UgMTMyOiAvLyBzY3RwXG4gICAgICAgICAgICByZXR1cm4gcG9ydDJieXRlcyhwYXJzZUludChzdHIsIDEwKSk7XG4gICAgICAgIGNhc2UgNTM6IC8vIGRuc1xuICAgICAgICBjYXNlIDU0OiAvLyBkbnM0XG4gICAgICAgIGNhc2UgNTU6IC8vIGRuczZcbiAgICAgICAgY2FzZSA1NjogLy8gZG5zYWRkclxuICAgICAgICBjYXNlIDQwMDogLy8gdW5peFxuICAgICAgICBjYXNlIDc3NzogLy8gbWVtb3J5XG4gICAgICAgICAgICByZXR1cm4gc3RyMmJ5dGVzKHN0cik7XG4gICAgICAgIGNhc2UgNDIxOiAvLyBpcGZzXG4gICAgICAgICAgICByZXR1cm4gbWgyYnl0ZXMoc3RyKTtcbiAgICAgICAgY2FzZSA0NDQ6IC8vIG9uaW9uXG4gICAgICAgICAgICByZXR1cm4gb25pb24yYnl0ZXMoc3RyKTtcbiAgICAgICAgY2FzZSA0NDU6IC8vIG9uaW9uM1xuICAgICAgICAgICAgcmV0dXJuIG9uaW9uMzJieXRlcyhzdHIpO1xuICAgICAgICBjYXNlIDQ2NjogLy8gY2VydGhhc2hcbiAgICAgICAgICAgIHJldHVybiBtYjJieXRlcyhzdHIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKHN0ciwgJ2Jhc2UxNicpOyAvLyBubyBjbHVlLiBjb252ZXJ0IGZyb20gaGV4XG4gICAgfVxufVxuY29uc3QgZGVjb2RlcnMgPSBPYmplY3QudmFsdWVzKGJhc2VzKS5tYXAoKGMpID0+IGMuZGVjb2Rlcik7XG5jb25zdCBhbnliYXNlRGVjb2RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGFjYyA9IGRlY29kZXJzWzBdLm9yKGRlY29kZXJzWzFdKTtcbiAgICBkZWNvZGVycy5zbGljZSgyKS5mb3JFYWNoKChkKSA9PiAoYWNjID0gYWNjLm9yKGQpKSk7XG4gICAgcmV0dXJuIGFjYztcbn0pKCk7XG5mdW5jdGlvbiBpcDJieXRlcyhpcFN0cmluZykge1xuICAgIGlmICghaXAuaXNJUChpcFN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlwIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlwLnRvQnl0ZXMoaXBTdHJpbmcpO1xufVxuZnVuY3Rpb24gYnl0ZXMyaXAoaXBCdWZmKSB7XG4gICAgY29uc3QgaXBTdHJpbmcgPSBpcC50b1N0cmluZyhpcEJ1ZmYsIDAsIGlwQnVmZi5sZW5ndGgpO1xuICAgIGlmIChpcFN0cmluZyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXBCdWZmIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghaXAuaXNJUChpcFN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlwIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlwU3RyaW5nO1xufVxuZnVuY3Rpb24gcG9ydDJieXRlcyhwb3J0KSB7XG4gICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDIpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmKTtcbiAgICB2aWV3LnNldFVpbnQxNigwLCBwb3J0KTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzMnBvcnQoYnVmKSB7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyKTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MTYoYnVmLmJ5dGVPZmZzZXQpO1xufVxuZnVuY3Rpb24gc3RyMmJ5dGVzKHN0cikge1xuICAgIGNvbnN0IGJ1ZiA9IHVpbnQ4QXJyYXlGcm9tU3RyaW5nKHN0cik7XG4gICAgY29uc3Qgc2l6ZSA9IFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKGJ1Zi5sZW5ndGgpKTtcbiAgICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbc2l6ZSwgYnVmXSwgc2l6ZS5sZW5ndGggKyBidWYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzMnN0cihidWYpIHtcbiAgICBjb25zdCBzaXplID0gdmFyaW50LmRlY29kZShidWYpO1xuICAgIGJ1ZiA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKTtcbiAgICBpZiAoYnVmLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBsZW5ndGhzJyk7XG4gICAgfVxuICAgIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYnVmKTtcbn1cbmZ1bmN0aW9uIG1oMmJ5dGVzKGhhc2gpIHtcbiAgICBsZXQgbWg7XG4gICAgaWYgKGhhc2hbMF0gPT09ICdRJyB8fCBoYXNoWzBdID09PSAnMScpIHtcbiAgICAgICAgbWggPSBEaWdlc3QuZGVjb2RlKGJhc2U1OGJ0Yy5kZWNvZGUoYHoke2hhc2h9YCkpLmJ5dGVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWggPSBDSUQucGFyc2UoaGFzaCkubXVsdGloYXNoLmJ5dGVzO1xuICAgIH1cbiAgICAvLyB0aGUgYWRkcmVzcyBpcyBhIHZhcmludCBwcmVmaXhlZCBtdWx0aWhhc2ggc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgY29uc3Qgc2l6ZSA9IFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKG1oLmxlbmd0aCkpO1xuICAgIHJldHVybiB1aW50OEFycmF5Q29uY2F0KFtzaXplLCBtaF0sIHNpemUubGVuZ3RoICsgbWgubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIG1iMmJ5dGVzKG1ic3RyKSB7XG4gICAgY29uc3QgbWIgPSBhbnliYXNlRGVjb2Rlci5kZWNvZGUobWJzdHIpO1xuICAgIGNvbnN0IHNpemUgPSBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZShtYi5sZW5ndGgpKTtcbiAgICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbc2l6ZSwgbWJdLCBzaXplLmxlbmd0aCArIG1iLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBieXRlczJtYihidWYpIHtcbiAgICBjb25zdCBzaXplID0gdmFyaW50LmRlY29kZShidWYpO1xuICAgIGNvbnN0IGhhc2ggPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcyk7XG4gICAgaWYgKGhhc2gubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IGxlbmd0aHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICd1JyArIHVpbnQ4QXJyYXlUb1N0cmluZyhoYXNoLCAnYmFzZTY0dXJsJyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIGJhczU4YnRjIHN0cmluZ1xuICovXG5mdW5jdGlvbiBieXRlczJtaChidWYpIHtcbiAgICBjb25zdCBzaXplID0gdmFyaW50LmRlY29kZShidWYpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcyk7XG4gICAgaWYgKGFkZHJlc3MubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IGxlbmd0aHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhhZGRyZXNzLCAnYmFzZTU4YnRjJyk7XG59XG5mdW5jdGlvbiBvbmlvbjJieXRlcyhzdHIpIHtcbiAgICBjb25zdCBhZGRyID0gc3RyLnNwbGl0KCc6Jyk7XG4gICAgaWYgKGFkZHIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIHBhcnNlIG9uaW9uIGFkZHI6IFtcIicke2FkZHIuam9pbignXCIsIFwiJyl9J1wiXScgZG9lcyBub3QgY29udGFpbiBhIHBvcnQgbnVtYmVyYCk7XG4gICAgfVxuICAgIGlmIChhZGRyWzBdLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gcGFyc2Ugb25pb24gYWRkcjogJHthZGRyWzBdfSBub3QgYSBUb3Igb25pb24gYWRkcmVzcy5gKTtcbiAgICB9XG4gICAgLy8gb25pb24gYWRkcmVzc2VzIGRvIG5vdCBpbmNsdWRlIHRoZSBtdWx0aWJhc2UgcHJlZml4LCBhZGQgaXQgYmVmb3JlIGRlY29kaW5nXG4gICAgY29uc3QgYnVmID0gYmFzZTMyLmRlY29kZSgnYicgKyBhZGRyWzBdKTtcbiAgICAvLyBvbmlvbiBwb3J0IG51bWJlclxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChhZGRyWzFdLCAxMCk7XG4gICAgaWYgKHBvcnQgPCAxIHx8IHBvcnQgPiA2NTUzNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgbnVtYmVyIGlzIG5vdCBpbiByYW5nZSgxLCA2NTUzNiknKTtcbiAgICB9XG4gICAgY29uc3QgcG9ydEJ1ZiA9IHBvcnQyYnl0ZXMocG9ydCk7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW2J1ZiwgcG9ydEJ1Zl0sIGJ1Zi5sZW5ndGggKyBwb3J0QnVmLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBvbmlvbjMyYnl0ZXMoc3RyKSB7XG4gICAgY29uc3QgYWRkciA9IHN0ci5zcGxpdCgnOicpO1xuICAgIGlmIChhZGRyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBwYXJzZSBvbmlvbiBhZGRyOiBbXCInJHthZGRyLmpvaW4oJ1wiLCBcIicpfSdcIl0nIGRvZXMgbm90IGNvbnRhaW4gYSBwb3J0IG51bWJlcmApO1xuICAgIH1cbiAgICBpZiAoYWRkclswXS5sZW5ndGggIT09IDU2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIHBhcnNlIG9uaW9uIGFkZHI6ICR7YWRkclswXX0gbm90IGEgVG9yIG9uaW9uMyBhZGRyZXNzLmApO1xuICAgIH1cbiAgICAvLyBvbmlvbiBhZGRyZXNzZXMgZG8gbm90IGluY2x1ZGUgdGhlIG11bHRpYmFzZSBwcmVmaXgsIGFkZCBpdCBiZWZvcmUgZGVjb2RpbmdcbiAgICBjb25zdCBidWYgPSBiYXNlMzIuZGVjb2RlKGBiJHthZGRyWzBdfWApO1xuICAgIC8vIG9uaW9uIHBvcnQgbnVtYmVyXG4gICAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGFkZHJbMV0sIDEwKTtcbiAgICBpZiAocG9ydCA8IDEgfHwgcG9ydCA+IDY1NTM2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBudW1iZXIgaXMgbm90IGluIHJhbmdlKDEsIDY1NTM2KScpO1xuICAgIH1cbiAgICBjb25zdCBwb3J0QnVmID0gcG9ydDJieXRlcyhwb3J0KTtcbiAgICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbYnVmLCBwb3J0QnVmXSwgYnVmLmxlbmd0aCArIHBvcnRCdWYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzMm9uaW9uKGJ1Zikge1xuICAgIGNvbnN0IGFkZHJCeXRlcyA9IGJ1Zi5zbGljZSgwLCBidWYubGVuZ3RoIC0gMik7XG4gICAgY29uc3QgcG9ydEJ5dGVzID0gYnVmLnNsaWNlKGJ1Zi5sZW5ndGggLSAyKTtcbiAgICBjb25zdCBhZGRyID0gdWludDhBcnJheVRvU3RyaW5nKGFkZHJCeXRlcywgJ2Jhc2UzMicpO1xuICAgIGNvbnN0IHBvcnQgPSBieXRlczJwb3J0KHBvcnRCeXRlcyk7XG4gICAgcmV0dXJuIGAke2FkZHJ9OiR7cG9ydH1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydC5qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0RlZmF1bHRNdWx0aWFkZHJfc3RyaW5nLCBfRGVmYXVsdE11bHRpYWRkcl90dXBsZXMsIF9EZWZhdWx0TXVsdGlhZGRyX3N0cmluZ1R1cGxlcywgX2E7XG5pbXBvcnQgKiBhcyBjb2RlYyBmcm9tICcuL2NvZGVjLmpzJztcbmltcG9ydCB7IGdldFByb3RvY29sLCBuYW1lcyB9IGZyb20gJy4vcHJvdG9jb2xzLXRhYmxlLmpzJztcbmltcG9ydCB2YXJpbnQgZnJvbSAndmFyaW50JztcbmltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgYmFzZTU4YnRjIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jhc2VzL2Jhc2U1OCc7XG5pbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnO1xuaW1wb3J0IHsgZXF1YWxzIGFzIHVpbnQ4QXJyYXlFcXVhbHMgfSBmcm9tICd1aW50OGFycmF5cy9lcXVhbHMnO1xuY29uc3QgaW5zcGVjdCA9IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyk7XG5jb25zdCBETlNfQ09ERVMgPSBbXG4gICAgZ2V0UHJvdG9jb2woJ2RucycpLmNvZGUsXG4gICAgZ2V0UHJvdG9jb2woJ2RuczQnKS5jb2RlLFxuICAgIGdldFByb3RvY29sKCdkbnM2JykuY29kZSxcbiAgICBnZXRQcm90b2NvbCgnZG5zYWRkcicpLmNvZGVcbl07XG5jb25zdCBQMlBfQ09ERVMgPSBbXG4gICAgZ2V0UHJvdG9jb2woJ3AycCcpLmNvZGUsXG4gICAgZ2V0UHJvdG9jb2woJ2lwZnMnKS5jb2RlXG5dO1xuZXhwb3J0IGNvbnN0IHJlc29sdmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ0BtdWx0aWZvcm1hdHMvanMtbXVsdGlhZGRyL211bHRpYWRkcicpO1xuLyoqXG4gKiBDcmVhdGVzIGEgTXVsdGlhZGRyIGZyb20gYSBub2RlLWZyaWVuZGx5IGFkZHJlc3Mgb2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBNdWx0aWFkZHIuZnJvbU5vZGVBZGRyZXNzKHthZGRyZXNzOiAnMTI3LjAuMC4xJywgcG9ydDogJzQwMDEnfSwgJ3RjcCcpXG4gKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU5vZGVBZGRyZXNzKGFkZHIsIHRyYW5zcG9ydCkge1xuICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBub2RlIGFkZHJlc3Mgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICh0cmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIHRyYW5zcG9ydCBwcm90b2NvbCcpO1xuICAgIH1cbiAgICBsZXQgaXA7XG4gICAgc3dpdGNoIChhZGRyLmZhbWlseSkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpcCA9ICdpcDQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlwID0gJ2lwNic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGFkZHIgZmFtaWx5LCBzaG91bGQgYmUgNCBvciA2LicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERlZmF1bHRNdWx0aWFkZHIoJy8nICsgW2lwLCBhZGRyLmFkZHJlc3MsIHRyYW5zcG9ydCwgYWRkci5wb3J0XS5qb2luKCcvJykpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIHNvbWV0aGluZyBpcyBhIE11bHRpYWRkciB0aGF0IGlzIGEgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lKGFkZHIpIHtcbiAgICBpZiAoIWlzTXVsdGlhZGRyKGFkZHIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaWYgYSBwYXJ0IG9mIHRoZSBtdWx0aWFkZHIgaXMgcmVzb2x2YWJsZSwgdGhlbiByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBhZGRyLnByb3RvcygpLnNvbWUoKHByb3RvKSA9PiBwcm90by5yZXNvbHZhYmxlKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgb2JqZWN0IGlzIGEgQ0lEIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc011bHRpYWRkcih2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlPy5bc3ltYm9sXSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBbbXVsdGlhZGRyXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkcikgZnJvbVxuICogYSBVaW50OEFycmF5LCBTdHJpbmcgb3IgYW5vdGhlciBNdWx0aWFkZHIgaW5zdGFuY2VcbiAqIHB1YmxpYyBrZXkuXG4gKlxuICovXG5jbGFzcyBEZWZhdWx0TXVsdGlhZGRyIHtcbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICAgICAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtNdWx0aWFkZHJJbnB1dH0gW2FkZHJdIC0gSWYgU3RyaW5nIG9yIFVpbnQ4QXJyYXksIG5lZWRzIHRvIGFkaGVyZSB0byB0aGUgYWRkcmVzcyBmb3JtYXQgb2YgYSBbbXVsdGlhZGRyXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkciNzdHJpbmctZm9ybWF0KVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHIpIHtcbiAgICAgICAgX0RlZmF1bHRNdWx0aWFkZHJfc3RyaW5nLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRGVmYXVsdE11bHRpYWRkcl90dXBsZXMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9EZWZhdWx0TXVsdGlhZGRyX3N0cmluZ1R1cGxlcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBjb2RlYy5mcm9tQnl0ZXMoYWRkcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFkZHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoYWRkci5sZW5ndGggPiAwICYmIGFkZHIuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpYWRkciBcIiR7YWRkcn1cIiBtdXN0IHN0YXJ0IHdpdGggYSBcIi9cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IGNvZGVjLmZyb21TdHJpbmcoYWRkcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNdWx0aWFkZHIoYWRkcikpIHsgLy8gTXVsdGlhZGRyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gY29kZWMuZnJvbUJ5dGVzKGFkZHIuYnl0ZXMpOyAvLyB2YWxpZGF0ZSArIGNvcHkgYnVmZmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHIgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBvciBhbm90aGVyIE11bHRpYWRkcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRGVmYXVsdE11bHRpYWRkcl9zdHJpbmcsIFwiZlwiKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9EZWZhdWx0TXVsdGlhZGRyX3N0cmluZywgY29kZWMuYnl0ZXNUb1N0cmluZyh0aGlzLmJ5dGVzKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9EZWZhdWx0TXVsdGlhZGRyX3N0cmluZywgXCJmXCIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgY29kZXMgPSB0aGlzLnByb3RvQ29kZXMoKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRyYW5zcG9ydDtcbiAgICAgICAgbGV0IHBvcnQ7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGh0dHBzIHdoZW4gcHJvdG9jb2wgJiBwb3J0IGFyZSBvbWl0dGVkIGZyb20gRE5TIGFkZHJzXG4gICAgICAgICAgICBpZiAoRE5TX0NPREVTLmluY2x1ZGVzKGNvZGVzWzBdKSAmJiBQMlBfQ09ERVMuaW5jbHVkZXMoY29kZXNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gZ2V0UHJvdG9jb2woJ3RjcCcpLm5hbWU7XG4gICAgICAgICAgICAgICAgcG9ydCA9IDQ0MztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IGdldFByb3RvY29sKHBhcnRzWzJdKS5uYW1lO1xuICAgICAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwYXJ0c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoRE5TX0NPREVTLmluY2x1ZGVzKGNvZGVzWzBdKSkge1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gZ2V0UHJvdG9jb2woJ3RjcCcpLm5hbWU7XG4gICAgICAgICAgICBwb3J0ID0gNDQzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWFkZHIgbXVzdCBoYXZlIGEgdmFsaWQgZm9ybWF0OiBcIi97aXA0LCBpcDYsIGRuczQsIGRuczYsIGRuc2FkZHJ9L3thZGRyZXNzfS97dGNwLCB1ZHB9L3twb3J0fVwiLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICBmYW1pbHk6IChjb2Rlc1swXSA9PT0gNDEgfHwgY29kZXNbMF0gPT09IDU1KSA/IDYgOiA0LFxuICAgICAgICAgICAgaG9zdDogcGFydHNbMV0sXG4gICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICBwb3J0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgICBwcm90b3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvQ29kZXMoKS5tYXAoY29kZSA9PiBPYmplY3QuYXNzaWduKHt9LCBnZXRQcm90b2NvbChjb2RlKSkpO1xuICAgIH1cbiAgICBwcm90b0NvZGVzKCkge1xuICAgICAgICBjb25zdCBjb2RlcyA9IFtdO1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLmJ5dGVzO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB2YXJpbnQuZGVjb2RlLmJ5dGVzO1xuICAgICAgICAgICAgY29uc3QgcCA9IGdldFByb3RvY29sKGNvZGUpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGNvZGVjLnNpemVGb3JBZGRyKHAsIGJ1Zi5zbGljZShpICsgbikpO1xuICAgICAgICAgICAgaSArPSAoc2l6ZSArIG4pO1xuICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfVxuICAgIHByb3RvTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvcygpLm1hcChwcm90byA9PiBwcm90by5uYW1lKTtcbiAgICB9XG4gICAgdHVwbGVzKCkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRGVmYXVsdE11bHRpYWRkcl90dXBsZXMsIFwiZlwiKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9EZWZhdWx0TXVsdGlhZGRyX3R1cGxlcywgY29kZWMuYnl0ZXNUb1R1cGxlcyh0aGlzLmJ5dGVzKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9EZWZhdWx0TXVsdGlhZGRyX3R1cGxlcywgXCJmXCIpO1xuICAgIH1cbiAgICBzdHJpbmdUdXBsZXMoKSB7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9EZWZhdWx0TXVsdGlhZGRyX3N0cmluZ1R1cGxlcywgXCJmXCIpID09IG51bGwpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0RlZmF1bHRNdWx0aWFkZHJfc3RyaW5nVHVwbGVzLCBjb2RlYy50dXBsZXNUb1N0cmluZ1R1cGxlcyh0aGlzLnR1cGxlcygpKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9EZWZhdWx0TXVsdGlhZGRyX3N0cmluZ1R1cGxlcywgXCJmXCIpO1xuICAgIH1cbiAgICBlbmNhcHN1bGF0ZShhZGRyKSB7XG4gICAgICAgIGFkZHIgPSBuZXcgRGVmYXVsdE11bHRpYWRkcihhZGRyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0TXVsdGlhZGRyKHRoaXMudG9TdHJpbmcoKSArIGFkZHIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGRlY2Fwc3VsYXRlKGFkZHIpIHtcbiAgICAgICAgY29uc3QgYWRkclN0cmluZyA9IGFkZHIudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgaSA9IHMubGFzdEluZGV4T2YoYWRkclN0cmluZyk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7dGhpcy50b1N0cmluZygpfSBkb2VzIG5vdCBjb250YWluIHN1YmFkZHJlc3M6ICR7YWRkci50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdE11bHRpYWRkcihzLnNsaWNlKDAsIGkpKTtcbiAgICB9XG4gICAgZGVjYXBzdWxhdGVDb2RlKGNvZGUpIHtcbiAgICAgICAgY29uc3QgdHVwbGVzID0gdGhpcy50dXBsZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHR1cGxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHR1cGxlc1tpXVswXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdE11bHRpYWRkcihjb2RlYy50dXBsZXNUb0J5dGVzKHR1cGxlcy5zbGljZSgwLCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRQZWVySWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0dXBsZXMgPSB0aGlzLnN0cmluZ1R1cGxlcygpLmZpbHRlcigodHVwbGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHVwbGVbMF0gPT09IG5hbWVzLmlwZnMuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxhc3QgaXBmcyB0dXBsZSBbJ2lwZnMnLCAncGVlcmlkIHN0cmluZyddXG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IHR1cGxlcy5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0dXBsZT8uWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZWVySWRTdHIgPSB0dXBsZVsxXTtcbiAgICAgICAgICAgICAgICAvLyBwZWVyIGlkIGlzIGJhc2U1OGJ0YyBlbmNvZGVkIHN0cmluZyBidXQgbm90IG11bHRpYmFzZSBlbmNvZGVkIHNvIGFkZCB0aGUgYHpgXG4gICAgICAgICAgICAgICAgLy8gcHJlZml4IHNvIHdlIGNhbiB2YWxpZGF0ZSB0aGF0IGl0IGlzIGNvcnJlY3RseSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgaWYgKHBlZXJJZFN0clswXSA9PT0gJ1EnIHx8IHBlZXJJZFN0clswXSA9PT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYmFzZTU4YnRjLmRlY29kZShgeiR7cGVlcklkU3RyfWApLCAnYmFzZTU4YnRjJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwYXJzZSBwZWVyIGlkIGFzIENJRFxuICAgICAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoQ0lELnBhcnNlKHBlZXJJZFN0cikubXVsdGloYXNoLmJ5dGVzLCAnYmFzZTU4YnRjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGF0aCA9IHRoaXMuc3RyaW5nVHVwbGVzKCkuZmlsdGVyKCh0dXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG9jb2wodHVwbGVbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm90by5wYXRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KVswXVsxXTtcbiAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBwYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgZXF1YWxzKGFkZHIpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlFcXVhbHModGhpcy5ieXRlcywgYWRkci5ieXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXNvbHZhYmxlUHJvdG8gPSB0aGlzLnByb3RvcygpLmZpbmQoKHApID0+IHAucmVzb2x2YWJsZSk7XG4gICAgICAgIC8vIE11bHRpYWRkciBpcyBub3QgcmVzb2x2YWJsZT9cbiAgICAgICAgaWYgKHJlc29sdmFibGVQcm90byA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gcmVzb2x2ZXJzLmdldChyZXNvbHZhYmxlUHJvdG8ubmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIHJlc29sdmVyIGZvciAke3Jlc29sdmFibGVQcm90by5uYW1lfWApLCAnRVJSX05PX0FWQUlMQUJMRV9SRVNPTFZFUicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHJlc29sdmVyKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYWRkcmVzc2VzLm1hcCgoYSkgPT4gbmV3IERlZmF1bHRNdWx0aWFkZHIoYSkpO1xuICAgIH1cbiAgICBub2RlQWRkcmVzcygpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMudG9PcHRpb25zKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydCAhPT0gJ3RjcCcgJiYgb3B0aW9ucy50cmFuc3BvcnQgIT09ICd1ZHAnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpYWRkciBtdXN0IGhhdmUgYSB2YWxpZCBmb3JtYXQgLSBubyBwcm90b2NvbCB3aXRoIG5hbWU6IFwiJHtvcHRpb25zLnRyYW5zcG9ydH1cIi4gTXVzdCBoYXZlIGEgdmFsaWQgdHJhbnNwb3J0IHByb3RvY29sOiBcInt0Y3AsIHVkcH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmYW1pbHk6IG9wdGlvbnMuZmFtaWx5LFxuICAgICAgICAgICAgYWRkcmVzczogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzVGhpbldhaXN0QWRkcmVzcyhhZGRyKSB7XG4gICAgICAgIGNvbnN0IHByb3RvcyA9IChhZGRyID8/IHRoaXMpLnByb3RvcygpO1xuICAgICAgICBpZiAocHJvdG9zLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90b3NbMF0uY29kZSAhPT0gNCAmJiBwcm90b3NbMF0uY29kZSAhPT0gNDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdG9zWzFdLmNvZGUgIT09IDYgJiYgcHJvdG9zWzFdLmNvZGUgIT09IDI3Mykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbiAgICAgKiBGb3IgcG9zdCBOb2RlLmpzIHYxMC4wLjAuXG4gICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kZXByZWNhdGlvbnMuaHRtbCNkZXByZWNhdGlvbnNfZGVwMDA3OV9jdXN0b21faW5zcGVjdGlvbl9mdW5jdGlvbl9vbl9vYmplY3RzX3ZpYV9pbnNwZWN0XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc29sZS5sb2cobmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKSlcbiAgICAgKiAvLyAnPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+J1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFsoX0RlZmF1bHRNdWx0aWFkZHJfc3RyaW5nID0gbmV3IFdlYWtNYXAoKSwgX0RlZmF1bHRNdWx0aWFkZHJfdHVwbGVzID0gbmV3IFdlYWtNYXAoKSwgX0RlZmF1bHRNdWx0aWFkZHJfc3RyaW5nVHVwbGVzID0gbmV3IFdlYWtNYXAoKSwgX2EgPSBzeW1ib2wsIGluc3BlY3QpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gJzxNdWx0aWFkZHIgJyArXG4gICAgICAgICAgICB1aW50OEFycmF5VG9TdHJpbmcodGhpcy5ieXRlcywgJ2Jhc2UxNicpICsgJyAtICcgK1xuICAgICAgICAgICAgY29kZWMuYnl0ZXNUb1N0cmluZyh0aGlzLmJ5dGVzKSArICc+JztcbiAgICB9XG59XG4vKipcbiAqIFN0YXRpYyBmYWN0b3J5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpXG4gKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TXVsdGlhZGRySW5wdXR9IFthZGRyXSAtIElmIFN0cmluZyBvciBVaW50OEFycmF5LCBuZWVkcyB0byBhZGhlcmUgdG8gdGhlIGFkZHJlc3MgZm9ybWF0IG9mIGEgW211bHRpYWRkcl0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIjc3RyaW5nLWZvcm1hdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpYWRkcihhZGRyKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0TXVsdGlhZGRyKGFkZHIpO1xufVxuZXhwb3J0IHsgZ2V0UHJvdG9jb2wgYXMgcHJvdG9jb2xzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBpc0lQdjQsIGlzSVB2NiB9IGZyb20gJ2lzLWlwJztcbmltcG9ydCB7IHRvU3RyaW5nIGFzIHVpbnQ4QXJyYXlUb1N0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZyc7XG5leHBvcnQgeyBpc0lQIH0gZnJvbSAnaXMtaXAnO1xuZXhwb3J0IGNvbnN0IGlzVjQgPSBpc0lQdjQ7XG5leHBvcnQgY29uc3QgaXNWNiA9IGlzSVB2Njtcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L25vZGUtaXAvYmxvYi9tYXN0ZXIvbGliL2lwLmpzI0w3XG4vLyBidXQgd2l0aCBidWYvb2Zmc2V0IGFyZ3MgcmVtb3ZlZCBiZWNhdXNlIHdlIGRvbid0IHVzZSB0aGVtXG5leHBvcnQgY29uc3QgdG9CeXRlcyA9IGZ1bmN0aW9uIChpcCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlwID0gaXAudG9TdHJpbmcoKS50cmltKCk7XG4gICAgaWYgKGlzVjQoaXApKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkob2Zmc2V0ICsgNCk7XG4gICAgICAgIGlwLnNwbGl0KC9cXC4vZykuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gcGFyc2VJbnQoYnl0ZSwgMTApICYgMHhmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgaWYgKGlzVjYoaXApKSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gaXAuc3BsaXQoJzonLCA4KTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXN2NCA9IGlzVjQoc2VjdGlvbnNbaV0pO1xuICAgICAgICAgICAgbGV0IHY0QnVmZmVyO1xuICAgICAgICAgICAgaWYgKGlzdjQpIHtcbiAgICAgICAgICAgICAgICB2NEJ1ZmZlciA9IHRvQnl0ZXMoc2VjdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gdWludDhBcnJheVRvU3RyaW5nKHY0QnVmZmVyLnNsaWNlKDAsIDIpLCAnYmFzZTE2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodjRCdWZmZXIgIT0gbnVsbCAmJiArK2kgPCA4KSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMuc3BsaWNlKGksIDAsIHVpbnQ4QXJyYXlUb1N0cmluZyh2NEJ1ZmZlci5zbGljZSgyLCA0KSwgJ2Jhc2UxNicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbnNbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VjdGlvbnMubGVuZ3RoIDwgOClcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy51bnNoaWZ0KCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VjdGlvbnMubGVuZ3RoIDwgOClcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VjdGlvbnMubGVuZ3RoIDwgOCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aCAmJiBzZWN0aW9uc1tpXSAhPT0gJyc7IGkrKylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBjb25zdCBhcmd2ID0gW2ksIDFdO1xuICAgICAgICAgICAgZm9yIChpID0gOSAtIHNlY3Rpb25zLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3YucHVzaCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VjdGlvbnMuc3BsaWNlLmFwcGx5KHNlY3Rpb25zLCBhcmd2KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KG9mZnNldCArIDE2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gcGFyc2VJbnQoc2VjdGlvbnNbaV0sIDE2KTtcbiAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IHdvcmQgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlwIGFkZHJlc3MnKTtcbn07XG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ub2RlLWlwL2Jsb2IvbWFzdGVyL2xpYi9pcC5qcyNMNjNcbmV4cG9ydCBjb25zdCB0b1N0cmluZyA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCA9IDAsIGxlbmd0aCkge1xuICAgIG9mZnNldCA9IH5+b2Zmc2V0O1xuICAgIGxlbmd0aCA9IGxlbmd0aCA/PyAoYnVmLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyKTtcbiAgICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBJUHY0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ1ZltvZmZzZXQgKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IDE2KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBJUHY2XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZpZXcuZ2V0VWludDE2KG9mZnNldCArIGkpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCc6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXnw6KTAoOjApKjowKDp8JCkvLCAnJDE6OiQzJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC86ezMsNH0vLCAnOjonKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlwLmpzLm1hcCIsImNvbnN0IFYgPSAtMTtcbmV4cG9ydCBjb25zdCBuYW1lcyA9IHt9O1xuZXhwb3J0IGNvbnN0IGNvZGVzID0ge307XG5leHBvcnQgY29uc3QgdGFibGUgPSBbXG4gICAgWzQsIDMyLCAnaXA0J10sXG4gICAgWzYsIDE2LCAndGNwJ10sXG4gICAgWzMzLCAxNiwgJ2RjY3AnXSxcbiAgICBbNDEsIDEyOCwgJ2lwNiddLFxuICAgIFs0MiwgViwgJ2lwNnpvbmUnXSxcbiAgICBbNTMsIFYsICdkbnMnLCB0cnVlXSxcbiAgICBbNTQsIFYsICdkbnM0JywgdHJ1ZV0sXG4gICAgWzU1LCBWLCAnZG5zNicsIHRydWVdLFxuICAgIFs1NiwgViwgJ2Ruc2FkZHInLCB0cnVlXSxcbiAgICBbMTMyLCAxNiwgJ3NjdHAnXSxcbiAgICBbMjczLCAxNiwgJ3VkcCddLFxuICAgIFsyNzUsIDAsICdwMnAtd2VicnRjLXN0YXInXSxcbiAgICBbMjc2LCAwLCAncDJwLXdlYnJ0Yy1kaXJlY3QnXSxcbiAgICBbMjc3LCAwLCAncDJwLXN0YXJkdXN0J10sXG4gICAgWzI4MCwgMCwgJ3dlYnJ0YyddLFxuICAgIFsyOTAsIDAsICdwMnAtY2lyY3VpdCddLFxuICAgIFszMDEsIDAsICd1ZHQnXSxcbiAgICBbMzAyLCAwLCAndXRwJ10sXG4gICAgWzQwMCwgViwgJ3VuaXgnLCBmYWxzZSwgdHJ1ZV0sXG4gICAgLy8gYGlwZnNgIGlzIGFkZGVkIGJlZm9yZSBgcDJwYCBmb3IgbGVnYWN5IHN1cHBvcnQuXG4gICAgLy8gQWxsIHRleHQgcmVwcmVzZW50YXRpb25zIHdpbGwgZGVmYXVsdCB0byBgcDJwYCwgYnV0IGBpcGZzYCB3aWxsXG4gICAgLy8gc3RpbGwgYmUgc3VwcG9ydGVkXG4gICAgWzQyMSwgViwgJ2lwZnMnXSxcbiAgICAvLyBgcDJwYCBpcyB0aGUgcHJlZmVycmVkIG5hbWUgZm9yIDQyMSwgYW5kIGlzIG5vdyB0aGUgZGVmYXVsdFxuICAgIFs0MjEsIFYsICdwMnAnXSxcbiAgICBbNDQzLCAwLCAnaHR0cHMnXSxcbiAgICBbNDQ0LCA5NiwgJ29uaW9uJ10sXG4gICAgWzQ0NSwgMjk2LCAnb25pb24zJ10sXG4gICAgWzQ0NiwgViwgJ2dhcmxpYzY0J10sXG4gICAgWzQ2MCwgMCwgJ3F1aWMnXSxcbiAgICBbNDY1LCAwLCAnd2VidHJhbnNwb3J0J10sXG4gICAgWzQ2NiwgViwgJ2NlcnRoYXNoJ10sXG4gICAgWzQ3NywgMCwgJ3dzJ10sXG4gICAgWzQ3OCwgMCwgJ3dzcyddLFxuICAgIFs0NzksIDAsICdwMnAtd2Vic29ja2V0LXN0YXInXSxcbiAgICBbNDgwLCAwLCAnaHR0cCddLFxuICAgIFs3NzcsIFYsICdtZW1vcnknXVxuXTtcbi8vIHBvcHVsYXRlIHRhYmxlc1xudGFibGUuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gY3JlYXRlUHJvdG9jb2woLi4ucm93KTtcbiAgICBjb2Rlc1twcm90by5jb2RlXSA9IHByb3RvO1xuICAgIG5hbWVzW3Byb3RvLm5hbWVdID0gcHJvdG87XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm90b2NvbChjb2RlLCBzaXplLCBuYW1lLCByZXNvbHZhYmxlLCBwYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmVzb2x2YWJsZTogQm9vbGVhbihyZXNvbHZhYmxlKSxcbiAgICAgICAgcGF0aDogQm9vbGVhbihwYXRoKVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvdG9jb2wocHJvdG8pIHtcbiAgICBpZiAodHlwZW9mIHByb3RvID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoY29kZXNbcHJvdG9dICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2Rlc1twcm90b107XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBwcm90b2NvbCB3aXRoIGNvZGU6ICR7cHJvdG99YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwcm90byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG5hbWVzW3Byb3RvXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNbcHJvdG9dO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gcHJvdG9jb2wgd2l0aCBuYW1lOiAke3Byb3RvfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJvdG9jb2wgaWQgdHlwZTogJHt0eXBlb2YgcHJvdG99YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm90b2NvbHMtdGFibGUuanMubWFwIiwiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnXG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuLi9ieXRlcy5qcydcbi8vIExpbnRlciBjYW4ndCBzZWUgdGhhdCBBUEkgaXMgdXNlZCBpbiB0eXBlcy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW50ZXJmYWNlLmpzJ1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudHMgYm90aCBCYXNlRW5jb2RlciBhbmQgTXVsdGliYXNlRW5jb2RlciBtZWFuaW5nIGl0XG4gKiBjYW4gYmUgdXNlZCB0byBlbmNvZGUgdG8gbXVsdGliYXNlIG9yIGJhc2UgZW5jb2RlIHdpdGhvdXQgbXVsdGliYXNlXG4gKiBwcmVmaXguXG4gKlxuICogQGNsYXNzXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gQmFzZVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQGltcGxlbWVudHMge0FQSS5NdWx0aWJhc2VFbmNvZGVyPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLkJhc2VFbmNvZGVyfVxuICovXG5jbGFzcyBFbmNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZX0gbmFtZVxuICAgKiBAcGFyYW0ge1ByZWZpeH0gcHJlZml4XG4gICAqIEBwYXJhbSB7KGJ5dGVzOlVpbnQ4QXJyYXkpID0+IHN0cmluZ30gYmFzZUVuY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAqIEByZXR1cm5zIHtBUEkuTXVsdGliYXNlPFByZWZpeD59XG4gICAqL1xuICBlbmNvZGUgKGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7dGhpcy5iYXNlRW5jb2RlKGJ5dGVzKX1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqL1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRzIGJvdGggQmFzZURlY29kZXIgYW5kIE11bHRpYmFzZURlY29kZXIgc28gaXQgY291bGQgYmUgdXNlZFxuICogdG8gZGVjb2RlIG11bHRpYmFzZXMgKHdpdGggbWF0Y2hpbmcgcHJlZml4KSBvciBqdXN0IGJhc2UgZGVjb2RlIHN0cmluZ3NcbiAqIHdpdGggY29ycmVzcG9uZGluZyBiYXNlIGVuY29kaW5nLlxuICpcbiAqIEBjbGFzc1xuICogQHRlbXBsYXRlIHtzdHJpbmd9IEJhc2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBpbXBsZW1lbnRzIHtBUEkuTXVsdGliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5VbmliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlRGVjb2Rlcn1cbiAqL1xuY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2V9IG5hbWVcbiAgICogQHBhcmFtIHtQcmVmaXh9IHByZWZpeFxuICAgKiBAcGFyYW0geyh0ZXh0OnN0cmluZykgPT4gVWludDhBcnJheX0gYmFzZURlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocHJlZml4LmNvZGVQb2ludEF0KDApID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJylcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5wcmVmaXhDb2RlUG9pbnQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHByZWZpeC5jb2RlUG9pbnRBdCgwKSlcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGRlY29kZSAodGV4dCkge1xuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0ZXh0LmNvZGVQb2ludEF0KDApICE9PSB0aGlzLnByZWZpeENvZGVQb2ludCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkodGV4dCl9LCAke3RoaXMubmFtZX0gZGVjb2RlciBvbmx5IHN1cHBvcnRzIGlucHV0cyBwcmVmaXhlZCB3aXRoICR7dGhpcy5wcmVmaXh9YClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUodGV4dC5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtzdHJpbmd9IE90aGVyUHJlZml4XG4gICAqIEBwYXJhbSB7QVBJLlVuaWJhc2VEZWNvZGVyPE90aGVyUHJlZml4PnxDb21wb3NlZERlY29kZXI8T3RoZXJQcmVmaXg+fSBkZWNvZGVyXG4gICAqIEByZXR1cm5zIHtDb21wb3NlZERlY29kZXI8UHJlZml4fE90aGVyUHJlZml4Pn1cbiAgICovXG4gIG9yIChkZWNvZGVyKSB7XG4gICAgcmV0dXJuIG9yKHRoaXMsIGRlY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAdHlwZWRlZiB7UmVjb3JkPFByZWZpeCwgQVBJLlVuaWJhc2VEZWNvZGVyPFByZWZpeD4+fSBEZWNvZGVyc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQGltcGxlbWVudHMge0FQSS5NdWx0aWJhc2VEZWNvZGVyPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLkNvbWJvYmFzZURlY29kZXI8UHJlZml4Pn1cbiAqL1xuY2xhc3MgQ29tcG9zZWREZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVjb2RlcnM8UHJlZml4Pn0gZGVjb2RlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVycykge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBkZWNvZGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBPdGhlclByZWZpeFxuICAgKiBAcGFyYW0ge0FQSS5VbmliYXNlRGVjb2RlcjxPdGhlclByZWZpeD58Q29tcG9zZWREZWNvZGVyPE90aGVyUHJlZml4Pn0gZGVjb2RlclxuICAgKiBAcmV0dXJucyB7Q29tcG9zZWREZWNvZGVyPFByZWZpeHxPdGhlclByZWZpeD59XG4gICAqL1xuICBvciAoZGVjb2Rlcikge1xuICAgIHJldHVybiBvcih0aGlzLCBkZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGRlY29kZSAoaW5wdXQpIHtcbiAgICBjb25zdCBwcmVmaXggPSAvKiogQHR5cGUge1ByZWZpeH0gKi8gKGlucHV0WzBdKVxuICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLmRlY29kZXJzW3ByZWZpeF1cbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBSYW5nZUVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShpbnB1dCl9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5kZWNvZGVycyl9IGFyZSBzdXBwb3J0ZWRgKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBMXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICogQHBhcmFtIHtBUEkuVW5pYmFzZURlY29kZXI8TD58QVBJLkNvbWJvYmFzZURlY29kZXI8TD59IGxlZnRcbiAqIEBwYXJhbSB7QVBJLlVuaWJhc2VEZWNvZGVyPFI+fEFQSS5Db21ib2Jhc2VEZWNvZGVyPFI+fSByaWdodFxuICogQHJldHVybnMge0NvbXBvc2VkRGVjb2RlcjxMfFI+fVxuICovXG5leHBvcnQgY29uc3Qgb3IgPSAobGVmdCwgcmlnaHQpID0+IG5ldyBDb21wb3NlZERlY29kZXIoLyoqIEB0eXBlIHtEZWNvZGVyczxMfFI+fSAqLyh7XG4gIC4uLihsZWZ0LmRlY29kZXJzIHx8IHsgWy8qKiBAdHlwZSBBUEkuVW5pYmFzZURlY29kZXI8TD4gKi8obGVmdCkucHJlZml4XTogbGVmdCB9KSxcbiAgLi4uKHJpZ2h0LmRlY29kZXJzIHx8IHsgWy8qKiBAdHlwZSBBUEkuVW5pYmFzZURlY29kZXI8Uj4gKi8ocmlnaHQpLnByZWZpeF06IHJpZ2h0IH0pXG59KSlcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBCYXNlXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAaW1wbGVtZW50cyB7QVBJLk11bHRpYmFzZUNvZGVjPFByZWZpeD59XG4gKiBAaW1wbGVtZW50cyB7QVBJLk11bHRpYmFzZUVuY29kZXI8UHJlZml4Pn1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuTXVsdGliYXNlRGVjb2RlcjxQcmVmaXg+fVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlQ29kZWN9XG4gKiBAaW1wbGVtZW50cyB7QVBJLkJhc2VFbmNvZGVyfVxuICogQGltcGxlbWVudHMge0FQSS5CYXNlRGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVjIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZX0gbmFtZVxuICAgKiBAcGFyYW0ge1ByZWZpeH0gcHJlZml4XG4gICAqIEBwYXJhbSB7KGJ5dGVzOlVpbnQ4QXJyYXkpID0+IHN0cmluZ30gYmFzZUVuY29kZVxuICAgKiBAcGFyYW0geyh0ZXh0OnN0cmluZykgPT4gVWludDhBcnJheX0gYmFzZURlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSwgYmFzZURlY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGVcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlXG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlKVxuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gICAqL1xuICBlbmNvZGUgKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAqL1xuICBkZWNvZGUgKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5kZWNvZGUoaW5wdXQpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gQmFzZVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QmFzZX0gb3B0aW9ucy5uYW1lXG4gKiBAcGFyYW0ge1ByZWZpeH0gb3B0aW9ucy5wcmVmaXhcbiAqIEBwYXJhbSB7KGJ5dGVzOlVpbnQ4QXJyYXkpID0+IHN0cmluZ30gb3B0aW9ucy5lbmNvZGVcbiAqIEBwYXJhbSB7KGlucHV0OnN0cmluZykgPT4gVWludDhBcnJheX0gb3B0aW9ucy5kZWNvZGVcbiAqIEByZXR1cm5zIHtDb2RlYzxCYXNlLCBQcmVmaXg+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9ICh7IG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUgfSkgPT5cbiAgbmV3IENvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEJhc2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jhc2V9IG9wdGlvbnMubmFtZVxuICogQHBhcmFtIHtQcmVmaXh9IG9wdGlvbnMucHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hbHBoYWJldFxuICogQHJldHVybnMge0NvZGVjPEJhc2UsIFByZWZpeD59XG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlWCA9ICh7IHByZWZpeCwgbmFtZSwgYWxwaGFiZXQgfSkgPT4ge1xuICBjb25zdCB7IGVuY29kZSwgZGVjb2RlIH0gPSBiYXNleChhbHBoYWJldCwgbmFtZSlcbiAgcmV0dXJuIGZyb20oe1xuICAgIHByZWZpeCxcbiAgICBuYW1lLFxuICAgIGVuY29kZSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqL1xuICAgIGRlY29kZTogdGV4dCA9PiBjb2VyY2UoZGVjb2RlKHRleHQpKVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICAvLyBCdWlsZCB0aGUgY2hhcmFjdGVyIGxvb2t1cCB0YWJsZTpcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSAqL1xuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm9uLSR7bmFtZX0gY2hhcmFjdGVyYClcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJGQzQ2NDggRmFjdG9yeVxuICpcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBCYXNlXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUHJlZml4XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCYXNlfSBvcHRpb25zLm5hbWVcbiAqIEBwYXJhbSB7UHJlZml4fSBvcHRpb25zLnByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmJpdHNQZXJDaGFyXG4gKi9cbmV4cG9ydCBjb25zdCByZmM0NjQ4ID0gKHsgbmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXQgfSkgPT4ge1xuICByZXR1cm4gZnJvbSh7XG4gICAgcHJlZml4LFxuICAgIG5hbWUsXG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH0sXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyLCBuYW1lKVxuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IGJhc2VYIH0gZnJvbSAnLi9iYXNlLmpzJ1xuXG5leHBvcnQgY29uc3QgYmFzZTEwID0gYmFzZVgoe1xuICBwcmVmaXg6ICc5JyxcbiAgbmFtZTogJ2Jhc2UxMCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OSdcbn0pXG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdmJyxcbiAgbmFtZTogJ2Jhc2UxNicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTE2dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnRicsXG4gIG5hbWU6ICdiYXNlMTZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KVxuIiwiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnXG5cbmV4cG9ydCBjb25zdCBiYXNlMiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICcwJyxcbiAgbmFtZTogJ2Jhc2UyJyxcbiAgYWxwaGFiZXQ6ICcwMScsXG4gIGJpdHNQZXJDaGFyOiAxXG59KVxuIiwiaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vYmFzZS5qcydcblxuY29uc3QgYWxwaGFiZXQgPSBBcnJheS5mcm9tKCfwn5qA8J+qkOKYhPCfm7Dwn4yM8J+MkfCfjJLwn4yT8J+MlPCfjJXwn4yW8J+Ml/CfjJjwn4yN8J+Mj/CfjI7wn5CJ4piA8J+Su/CflqXwn5K+8J+Sv/CfmILinaTwn5iN8J+ko/CfmIrwn5mP8J+SlfCfmK3wn5iY8J+RjfCfmIXwn5GP8J+YgfCflKXwn6Ww8J+SlPCfkpbwn5KZ8J+YovCfpJTwn5iG8J+ZhPCfkqrwn5iJ4pi68J+RjPCfpJfwn5Kc8J+YlPCfmI7wn5iH8J+MufCfpKbwn46J8J+SnuKcjOKcqPCfpLfwn5ix8J+YjPCfjLjwn5mM8J+Yi/Cfkpfwn5Ka8J+Yj/Cfkpvwn5mC8J+Sk/CfpKnwn5iE8J+YgPCflqTwn5iD8J+Sr/CfmYjwn5GH8J+OtvCfmJLwn6St4p2j8J+YnPCfkovwn5GA8J+YqvCfmJHwn5Kl8J+Zi/CfmJ7wn5ip8J+YofCfpKrwn5GK8J+ls/CfmKXwn6Sk8J+RifCfkoPwn5iz4pyL8J+YmvCfmJ3wn5i08J+Mn/CfmKzwn5mD8J+NgPCfjLfwn5i78J+Yk+KtkOKchfCfpbrwn4yI8J+YiPCfpJjwn5Km4pyU8J+Yo/Cfj4Pwn5KQ4pi58J+OivCfkpjwn5ig4pid8J+YlfCfjLrwn46C8J+Mu/CfmJDwn5aV8J+SnfCfmYrwn5i58J+Xo/Cfkqvwn5KA8J+RkfCfjrXwn6Se8J+Ym/CflLTwn5ik8J+MvPCfmKvimr3wn6SZ4piV8J+PhvCfpKvwn5GI8J+YrvCfmYbwn4278J+Ng/CfkLbwn5KB8J+YsvCfjL/wn6eh8J+OgeKaofCfjJ7wn46I4p2M4pyK8J+Ri/CfmLDwn6So8J+YtvCfpJ3wn5q28J+SsPCfjZPwn5Ki8J+kn/CfmYHwn5qo8J+SqPCfpKzinIjwn46A8J+NuvCfpJPwn5iZ8J+Sn/CfjLHwn5iW8J+RtvCfpbTilrbinqHinZPwn5KO8J+SuOKsh/CfmKjwn4ya8J+mi/CfmLfwn5W64pqg8J+ZhfCfmJ/wn5i18J+RjvCfpLLwn6Sg8J+kp/Cfk4zwn5S18J+ShfCfp5Dwn5C+8J+NkvCfmJfwn6SR8J+MivCfpK/wn5C34piO8J+Sp/CfmK/wn5KG8J+RhvCfjqTwn5mH8J+NkeKdhPCfjLTwn5Kj8J+QuPCfkozwn5ON8J+lgPCfpKLwn5GF8J+SofCfkqnwn5GQ8J+TuPCfkbvwn6SQ8J+krvCfjrzwn6W18J+aqfCfjY7wn42K8J+RvPCfko3wn5Oj8J+lgicpXG5jb25zdCBhbHBoYWJldEJ5dGVzVG9DaGFycyA9IC8qKiBAdHlwZSB7c3RyaW5nW119ICovIChhbHBoYWJldC5yZWR1Y2UoKHAsIGMsIGkpID0+IHsgcFtpXSA9IGM7IHJldHVybiBwIH0sIC8qKiBAdHlwZSB7c3RyaW5nW119ICovKFtdKSkpXG5jb25zdCBhbHBoYWJldENoYXJzVG9CeXRlcyA9IC8qKiBAdHlwZSB7bnVtYmVyW119ICovIChhbHBoYWJldC5yZWR1Y2UoKHAsIGMsIGkpID0+IHsgcFsvKiogQHR5cGUge251bWJlcn0gKi8gKGMuY29kZVBvaW50QXQoMCkpXSA9IGk7IHJldHVybiBwIH0sIC8qKiBAdHlwZSB7bnVtYmVyW119ICovKFtdKSkpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGUgKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEucmVkdWNlKChwLCBjKSA9PiB7XG4gICAgcCArPSBhbHBoYWJldEJ5dGVzVG9DaGFyc1tjXVxuICAgIHJldHVybiBwXG4gIH0sICcnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBkZWNvZGUgKHN0cikge1xuICBjb25zdCBieXRzID0gW11cbiAgZm9yIChjb25zdCBjaGFyIG9mIHN0cikge1xuICAgIGNvbnN0IGJ5dCA9IGFscGhhYmV0Q2hhcnNUb0J5dGVzWy8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoY2hhci5jb2RlUG9pbnRBdCgwKSldXG4gICAgaWYgKGJ5dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAke2NoYXJ9YClcbiAgICB9XG4gICAgYnl0cy5wdXNoKGJ5dClcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0cylcbn1cblxuZXhwb3J0IGNvbnN0IGJhc2UyNTZlbW9qaSA9IGZyb20oe1xuICBwcmVmaXg6ICfwn5qAJyxcbiAgbmFtZTogJ2Jhc2UyNTZlbW9qaScsXG4gIGVuY29kZSxcbiAgZGVjb2RlXG59KVxuIiwiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdiJyxcbiAgbmFtZTogJ2Jhc2UzMicsXG4gIGFscGhhYmV0OiAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMnVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ0InLFxuICBuYW1lOiAnYmFzZTMydXBwZXInLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnYycsXG4gIG5hbWU6ICdiYXNlMzJwYWQnLFxuICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMycGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQycsXG4gIG5hbWU6ICdiYXNlMzJwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAndicsXG4gIG5hbWU6ICdiYXNlMzJoZXgnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzJoZXh1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdWJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2UzMmhleHBhZHVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ1QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkdXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KVxuXG5leHBvcnQgY29uc3QgYmFzZTMyeiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdoJyxcbiAgbmFtZTogJ2Jhc2UzMnonLFxuICBhbHBoYWJldDogJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pXG4iLCJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcydcblxuZXhwb3J0IGNvbnN0IGJhc2UzNiA9IGJhc2VYKHtcbiAgcHJlZml4OiAnaycsXG4gIG5hbWU6ICdiYXNlMzYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlMzZ1cHBlciA9IGJhc2VYKHtcbiAgcHJlZml4OiAnSycsXG4gIG5hbWU6ICdiYXNlMzZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ1xufSlcbiIsImltcG9ydCB7IGJhc2VYIH0gZnJvbSAnLi9iYXNlLmpzJ1xuXG5leHBvcnQgY29uc3QgYmFzZTU4YnRjID0gYmFzZVgoe1xuICBuYW1lOiAnYmFzZTU4YnRjJyxcbiAgcHJlZml4OiAneicsXG4gIGFscGhhYmV0OiAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBiYXNlWCh7XG4gIG5hbWU6ICdiYXNlNThmbGlja3InLFxuICBwcmVmaXg6ICdaJyxcbiAgYWxwaGFiZXQ6ICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ1xufSlcbiIsIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJ1xuXG5leHBvcnQgY29uc3QgYmFzZTY0ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ20nLFxuICBuYW1lOiAnYmFzZTY0JyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlNjRwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnTScsXG4gIG5hbWU6ICdiYXNlNjRwYWQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JyxcbiAgYml0c1BlckNoYXI6IDZcbn0pXG5cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAndScsXG4gIG5hbWU6ICdiYXNlNjR1cmwnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLFxuICBiaXRzUGVyQ2hhcjogNlxufSlcblxuZXhwb3J0IGNvbnN0IGJhc2U2NHVybHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdVJyxcbiAgbmFtZTogJ2Jhc2U2NHVybHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSlcbiIsIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJ1xuXG5leHBvcnQgY29uc3QgYmFzZTggPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnNycsXG4gIG5hbWU6ICdiYXNlOCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogM1xufSlcbiIsIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9iYXNlLmpzJ1xuaW1wb3J0IHsgZnJvbVN0cmluZywgdG9TdHJpbmcgfSBmcm9tICcuLi9ieXRlcy5qcydcblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gZnJvbSh7XG4gIHByZWZpeDogJ1xceDAwJyxcbiAgbmFtZTogJ2lkZW50aXR5JyxcbiAgZW5jb2RlOiAoYnVmKSA9PiB0b1N0cmluZyhidWYpLFxuICBkZWNvZGU6IChzdHIpID0+IGZyb21TdHJpbmcoc3RyKVxufSlcbiIsIi8vIHRoaXMgaXMgZHVtbXkgbW9kdWxlIG92ZXJsYXllZCBieSBpbnRlcmZhY2UudHNcbiIsIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgKiBhcyBpZGVudGl0eUJhc2UgZnJvbSAnLi9iYXNlcy9pZGVudGl0eS5qcydcbmltcG9ydCAqIGFzIGJhc2UyIGZyb20gJy4vYmFzZXMvYmFzZTIuanMnXG5pbXBvcnQgKiBhcyBiYXNlOCBmcm9tICcuL2Jhc2VzL2Jhc2U4LmpzJ1xuaW1wb3J0ICogYXMgYmFzZTEwIGZyb20gJy4vYmFzZXMvYmFzZTEwLmpzJ1xuaW1wb3J0ICogYXMgYmFzZTE2IGZyb20gJy4vYmFzZXMvYmFzZTE2LmpzJ1xuaW1wb3J0ICogYXMgYmFzZTMyIGZyb20gJy4vYmFzZXMvYmFzZTMyLmpzJ1xuaW1wb3J0ICogYXMgYmFzZTM2IGZyb20gJy4vYmFzZXMvYmFzZTM2LmpzJ1xuaW1wb3J0ICogYXMgYmFzZTU4IGZyb20gJy4vYmFzZXMvYmFzZTU4LmpzJ1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZXMvYmFzZTY0LmpzJ1xuaW1wb3J0ICogYXMgYmFzZTI1NmVtb2ppIGZyb20gJy4vYmFzZXMvYmFzZTI1NmVtb2ppLmpzJ1xuaW1wb3J0ICogYXMgc2hhMiBmcm9tICcuL2hhc2hlcy9zaGEyLmpzJ1xuaW1wb3J0ICogYXMgaWRlbnRpdHkgZnJvbSAnLi9oYXNoZXMvaWRlbnRpdHkuanMnXG5cbmltcG9ydCAqIGFzIHJhdyBmcm9tICcuL2NvZGVjcy9yYXcuanMnXG5pbXBvcnQgKiBhcyBqc29uIGZyb20gJy4vY29kZWNzL2pzb24uanMnXG5cbmltcG9ydCB7IENJRCwgaGFzaGVyLCBkaWdlc3QsIHZhcmludCwgYnl0ZXMgfSBmcm9tICcuL2luZGV4LmpzJ1xuXG5jb25zdCBiYXNlcyA9IHsgLi4uaWRlbnRpdHlCYXNlLCAuLi5iYXNlMiwgLi4uYmFzZTgsIC4uLmJhc2UxMCwgLi4uYmFzZTE2LCAuLi5iYXNlMzIsIC4uLmJhc2UzNiwgLi4uYmFzZTU4LCAuLi5iYXNlNjQsIC4uLmJhc2UyNTZlbW9qaSB9XG5jb25zdCBoYXNoZXMgPSB7IC4uLnNoYTIsIC4uLmlkZW50aXR5IH1cbmNvbnN0IGNvZGVjcyA9IHsgcmF3LCBqc29uIH1cblxuZXhwb3J0IHsgQ0lELCBoYXNoZXIsIGRpZ2VzdCwgdmFyaW50LCBieXRlcywgaGFzaGVzLCBiYXNlcywgY29kZWNzIH1cbiIsImNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoMClcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRcbiAqL1xuY29uc3QgdG9IZXggPSBkID0+IGQucmVkdWNlKChoZXgsIGJ5dGUpID0+IGhleCArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAqL1xuY29uc3QgZnJvbUhleCA9IGhleCA9PiB7XG4gIGNvbnN0IGhleGVzID0gaGV4Lm1hdGNoKC8uLi9nKVxuICByZXR1cm4gaGV4ZXMgPyBuZXcgVWludDhBcnJheShoZXhlcy5tYXAoYiA9PiBwYXJzZUludChiLCAxNikpKSA6IGVtcHR5XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhYVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiYlxuICovXG5jb25zdCBlcXVhbHMgPSAoYWEsIGJiKSA9PiB7XG4gIGlmIChhYSA9PT0gYmIpIHJldHVybiB0cnVlXG4gIGlmIChhYS5ieXRlTGVuZ3RoICE9PSBiYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYWEuYnl0ZUxlbmd0aDsgaWkrKykge1xuICAgIGlmIChhYVtpaV0gIT09IGJiW2lpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fSBvXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgY29lcmNlID0gbyA9PiB7XG4gIGlmIChvIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykgcmV0dXJuIG9cbiAgaWYgKG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8pXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcobykpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIsIG8uYnl0ZU9mZnNldCwgby5ieXRlTGVuZ3RoKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb1xuICogQHJldHVybnMge28gaXMgQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fVxuICovXG5jb25zdCBpc0JpbmFyeSA9IG8gPT5cbiAgbyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhvKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBmcm9tU3RyaW5nID0gc3RyID0+IChuZXcgVGV4dEVuY29kZXIoKSkuZW5jb2RlKHN0cilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvU3RyaW5nID0gYiA9PiAobmV3IFRleHREZWNvZGVyKCkpLmRlY29kZShiKVxuXG5leHBvcnQgeyBlcXVhbHMsIGNvZXJjZSwgaXNCaW5hcnksIGZyb21IZXgsIHRvSGV4LCBmcm9tU3RyaW5nLCB0b1N0cmluZywgZW1wdHkgfVxuIiwiaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4vdmFyaW50LmpzJ1xuaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vaGFzaGVzL2RpZ2VzdC5qcydcbmltcG9ydCB7IGJhc2U1OGJ0YyB9IGZyb20gJy4vYmFzZXMvYmFzZTU4LmpzJ1xuaW1wb3J0IHsgYmFzZTMyIH0gZnJvbSAnLi9iYXNlcy9iYXNlMzIuanMnXG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuL2J5dGVzLmpzJ1xuLy8gTGludGVyIGNhbiBzZWUgdGhhdCBBUEkgaXMgdXNlZCBpbiB0eXBlcy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuaW1wb3J0ICogYXMgQVBJIGZyb20gXCIuL2xpbmsvaW50ZXJmYWNlLmpzXCJcblxuLy8gVGhpcyB3YXkgVFMgd2lsbCBhbHNvIGV4cG9zZSBhbGwgdGhlIHR5cGVzIGZyb20gbW9kdWxlXG5leHBvcnQgKiBmcm9tICcuL2xpbmsvaW50ZXJmYWNlLmpzJ1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7QVBJLkxpbms8dW5rbm93biwgbnVtYmVyLCBudW1iZXIsIEFQSS5WZXJzaW9uPn0gVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQHBhcmFtIHtUfSBsaW5rXG4gKiBAcGFyYW0ge0FQSS5NdWx0aWJhc2VFbmNvZGVyPFByZWZpeD59IFtiYXNlXVxuICogQHJldHVybnMge0FQSS5Ub1N0cmluZzxULCBQcmVmaXg+fVxuICovXG5leHBvcnQgY29uc3QgZm9ybWF0ID0gKGxpbmssIGJhc2UpID0+IHtcbiAgY29uc3QgeyBieXRlcywgdmVyc2lvbiB9ID0gbGlua1xuICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdG9TdHJpbmdWMChcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIGJhc2VDYWNoZShsaW5rKSxcbiAgICAgICAgLyoqIEB0eXBlIHtBUEkuTXVsdGliYXNlRW5jb2RlcjxcInpcIj59ICovIChiYXNlKSB8fCBiYXNlNThidGMuZW5jb2RlclxuICAgICAgKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdG9TdHJpbmdWMShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIGJhc2VDYWNoZShsaW5rKSxcbiAgICAgICAgLyoqIEB0eXBlIHtBUEkuTXVsdGliYXNlRW5jb2RlcjxQcmVmaXg+fSAqLyAoYmFzZSB8fCBiYXNlMzIuZW5jb2RlcilcbiAgICAgIClcbiAgfVxufVxuXG4vKiogQHR5cGUge1dlYWtNYXA8QVBJLlVua25vd25MaW5rLCBNYXA8c3RyaW5nLCBzdHJpbmc+Pn0gKi9cbmNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKVxuXG4vKipcbiAqIEBwYXJhbSB7QVBJLlVua25vd25MaW5rfSBjaWRcbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBiYXNlQ2FjaGUgPSBjaWQgPT4ge1xuICBjb25zdCBiYXNlQ2FjaGUgPSBjYWNoZS5nZXQoY2lkKVxuICBpZiAoYmFzZUNhY2hlID09IG51bGwpIHtcbiAgICBjb25zdCBiYXNlQ2FjaGUgPSBuZXcgTWFwKClcbiAgICBjYWNoZS5zZXQoY2lkLCBiYXNlQ2FjaGUpXG4gICAgcmV0dXJuIGJhc2VDYWNoZVxuICB9XG4gIHJldHVybiBiYXNlQ2FjaGVcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge3Vua25vd259IFtEYXRhPXVua25vd25dXG4gKiBAdGVtcGxhdGUge251bWJlcn0gW0Zvcm1hdD1udW1iZXJdXG4gKiBAdGVtcGxhdGUge251bWJlcn0gW0FsZz1udW1iZXJdXG4gKiBAdGVtcGxhdGUge0FQSS5WZXJzaW9ufSBbVmVyc2lvbj1BUEkuVmVyc2lvbl1cbiAqIEBpbXBsZW1lbnRzIHtBUEkuTGluazxEYXRhLCBGb3JtYXQsIEFsZywgVmVyc2lvbj59XG4gKi9cblxuZXhwb3J0IGNsYXNzIENJRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZlcnNpb259IHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBDSURcbiAgICogQHBhcmFtIHtGb3JtYXR9IGNvZGUgLSBDb2RlIG9mIHRoZSBjb2RlYyBjb250ZW50IGlzIGVuY29kZWQgaW4sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpY29kZWMvYmxvYi9tYXN0ZXIvdGFibGUuY3N2XG4gICAqIEBwYXJhbSB7QVBJLk11bHRpaGFzaERpZ2VzdDxBbGc+fSBtdWx0aWhhc2ggLSAoTXVsdGkpaGFzaCBvZiB0aGUgb2YgdGhlIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzKSB7XG4gICAgLyoqIEByZWFkb25seSAqL1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvblxuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpaGFzaFxuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXNcblxuICAgIC8vIEFycmF5QnVmZmVyVmlld1xuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlcy5ieXRlT2Zmc2V0XG4gICAgLyoqIEByZWFkb25seSAqL1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGhcblxuICAgIC8vIENpcmN1bGFyIHJlZmVyZW5jZVxuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmFzQ0lEID0gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgQVBJLkRBR19QQiwgQVBJLlNIQV8yNTYsIDA+fVxuICAgKi9cbiAgdG9WMCAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtDSUQ8RGF0YSwgQVBJLkRBR19QQiwgQVBJLlNIQV8yNTYsIDA+fSAqLyAodGhpcylcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCB7IGNvZGUsIG11bHRpaGFzaCB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChjb2RlICE9PSBEQUdfUEJfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBub24gZGFnLXBiIENJRCB0byBDSUR2MCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGEyLTI1NlxuICAgICAgICBpZiAobXVsdGloYXNoLmNvZGUgIT09IFNIQV8yNTZfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7Q0lEPERhdGEsIEFQSS5EQUdfUEIsIEFQSS5TSEFfMjU2LCAwPn0gKi8gKFxuICAgICAgICAgIENJRC5jcmVhdGVWMChcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7QVBJLk11bHRpaGFzaERpZ2VzdDxBUEkuU0hBXzI1Nj59ICovIChtdWx0aWhhc2gpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBDYW4gbm90IGNvbnZlcnQgQ0lEIHZlcnNpb24gJHt0aGlzLnZlcnNpb259IHRvIHZlcnNpb24gMC4gVGhpcyBpcyBhIGJ1ZyBwbGVhc2UgcmVwb3J0YFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgRm9ybWF0LCBBbGcsIDE+fVxuICAgKi9cbiAgdG9WMSAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICBjb25zdCB7IGNvZGUsIGRpZ2VzdCB9ID0gdGhpcy5tdWx0aWhhc2hcbiAgICAgICAgY29uc3QgbXVsdGloYXNoID0gRGlnZXN0LmNyZWF0ZShjb2RlLCBkaWdlc3QpXG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0NJRDxEYXRhLCBGb3JtYXQsIEFsZywgMT59ICovIChcbiAgICAgICAgICBDSUQuY3JlYXRlVjEodGhpcy5jb2RlLCBtdWx0aWhhc2gpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtDSUQ8RGF0YSwgRm9ybWF0LCBBbGcsIDE+fSAqLyAodGhpcylcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYENhbiBub3QgY29udmVydCBDSUQgdmVyc2lvbiAke3RoaXMudmVyc2lvbn0gdG8gdmVyc2lvbiAxLiBUaGlzIGlzIGEgYnVnIHBsZWFzZSByZXBvcnRgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHt1bmtub3dufSBvdGhlclxuICAgKiBAcmV0dXJucyB7b3RoZXIgaXMgQ0lEPERhdGEsIEZvcm1hdCwgQWxnLCBWZXJzaW9uPn1cbiAgICovXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gQ0lELmVxdWFscyh0aGlzLCBvdGhlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEZvcm1hdFxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQWxnXG4gICAqIEB0ZW1wbGF0ZSB7QVBJLlZlcnNpb259IFZlcnNpb25cbiAgICogQHBhcmFtIHtBUEkuTGluazxEYXRhLCBGb3JtYXQsIEFsZywgVmVyc2lvbj59IHNlbGZcbiAgICogQHBhcmFtIHt1bmtub3dufSBvdGhlclxuICAgKiBAcmV0dXJucyB7b3RoZXIgaXMgQ0lEfVxuICAgKi9cbiAgc3RhdGljIGVxdWFscyAoc2VsZiwgb3RoZXIpIHtcbiAgICBjb25zdCB1bmtub3duID1cbiAgICAgIC8qKiBAdHlwZSB7e2NvZGU/OnVua25vd24sIHZlcnNpb24/OnVua25vd24sIG11bHRpaGFzaD86dW5rbm93bn19ICovIChcbiAgICAgICAgb3RoZXJcbiAgICAgIClcbiAgICByZXR1cm4gKFxuICAgICAgdW5rbm93biAmJlxuICAgICAgc2VsZi5jb2RlID09PSB1bmtub3duLmNvZGUgJiZcbiAgICAgIHNlbGYudmVyc2lvbiA9PT0gdW5rbm93bi52ZXJzaW9uICYmXG4gICAgICBEaWdlc3QuZXF1YWxzKHNlbGYubXVsdGloYXNoLCB1bmtub3duLm11bHRpaGFzaClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBUEkuTXVsdGliYXNlRW5jb2RlcjxzdHJpbmc+fSBbYmFzZV1cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nIChiYXNlKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBiYXNlKVxuICB9XG5cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgaGFzaDogdGhpcy5tdWx0aWhhc2guYnl0ZXNcbiAgICB9XG4gIH1cblxuICBsaW5rICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0NJRCdcbiAgfVxuXG4gIC8vIExlZ2FjeVxuXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSAoKSB7XG4gICAgcmV0dXJuIGBDSUQoJHt0aGlzLnRvU3RyaW5nKCl9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBhbnkgaW5wdXQgYHZhbHVlYCBhbmQgcmV0dXJucyBhIGBDSURgIGluc3RhbmNlIGlmIGl0IHdhc1xuICAgKiBhIGBDSURgIG90aGVyd2lzZSByZXR1cm5zIGBudWxsYC4gSWYgYHZhbHVlYCBpcyBpbnN0YW5jZW9mIGBDSURgXG4gICAqIGl0IHdpbGwgcmV0dXJuIHZhbHVlIGJhY2suIElmIGB2YWx1ZWAgaXMgbm90IGluc3RhbmNlIG9mIHRoaXMgQ0lEXG4gICAqIGNsYXNzLCBidXQgaXMgY29tcGF0aWJsZSBDSUQgaXQgd2lsbCByZXR1cm4gbmV3IGluc3RhbmNlIG9mIHRoaXNcbiAgICogYENJRGAgY2xhc3MuIE90aGVyd2lzZSByZXR1cnMgbnVsbC5cbiAgICpcbiAgICogVGhpcyBhbGxvd3MgdHdvIGRpZmZlcmVudCBpbmNvbXBhdGlibGUgdmVyc2lvbnMgb2YgQ0lEIGxpYnJhcnkgdG9cbiAgICogY28tZXhpc3QgYW5kIGludGVyb3AgYXMgbG9uZyBhcyBiaW5hcnkgaW50ZXJmYWNlIGlzIGNvbXBhdGlibGUuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gRGF0YVxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gRm9ybWF0XG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBbGdcbiAgICogQHRlbXBsYXRlIHtBUEkuVmVyc2lvbn0gVmVyc2lvblxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IFVcbiAgICogQHBhcmFtIHtBUEkuTGluazxEYXRhLCBGb3JtYXQsIEFsZywgVmVyc2lvbj58VX0gaW5wdXRcbiAgICogQHJldHVybnMge0NJRDxEYXRhLCBGb3JtYXQsIEFsZywgVmVyc2lvbj58bnVsbH1cbiAgICovXG4gIHN0YXRpYyBhc0NJRCAoaW5wdXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAoaW5wdXQpXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ0lEKSB7XG4gICAgICAvLyBJZiB2YWx1ZSBpcyBpbnN0YW5jZSBvZiBDSUQgdGhlbiB3ZSdyZSBhbGwgc2V0LlxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmFzQ0lEID09PSB2YWx1ZSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXNuJ3QgaW5zdGFuY2Ugb2YgdGhpcyBDSUQgY2xhc3MgYnV0IGB0aGlzLmFzQ0lEID09PSB0aGlzYCBpc1xuICAgICAgLy8gdHJ1ZSBpdCBpcyBDSUQgaW5zdGFuY2UgY29taW5nIGZyb20gYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb24gKGRpZmZcbiAgICAgIC8vIHZlcnNpb24gb3IgZHVwbGljYXRlKS4gSW4gdGhhdCBjYXNlIHdlIHJlYmFzZSBpdCB0byB0aGlzIGBDSURgXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBzbyBjYWxsZXIgaXMgZ3VhcmFudGVlZCB0byBnZXQgaW5zdGFuY2Ugd2l0aCBleHBlY3RlZFxuICAgICAgLy8gQVBJLlxuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzIH0gPSB2YWx1ZVxuICAgICAgcmV0dXJuIG5ldyBDSUQoXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGNvZGUsXG4gICAgICAgIC8qKiBAdHlwZSB7QVBJLk11bHRpaGFzaERpZ2VzdDxBbGc+fSAqLyAobXVsdGloYXNoKSxcbiAgICAgICAgYnl0ZXMgfHwgZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaC5ieXRlcylcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbY2lkU3ltYm9sXSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYSBDSUQgZnJvbSBvbGRlciBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZWQgdG8gYmUgdGFnZ2VkIHZpYVxuICAgICAgLy8gc3ltYm9sIHdlIHN0aWxsIHJlYmFzZSBpdCB0byB0aGUgdGhpcyBgQ0lEYCBpbXBsZW1lbnRhdGlvbiBieVxuICAgICAgLy8gZGVsZWdhdGluZyB0aGF0IHRvIGEgY29uc3RydWN0b3IuXG4gICAgICBjb25zdCB7IHZlcnNpb24sIG11bHRpaGFzaCwgY29kZSB9ID0gdmFsdWVcbiAgICAgIGNvbnN0IGRpZ2VzdCA9XG4gICAgICAgIC8qKiBAdHlwZSB7QVBJLk11bHRpaGFzaERpZ2VzdDxBbGc+fSAqL1xuICAgICAgICAoRGlnZXN0LmRlY29kZShtdWx0aWhhc2gpKVxuICAgICAgcmV0dXJuIENJRC5jcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgdmFsdWUgaXMgbm90IGEgQ0lEIChvciBhbiBpbmNvbXBhdGlibGUgdmVyc2lvbiBvZiBpdCkgaW5cbiAgICAgIC8vIHdoaWNoIGNhc2Ugd2UgcmV0dXJuIGBudWxsYC5cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gRGF0YVxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gRm9ybWF0XG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBbGdcbiAgICogQHRlbXBsYXRlIHtBUEkuVmVyc2lvbn0gVmVyc2lvblxuICAgKiBAcGFyYW0ge1ZlcnNpb259IHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBDSURcbiAgICogQHBhcmFtIHtGb3JtYXR9IGNvZGUgLSBDb2RlIG9mIHRoZSBjb2RlYyBjb250ZW50IGlzIGVuY29kZWQgaW4sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpY29kZWMvYmxvYi9tYXN0ZXIvdGFibGUuY3N2XG4gICAqIEBwYXJhbSB7QVBJLk11bHRpaGFzaERpZ2VzdDxBbGc+fSBkaWdlc3QgLSAoTXVsdGkpaGFzaCBvZiB0aGUgb2YgdGhlIGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgRm9ybWF0LCBBbGcsIFZlcnNpb24+fVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSAodmVyc2lvbiwgY29kZSwgZGlnZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgY29kZWNzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkJylcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVmVyc2lvbiAwIENJRCBtdXN0IHVzZSBkYWctcGIgKGNvZGU6ICR7REFHX1BCX0NPREV9KSBibG9jayBlbmNvZGluZ2BcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LCBkaWdlc3QuYnl0ZXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZUNJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QuYnl0ZXMpXG4gICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgYnl0ZXMpXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBjcmVhdGVgIGZvciBDSUR2MC5cbiAgICpcbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBbVD11bmtub3duXVxuICAgKiBAcGFyYW0ge0FQSS5NdWx0aWhhc2hEaWdlc3Q8dHlwZW9mIFNIQV8yNTZfQ09ERT59IGRpZ2VzdCAtIE11bHRpaGFzaC5cbiAgICogQHJldHVybnMge0NJRDxULCB0eXBlb2YgREFHX1BCX0NPREUsIHR5cGVvZiBTSEFfMjU2X0NPREUsIDA+fVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVYwIChkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBEQUdfUEJfQ09ERSwgZGlnZXN0KVxuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgY3JlYXRlYCBmb3IgQ0lEdjEuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gRGF0YVxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQ29kZVxuICAgKiBAdGVtcGxhdGUge251bWJlcn0gQWxnXG4gICAqIEBwYXJhbSB7Q29kZX0gY29kZSAtIENvbnRlbnQgZW5jb2RpbmcgZm9ybWF0IGNvZGUuXG4gICAqIEBwYXJhbSB7QVBJLk11bHRpaGFzaERpZ2VzdDxBbGc+fSBkaWdlc3QgLSBNaWx0aWhhc2ggb2YgdGhlIGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtDSUQ8RGF0YSwgQ29kZSwgQWxnLCAxPn1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVWMSAoY29kZSwgZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMSwgY29kZSwgZGlnZXN0KVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZWQgYSBDSUQgZnJvbSBpdHMgYmluYXJ5IHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZSBhcnJheSBtdXN0IGNvbnRhaW5cbiAgICogb25seSB0aGUgQ0lEIHdpdGggbm8gYWRkaXRpb25hbCBieXRlcy5cbiAgICpcbiAgICogQW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgdGhlIGJ5dGVzIHByb3ZpZGVkIGRvIG5vdCBjb250YWluIGEgdmFsaWRcbiAgICogYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGEgQ0lELlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEFsZ1xuICAgKiBAdGVtcGxhdGUge0FQSS5WZXJzaW9ufSBWZXJcbiAgICogQHBhcmFtIHtBUEkuQnl0ZVZpZXc8QVBJLkxpbms8RGF0YSwgQ29kZSwgQWxnLCBWZXI+Pn0gYnl0ZXNcbiAgICogQHJldHVybnMge0NJRDxEYXRhLCBDb2RlLCBBbGcsIFZlcj59XG4gICAqL1xuICBzdGF0aWMgZGVjb2RlIChieXRlcykge1xuICAgIGNvbnN0IFtjaWQsIHJlbWFpbmRlcl0gPSBDSUQuZGVjb2RlRmlyc3QoYnl0ZXMpXG4gICAgaWYgKHJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpXG4gICAgfVxuICAgIHJldHVybiBjaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVkIGEgQ0lEIGZyb20gaXRzIGJpbmFyeSByZXByZXNlbnRhdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgYnl0ZVxuICAgKiBhcnJheS5cbiAgICpcbiAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIENJRCBhbmQgdGhlIHNlY29uZFxuICAgKiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHJlbWFpbmRlciBvZiB0aGUgb3JpZ2luYWwgYnl0ZSBhcnJheS4gVGhlIHJlbWFpbmRlclxuICAgKiB3aWxsIGJlIGEgemVyby1sZW5ndGggYnl0ZSBhcnJheSBpZiB0aGUgcHJvdmlkZWQgYnl0ZXMgb25seSBjb250YWluZWQgYVxuICAgKiBiaW5hcnkgQ0lEIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IFRcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IENcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEFcbiAgICogQHRlbXBsYXRlIHtBUEkuVmVyc2lvbn0gVlxuICAgKiBAcGFyYW0ge0FQSS5CeXRlVmlldzxBUEkuTGluazxULCBDLCBBLCBWPj59IGJ5dGVzXG4gICAqIEByZXR1cm5zIHtbQ0lEPFQsIEMsIEEsIFY+LCBVaW50OEFycmF5XX1cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVGaXJzdCAoYnl0ZXMpIHtcbiAgICBjb25zdCBzcGVjcyA9IENJRC5pbnNwZWN0Qnl0ZXMoYnl0ZXMpXG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IHNwZWNzLnNpemUgLSBzcGVjcy5tdWx0aWhhc2hTaXplXG4gICAgY29uc3QgbXVsdGloYXNoQnl0ZXMgPSBjb2VyY2UoXG4gICAgICBieXRlcy5zdWJhcnJheShwcmVmaXhTaXplLCBwcmVmaXhTaXplICsgc3BlY3MubXVsdGloYXNoU2l6ZSlcbiAgICApXG4gICAgaWYgKG11bHRpaGFzaEJ5dGVzLmJ5dGVMZW5ndGggIT09IHNwZWNzLm11bHRpaGFzaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpXG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gbXVsdGloYXNoQnl0ZXMuc3ViYXJyYXkoXG4gICAgICBzcGVjcy5tdWx0aWhhc2hTaXplIC0gc3BlY3MuZGlnZXN0U2l6ZVxuICAgIClcbiAgICBjb25zdCBkaWdlc3QgPSBuZXcgRGlnZXN0LkRpZ2VzdChcbiAgICAgIHNwZWNzLm11bHRpaGFzaENvZGUsXG4gICAgICBzcGVjcy5kaWdlc3RTaXplLFxuICAgICAgZGlnZXN0Qnl0ZXMsXG4gICAgICBtdWx0aWhhc2hCeXRlc1xuICAgIClcbiAgICBjb25zdCBjaWQgPVxuICAgICAgc3BlY3MudmVyc2lvbiA9PT0gMFxuICAgICAgICA/IENJRC5jcmVhdGVWMCgvKiogQHR5cGUge0FQSS5NdWx0aWhhc2hEaWdlc3Q8QVBJLlNIQV8yNTY+fSAqLyAoZGlnZXN0KSlcbiAgICAgICAgOiBDSUQuY3JlYXRlVjEoc3BlY3MuY29kZWMsIGRpZ2VzdClcbiAgICByZXR1cm4gWy8qKiBAdHlwZSB7Q0lEPFQsIEMsIEEsIFY+fSAqLyhjaWQpLCBieXRlcy5zdWJhcnJheShzcGVjcy5zaXplKV1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IHRoZSBpbml0aWFsIGJ5dGVzIG9mIGEgQ0lEIHRvIGRldGVybWluZSBpdHMgcHJvcGVydGllcy5cbiAgICpcbiAgICogSW52b2x2ZXMgZGVjb2RpbmcgdXAgdG8gNCB2YXJpbnRzLiBUeXBpY2FsbHkgdGhpcyB3aWxsIHJlcXVpcmUgb25seSA0IHRvIDZcbiAgICogYnl0ZXMgYnV0IGZvciBsYXJnZXIgbXVsdGljb2RlYyBjb2RlIHZhbHVlcyBhbmQgbGFyZ2VyIG11bHRpaGFzaCBkaWdlc3RcbiAgICogbGVuZ3RocyB0aGVzZSB2YXJpbnRzIGNhbiBiZSBxdWl0ZSBsYXJnZS4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBhdCBsZWFzdFxuICAgKiAxMCBieXRlcyBiZSBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgYGluaXRpYWxCeXRlc2AgYXJndW1lbnQgZm9yIGEgY29tcGxldGVcbiAgICogaW5zcGVjdGlvbi5cbiAgICpcbiAgICogQHRlbXBsYXRlIHt1bmtub3dufSBUXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBDXG4gICAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBXG4gICAqIEB0ZW1wbGF0ZSB7QVBJLlZlcnNpb259IFZcbiAgICogQHBhcmFtIHtBUEkuQnl0ZVZpZXc8QVBJLkxpbms8VCwgQywgQSwgVj4+fSBpbml0aWFsQnl0ZXNcbiAgICogQHJldHVybnMge3sgdmVyc2lvbjpWLCBjb2RlYzpDLCBtdWx0aWhhc2hDb2RlOkEsIGRpZ2VzdFNpemU6bnVtYmVyLCBtdWx0aWhhc2hTaXplOm51bWJlciwgc2l6ZTpudW1iZXIgfX1cbiAgICovXG4gIHN0YXRpYyBpbnNwZWN0Qnl0ZXMgKGluaXRpYWxCeXRlcykge1xuICAgIGxldCBvZmZzZXQgPSAwXG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFtpLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShpbml0aWFsQnl0ZXMuc3ViYXJyYXkob2Zmc2V0KSlcbiAgICAgIG9mZnNldCArPSBsZW5ndGhcbiAgICAgIHJldHVybiBpXG4gICAgfVxuXG4gICAgbGV0IHZlcnNpb24gPSAvKiogQHR5cGUge1Z9ICovIChuZXh0KCkpXG4gICAgbGV0IGNvZGVjID0gLyoqIEB0eXBlIHtDfSAqLyAoREFHX1BCX0NPREUpXG4gICAgaWYgKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyh2ZXJzaW9uKSA9PT0gMTgpIHtcbiAgICAgIC8vIENJRHYwXG4gICAgICB2ZXJzaW9uID0gLyoqIEB0eXBlIHtWfSAqLyAoMClcbiAgICAgIG9mZnNldCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZWMgPSAvKiogQHR5cGUge0N9ICovIChuZXh0KCkpXG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDAgJiYgdmVyc2lvbiAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgQ0lEIHZlcnNpb24gJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IG9mZnNldFxuICAgIGNvbnN0IG11bHRpaGFzaENvZGUgPSAvKiogQHR5cGUge0F9ICovIChuZXh0KCkpIC8vIG11bHRpaGFzaCBjb2RlXG4gICAgY29uc3QgZGlnZXN0U2l6ZSA9IG5leHQoKSAvLyBtdWx0aWhhc2ggbGVuZ3RoXG4gICAgY29uc3Qgc2l6ZSA9IG9mZnNldCArIGRpZ2VzdFNpemVcbiAgICBjb25zdCBtdWx0aWhhc2hTaXplID0gc2l6ZSAtIHByZWZpeFNpemVcblxuICAgIHJldHVybiB7IHZlcnNpb24sIGNvZGVjLCBtdWx0aWhhc2hDb2RlLCBkaWdlc3RTaXplLCBtdWx0aWhhc2hTaXplLCBzaXplIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBjaWQgaW4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYW5kIGNyZWF0ZXMgYW4gaW5zdGFuY2UuIElmIGBiYXNlYFxuICAgKiBkZWNvZGVyIGlzIG5vdCBwcm92aWRlZCB3aWxsIHVzZSBhIGRlZmF1bHQgZnJvbSB0aGUgY29uZmlndXJhdGlvbi4gSXQgd2lsbFxuICAgKiB0aHJvdyBhbiBlcnJvciBpZiBlbmNvZGluZyBvZiB0aGUgQ0lEIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggc3VwcGxpZWQgKG9yXG4gICAqIGEgZGVmYXVsdCBkZWNvZGVyKS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICAgKiBAdGVtcGxhdGUge3Vua25vd259IERhdGFcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAgICogQHRlbXBsYXRlIHtudW1iZXJ9IEFsZ1xuICAgKiBAdGVtcGxhdGUge0FQSS5WZXJzaW9ufSBWZXJcbiAgICogQHBhcmFtIHtBUEkuVG9TdHJpbmc8QVBJLkxpbms8RGF0YSwgQ29kZSwgQWxnLCBWZXI+LCBQcmVmaXg+fSBzb3VyY2VcbiAgICogQHBhcmFtIHtBUEkuTXVsdGliYXNlRGVjb2RlcjxQcmVmaXg+fSBbYmFzZV1cbiAgICogQHJldHVybnMge0NJRDxEYXRhLCBDb2RlLCBBbGcsIFZlcj59XG4gICAqL1xuICBzdGF0aWMgcGFyc2UgKHNvdXJjZSwgYmFzZSkge1xuICAgIGNvbnN0IFtwcmVmaXgsIGJ5dGVzXSA9IHBhcnNlQ0lEdG9CeXRlcyhzb3VyY2UsIGJhc2UpXG5cbiAgICBjb25zdCBjaWQgPSBDSUQuZGVjb2RlKGJ5dGVzKVxuXG4gICAgLy8gQ2FjaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGF2b2lkIGNvbXB1dGluZyBpdCBvbiBgdGhpcy50b1N0cmluZygpYFxuICAgIGJhc2VDYWNoZShjaWQpLnNldChwcmVmaXgsIHNvdXJjZSlcblxuICAgIHJldHVybiBjaWRcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBQcmVmaXhcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gRGF0YVxuICogQHRlbXBsYXRlIHtudW1iZXJ9IENvZGVcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBBbGdcbiAqIEB0ZW1wbGF0ZSB7QVBJLlZlcnNpb259IFZlclxuICogQHBhcmFtIHtBUEkuVG9TdHJpbmc8QVBJLkxpbms8RGF0YSwgQ29kZSwgQWxnLCBWZXI+LCBQcmVmaXg+fSBzb3VyY2VcbiAqIEBwYXJhbSB7QVBJLk11bHRpYmFzZURlY29kZXI8UHJlZml4Pn0gW2Jhc2VdXG4gKiBAcmV0dXJucyB7W1ByZWZpeCwgQVBJLkJ5dGVWaWV3PEFQSS5MaW5rPERhdGEsIENvZGUsIEFsZywgVmVyPj5dfVxuICovXG5jb25zdCBwYXJzZUNJRHRvQnl0ZXMgPSAoc291cmNlLCBiYXNlKSA9PiB7XG4gIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgLy8gQ0lEdjAgaXMgcGFyc2VkIGRpZmZlcmVudGx5XG4gICAgY2FzZSAnUSc6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2U1OGJ0Y1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLyoqIEB0eXBlIHtQcmVmaXh9ICovIChiYXNlNThidGMucHJlZml4KSxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoYCR7YmFzZTU4YnRjLnByZWZpeH0ke3NvdXJjZX1gKVxuICAgICAgXVxuICAgIH1cbiAgICBjYXNlIGJhc2U1OGJ0Yy5wcmVmaXg6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2U1OGJ0Y1xuICAgICAgcmV0dXJuIFsvKiogQHR5cGUge1ByZWZpeH0gKi8oYmFzZTU4YnRjLnByZWZpeCksIGRlY29kZXIuZGVjb2RlKHNvdXJjZSldXG4gICAgfVxuICAgIGNhc2UgYmFzZTMyLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTMyXG4gICAgICByZXR1cm4gWy8qKiBAdHlwZSB7UHJlZml4fSAqLyhiYXNlMzIucHJlZml4KSwgZGVjb2Rlci5kZWNvZGUoc291cmNlKV1cbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnVG8gcGFyc2Ugbm9uIGJhc2UzMiBvciBiYXNlNThidGMgZW5jb2RlZCBDSUQgbXVsdGliYXNlIGRlY29kZXIgbXVzdCBiZSBwcm92aWRlZCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFsvKiogQHR5cGUge1ByZWZpeH0gKi8oc291cmNlWzBdKSwgYmFzZS5kZWNvZGUoc291cmNlKV1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBjYWNoZVxuICogQHBhcmFtIHtBUEkuTXVsdGliYXNlRW5jb2Rlcjwneic+fSBiYXNlXG4gKi9cbmNvbnN0IHRvU3RyaW5nVjAgPSAoYnl0ZXMsIGNhY2hlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHsgcHJlZml4IH0gPSBiYXNlXG4gIGlmIChwcmVmaXggIT09IGJhc2U1OGJ0Yy5wcmVmaXgpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHN0cmluZyBlbmNvZGUgVjAgaW4gJHtiYXNlLm5hbWV9IGVuY29kaW5nYClcbiAgfVxuXG4gIGNvbnN0IGNpZCA9IGNhY2hlLmdldChwcmVmaXgpXG4gIGlmIChjaWQgPT0gbnVsbCkge1xuICAgIGNvbnN0IGNpZCA9IGJhc2UuZW5jb2RlKGJ5dGVzKS5zbGljZSgxKVxuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZClcbiAgICByZXR1cm4gY2lkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNpZFxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFByZWZpeFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBjYWNoZVxuICogQHBhcmFtIHtBUEkuTXVsdGliYXNlRW5jb2RlcjxQcmVmaXg+fSBiYXNlXG4gKi9cbmNvbnN0IHRvU3RyaW5nVjEgPSAoYnl0ZXMsIGNhY2hlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHsgcHJlZml4IH0gPSBiYXNlXG4gIGNvbnN0IGNpZCA9IGNhY2hlLmdldChwcmVmaXgpXG4gIGlmIChjaWQgPT0gbnVsbCkge1xuICAgIGNvbnN0IGNpZCA9IGJhc2UuZW5jb2RlKGJ5dGVzKVxuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZClcbiAgICByZXR1cm4gY2lkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNpZFxuICB9XG59XG5cbmNvbnN0IERBR19QQl9DT0RFID0gMHg3MFxuY29uc3QgU0hBXzI1Nl9DT0RFID0gMHgxMlxuXG4vKipcbiAqIEBwYXJhbSB7QVBJLlZlcnNpb259IHZlcnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZUNJRCA9ICh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gpID0+IHtcbiAgY29uc3QgY29kZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ZXJzaW9uKVxuICBjb25zdCBoYXNoT2Zmc2V0ID0gY29kZU9mZnNldCArIHZhcmludC5lbmNvZGluZ0xlbmd0aChjb2RlKVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhhc2hPZmZzZXQgKyBtdWx0aWhhc2guYnl0ZUxlbmd0aClcbiAgdmFyaW50LmVuY29kZVRvKHZlcnNpb24sIGJ5dGVzLCAwKVxuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIGNvZGVPZmZzZXQpXG4gIGJ5dGVzLnNldChtdWx0aWhhc2gsIGhhc2hPZmZzZXQpXG4gIHJldHVybiBieXRlc1xufVxuXG5jb25zdCBjaWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJylcbiIsIi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2ludGVyZmFjZS5qcycpLkJ5dGVWaWV3PFQ+fSBCeXRlVmlld1xuICovXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuZXhwb3J0IGNvbnN0IG5hbWUgPSAnanNvbidcbmV4cG9ydCBjb25zdCBjb2RlID0gMHgwMjAwXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gbm9kZVxuICogQHJldHVybnMge0J5dGVWaWV3PFQ+fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKG5vZGUpID0+IHRleHRFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShub2RlKSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtCeXRlVmlldzxUPn0gZGF0YVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoZGF0YSkgPT4gSlNPTi5wYXJzZSh0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSkpXG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaW50ZXJmYWNlLmpzJykuQnl0ZVZpZXc8VD59IEJ5dGVWaWV3XG4gKi9cblxuZXhwb3J0IGNvbnN0IG5hbWUgPSAncmF3J1xuZXhwb3J0IGNvbnN0IGNvZGUgPSAweDU1XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBub2RlXG4gKiBAcmV0dXJucyB7Qnl0ZVZpZXc8VWludDhBcnJheT59XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAobm9kZSkgPT4gY29lcmNlKG5vZGUpXG5cbi8qKlxuICogQHBhcmFtIHtCeXRlVmlldzxVaW50OEFycmF5Pn0gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoZGF0YSkgPT4gY29lcmNlKGRhdGEpXG4iLCJpbXBvcnQgeyBjb2VyY2UsIGVxdWFscyBhcyBlcXVhbEJ5dGVzIH0gZnJvbSAnLi4vYnl0ZXMuanMnXG5pbXBvcnQgKiBhcyB2YXJpbnQgZnJvbSAnLi4vdmFyaW50LmpzJ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtdWx0aWhhc2ggZGlnZXN0LlxuICpcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBDb2RlXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGlnZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoY29kZSwgZGlnZXN0KSA9PiB7XG4gIGNvbnN0IHNpemUgPSBkaWdlc3QuYnl0ZUxlbmd0aFxuICBjb25zdCBzaXplT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGUpXG4gIGNvbnN0IGRpZ2VzdE9mZnNldCA9IHNpemVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoc2l6ZSlcblxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRpZ2VzdE9mZnNldCArIHNpemUpXG4gIHZhcmludC5lbmNvZGVUbyhjb2RlLCBieXRlcywgMClcbiAgdmFyaW50LmVuY29kZVRvKHNpemUsIGJ5dGVzLCBzaXplT2Zmc2V0KVxuICBieXRlcy5zZXQoZGlnZXN0LCBkaWdlc3RPZmZzZXQpXG5cbiAgcmV0dXJuIG5ldyBEaWdlc3QoY29kZSwgc2l6ZSwgZGlnZXN0LCBieXRlcylcbn1cblxuLyoqXG4gKiBUdXJucyBieXRlcyByZXByZXNlbnRhdGlvbiBvZiBtdWx0aWhhc2ggZGlnZXN0IGludG8gYW4gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHtNdWx0aWhhc2hEaWdlc3R9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAobXVsdGloYXNoKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gY29lcmNlKG11bHRpaGFzaClcbiAgY29uc3QgW2NvZGUsIHNpemVPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcylcbiAgY29uc3QgW3NpemUsIGRpZ2VzdE9mZnNldF0gPSB2YXJpbnQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KHNpemVPZmZzZXQpKVxuICBjb25zdCBkaWdlc3QgPSBieXRlcy5zdWJhcnJheShzaXplT2Zmc2V0ICsgZGlnZXN0T2Zmc2V0KVxuXG4gIGlmIChkaWdlc3QuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TXVsdGloYXNoRGlnZXN0fSBhXG4gKiBAcGFyYW0ge3Vua25vd259IGJcbiAqIEByZXR1cm5zIHtiIGlzIE11bHRpaGFzaERpZ2VzdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFscyA9IChhLCBiKSA9PiB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkYXRhID0gLyoqIEB0eXBlIHt7Y29kZT86dW5rbm93biwgc2l6ZT86dW5rbm93biwgYnl0ZXM/OnVua25vd259fSAqLyhiKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGEuY29kZSA9PT0gZGF0YS5jb2RlICYmXG4gICAgICBhLnNpemUgPT09IGRhdGEuc2l6ZSAmJlxuICAgICAgZGF0YS5ieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiZcbiAgICAgIGVxdWFsQnl0ZXMoYS5ieXRlcywgZGF0YS5ieXRlcylcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2ludGVyZmFjZS5qcycpLk11bHRpaGFzaERpZ2VzdH0gTXVsdGloYXNoRGlnZXN0XG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbXVsdGloYXNoIGRpZ2VzdCB3aGljaCBjYXJyaWVzIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogaGFzaGluZyBhbG9ncml0aG0gYW5kIGFuIGFjdHVhbCBoYXNoIGRpZ2VzdC5cbiAqXG4gKiBAdGVtcGxhdGUge251bWJlcn0gQ29kZVxuICogQHRlbXBsYXRlIHtudW1iZXJ9IFNpemVcbiAqIEBjbGFzc1xuICogQGltcGxlbWVudHMge011bHRpaGFzaERpZ2VzdH1cbiAqL1xuZXhwb3J0IGNsYXNzIERpZ2VzdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbXVsdGloYXNoIGRpZ2VzdC5cbiAgICpcbiAgICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gICAqIEBwYXJhbSB7U2l6ZX0gc2l6ZVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRpZ2VzdFxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29kZSwgc2l6ZSwgZGlnZXN0LCBieXRlcykge1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICB0aGlzLnNpemUgPSBzaXplXG4gICAgdGhpcy5kaWdlc3QgPSBkaWdlc3RcbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXNcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vZGlnZXN0LmpzJ1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBOYW1lXG4gKiBAdGVtcGxhdGUge251bWJlcn0gQ29kZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TmFtZX0gb3B0aW9ucy5uYW1lXG4gKiBAcGFyYW0ge0NvZGV9IG9wdGlvbnMuY29kZVxuICogQHBhcmFtIHsoaW5wdXQ6IFVpbnQ4QXJyYXkpID0+IEF3YWl0PFVpbnQ4QXJyYXk+fSBvcHRpb25zLmVuY29kZVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9ICh7IG5hbWUsIGNvZGUsIGVuY29kZSB9KSA9PiBuZXcgSGFzaGVyKG5hbWUsIGNvZGUsIGVuY29kZSlcblxuLyoqXG4gKiBIYXNoZXIgcmVwcmVzZW50cyBhIGhhc2hpbmcgYWxnb3JpdGhtIGltcGxlbWVudGF0aW9uIHRoYXQgcHJvZHVjZXMgYXNcbiAqIGBNdWx0aWhhc2hEaWdlc3RgLlxuICpcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBOYW1lXG4gKiBAdGVtcGxhdGUge251bWJlcn0gQ29kZVxuICogQGNsYXNzXG4gKiBAaW1wbGVtZW50cyB7TXVsdGloYXNoSGFzaGVyPENvZGU+fVxuICovXG5leHBvcnQgY2xhc3MgSGFzaGVyIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7TmFtZX0gbmFtZVxuICAgKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAgICogQHBhcmFtIHsoaW5wdXQ6IFVpbnQ4QXJyYXkpID0+IEF3YWl0PFVpbnQ4QXJyYXk+fSBlbmNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBlbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuZW5jb2RlID0gZW5jb2RlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7QXdhaXQ8RGlnZXN0LkRpZ2VzdDxDb2RlLCBudW1iZXI+Pn1cbiAgICovXG4gIGRpZ2VzdCAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmVuY29kZShpbnB1dClcbiAgICAgIHJldHVybiByZXN1bHQgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgID8gRGlnZXN0LmNyZWF0ZSh0aGlzLmNvZGUsIHJlc3VsdClcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMSAqL1xuICAgICAgICA6IHJlc3VsdC50aGVuKGRpZ2VzdCA9PiBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgZGlnZXN0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpXG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAxICovXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtudW1iZXJ9IEFsZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi9pbnRlcmZhY2UuanMnKS5NdWx0aWhhc2hIYXNoZXJ9IE11bHRpaGFzaEhhc2hlclxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtQcm9taXNlPFQ+fFR9IEF3YWl0XG4gKi9cbiIsImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJ1xuaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vZGlnZXN0LmpzJ1xuXG5jb25zdCBjb2RlID0gMHgwXG5jb25zdCBuYW1lID0gJ2lkZW50aXR5J1xuXG4vKiogQHR5cGUgeyhpbnB1dDpVaW50OEFycmF5KSA9PiBVaW50OEFycmF5fSAqL1xuY29uc3QgZW5jb2RlID0gY29lcmNlXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICogQHJldHVybnMge0RpZ2VzdC5EaWdlc3Q8dHlwZW9mIGNvZGUsIG51bWJlcj59XG4gKi9cbmNvbnN0IGRpZ2VzdCA9IChpbnB1dCkgPT4gRGlnZXN0LmNyZWF0ZShjb2RlLCBlbmNvZGUoaW5wdXQpKVxuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSB7IGNvZGUsIG5hbWUsIGVuY29kZSwgZGlnZXN0IH1cbiIsIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0bydcbmltcG9ydCB7IGZyb20gfSBmcm9tICcuL2hhc2hlci5qcydcbmltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJ1xuXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gZnJvbSh7XG4gIG5hbWU6ICdzaGEyLTI1NicsXG4gIGNvZGU6IDB4MTIsXG4gIGVuY29kZTogKGlucHV0KSA9PiBjb2VyY2UoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCkpXG59KVxuXG5leHBvcnQgY29uc3Qgc2hhNTEyID0gZnJvbSh7XG4gIG5hbWU6ICdzaGEyLTUxMicsXG4gIGNvZGU6IDB4MTMsXG4gIGVuY29kZTogaW5wdXQgPT4gY29lcmNlKGNyeXB0by5jcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJy4vY2lkLmpzJ1xuaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4vdmFyaW50LmpzJ1xuaW1wb3J0ICogYXMgYnl0ZXMgZnJvbSAnLi9ieXRlcy5qcydcbmltcG9ydCAqIGFzIGhhc2hlciBmcm9tICcuL2hhc2hlcy9oYXNoZXIuanMnXG5pbXBvcnQgKiBhcyBkaWdlc3QgZnJvbSAnLi9oYXNoZXMvZGlnZXN0LmpzJ1xuLy8gVGhpcyB3YXkgVFMgd2lsbCBhbHNvIGV4cG9zZSBhbGwgdGhlIHR5cGVzIGZyb20gbW9kdWxlXG5leHBvcnQgKiBmcm9tICcuL2ludGVyZmFjZS5qcydcblxuZXhwb3J0IHsgQ0lELCBoYXNoZXIsIGRpZ2VzdCwgdmFyaW50LCBieXRlcyB9XG4iLCIvLyB0aGlzIGlzIGR1bW15IG1vZHVsZSBvdmVybGF5ZWQgYnkgaW50ZXJmYWNlLnRzXG4iLCIvLyB0aGlzIGlzIGR1bW15IG1vZHVsZSBvdmVybGF5ZWQgYnkgaW50ZXJmYWNlLnRzXG4iLCJpbXBvcnQgdmFyaW50IGZyb20gJy4uL3ZlbmRvci92YXJpbnQuanMnXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXVxuICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoZGF0YSwgb2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShkYXRhLCBvZmZzZXQpXG4gIHJldHVybiBbY29kZSwgdmFyaW50LmRlY29kZS5ieXRlc11cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW50XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvID0gKGludCwgdGFyZ2V0LCBvZmZzZXQgPSAwKSA9PiB7XG4gIHZhcmludC5lbmNvZGUoaW50LCB0YXJnZXQsIG9mZnNldClcbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGluZ0xlbmd0aCA9IChpbnQpID0+IHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aChpbnQpXG59XG4iLCIvLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVULCBuYW1lKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpO1xuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaTtcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aDtcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKTtcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KTsgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSk7IC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIDsgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5JykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB2YXIgcGJlZ2luID0gMDtcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKys7XG4gICAgICB6ZXJvZXMrKztcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDA7XG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDA7XG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrKztcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKTtcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSk7IH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHNwYWNlcy5cbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykgeyByZXR1cm4gfVxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDA7IC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMDtcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBTa2lwIHRyYWlsaW5nIHNwYWNlcy5cbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykgeyByZXR1cm4gfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi0ke25hbWV9IGNoYXJhY3RlcmApXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG52YXIgc3JjID0gYmFzZTtcblxudmFyIF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVggPSBzcmM7XG5cbmV4cG9ydCBkZWZhdWx0IF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVg7XG4iLCJ2YXIgZW5jb2RlXzEgPSBlbmNvZGU7XG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcbiAgLCBNU0JBTEwgPSB+UkVTVFxuICAsIElOVCA9IE1hdGgucG93KDIsIDMxKTtcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldDtcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQjtcbiAgICBudW0gLz0gMTI4O1xuICB9XG4gIHdoaWxlKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0I7XG4gICAgbnVtID4+Pj0gNztcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDA7XG4gIFxuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxO1xuICBcbiAgcmV0dXJuIG91dFxufVxuXG52YXIgZGVjb2RlID0gcmVhZDtcblxudmFyIE1TQiQxID0gMHg4MFxuICAsIFJFU1QkMSA9IDB4N0Y7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDA7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK107XG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUJDEpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCQxKSAqIE1hdGgucG93KDIsIHNoaWZ0KTtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChiID49IE1TQiQxKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0O1xuXG4gIHJldHVybiByZXNcbn1cblxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpO1xudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpO1xudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpO1xudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpO1xudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpO1xudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpO1xudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpO1xudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpO1xudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpO1xuXG52YXIgbGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn07XG5cbnZhciB2YXJpbnQgPSB7XG4gICAgZW5jb2RlOiBlbmNvZGVfMVxuICAsIGRlY29kZTogZGVjb2RlXG4gICwgZW5jb2RpbmdMZW5ndGg6IGxlbmd0aFxufTtcblxudmFyIF9icnJwX3ZhcmludCA9IHZhcmludDtcblxuZXhwb3J0IGRlZmF1bHQgX2JycnBfdmFyaW50O1xuIiwiaW1wb3J0IHsgYXNVaW50OEFycmF5IH0gZnJvbSAnLi91dGlsL2FzLXVpbnQ4YXJyYXkuanMnO1xuLyoqXG4gKiBSZXR1cm5zIGEgYFVpbnQ4QXJyYXlgIG9mIHRoZSByZXF1ZXN0ZWQgc2l6ZS4gUmVmZXJlbmNlZCBtZW1vcnkgd2lsbFxuICogYmUgaW5pdGlhbGl6ZWQgdG8gMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jKHNpemUgPSAwKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyPy5hbGxvYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG59XG4vKipcbiAqIFdoZXJlIHBvc3NpYmxlIHJldHVybnMgYSBVaW50OEFycmF5IG9mIHRoZSByZXF1ZXN0ZWQgc2l6ZSB0aGF0IHJlZmVyZW5jZXNcbiAqIHVuaW5pdGlhbGl6ZWQgbWVtb3J5LiBPbmx5IHVzZSBpZiB5b3UgYXJlIGNlcnRhaW4geW91IHdpbGwgaW1tZWRpYXRlbHlcbiAqIG92ZXJ3cml0ZSBldmVyeSB2YWx1ZSBpbiB0aGUgcmV0dXJuZWQgYFVpbnQ4QXJyYXlgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSA9IDApIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXI/LmFsbG9jVW5zYWZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFzVWludDhBcnJheShnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbG9jLmpzLm1hcCIsImltcG9ydCB7IGFsbG9jVW5zYWZlIH0gZnJvbSAnLi9hbGxvYy5qcyc7XG5pbXBvcnQgeyBhc1VpbnQ4QXJyYXkgfSBmcm9tICcuL3V0aWwvYXMtdWludDhhcnJheS5qcyc7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgVWludDhBcnJheSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhc3NlZCBBcnJheUxpa2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoYXJyYXlzLCBsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmxlbmd0aCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IGFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGFzVWludDhBcnJheShvdXRwdXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcCIsIi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcGFzc2VkIFVpbnQ4QXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWxzLmpzLm1hcCIsImltcG9ydCBiYXNlcyBmcm9tICcuL3V0aWwvYmFzZXMuanMnO1xuaW1wb3J0IHsgYXNVaW50OEFycmF5IH0gZnJvbSAnLi91dGlsL2FzLXVpbnQ4YXJyYXkuanMnO1xuLyoqXG4gKiBDcmVhdGUgYSBgVWludDhBcnJheWAgZnJvbSB0aGUgcGFzc2VkIHN0cmluZ1xuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCwgYGhleGAsIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWZvcm1hdHMgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICAgIGNvbnN0IGJhc2UgPSBiYXNlc1tlbmNvZGluZ107XG4gICAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHtlbmNvZGluZ31cImApO1xuICAgIH1cbiAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpICYmIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShzdHJpbmcsICd1dGYtOCcpKTtcbiAgICB9XG4gICAgLy8gYWRkIG11bHRpYmFzZSBwcmVmaXhcbiAgICByZXR1cm4gYmFzZS5kZWNvZGVyLmRlY29kZShgJHtiYXNlLnByZWZpeH0ke3N0cmluZ31gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20tc3RyaW5nLmpzLm1hcCIsImltcG9ydCBiYXNlcyBmcm9tICcuL3V0aWwvYmFzZXMuanMnO1xuLyoqXG4gKiBUdXJucyBhIGBVaW50OEFycmF5YCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhhcnJheSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgICBjb25zdCBiYXNlID0gYmFzZXNbZW5jb2RpbmddO1xuICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZW5jb2Rpbmd9XCJgKTtcbiAgICB9XG4gICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuICAgIC8vIHN0cmlwIG11bHRpYmFzZSBwcmVmaXhcbiAgICByZXR1cm4gYmFzZS5lbmNvZGVyLmVuY29kZShhcnJheSkuc3Vic3RyaW5nKDEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tc3RyaW5nLmpzLm1hcCIsIi8qKlxuICogVG8gZ3VhcmFudGVlIFVpbnQ4QXJyYXkgc2VtYW50aWNzLCBjb252ZXJ0IG5vZGVqcyBCdWZmZXJzXG4gKiBpbnRvIHZhbmlsbGEgVWludDhBcnJheXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzVWludDhBcnJheShidWYpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzLXVpbnQ4YXJyYXkuanMubWFwIiwiaW1wb3J0IHsgYmFzZXMgfSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzaWNzJztcbmltcG9ydCB7IGFsbG9jVW5zYWZlIH0gZnJvbSAnLi4vYWxsb2MuanMnO1xuZnVuY3Rpb24gY3JlYXRlQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgZW5jb2Rlcjoge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIGVuY29kZVxuICAgICAgICB9LFxuICAgICAgICBkZWNvZGVyOiB7XG4gICAgICAgICAgICBkZWNvZGVcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBzdHJpbmcgPSBjcmVhdGVDb2RlYygndXRmOCcsICd1JywgKGJ1ZikgPT4ge1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICByZXR1cm4gJ3UnICsgZGVjb2Rlci5kZWNvZGUoYnVmKTtcbn0sIChzdHIpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0ci5zdWJzdHJpbmcoMSkpO1xufSk7XG5jb25zdCBhc2NpaSA9IGNyZWF0ZUNvZGVjKCdhc2NpaScsICdhJywgKGJ1ZikgPT4ge1xuICAgIGxldCBzdHJpbmcgPSAnYSc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn0sIChzdHIpID0+IHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIGNvbnN0IGJ1ZiA9IGFsbG9jVW5zYWZlKHN0ci5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufSk7XG5jb25zdCBCQVNFUyA9IHtcbiAgICB1dGY4OiBzdHJpbmcsXG4gICAgJ3V0Zi04Jzogc3RyaW5nLFxuICAgIGhleDogYmFzZXMuYmFzZTE2LFxuICAgIGxhdGluMTogYXNjaWksXG4gICAgYXNjaWk6IGFzY2lpLFxuICAgIGJpbmFyeTogYXNjaWksXG4gICAgLi4uYmFzZXNcbn07XG5leHBvcnQgZGVmYXVsdCBCQVNFUztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VzLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsIHx8IHNoaWZ0ID4gNDkpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIGlmIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGVuY29kZS5ieXRlcyA9IDBcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGVuY29kZSB2YXJpbnQnKVxuICB9XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwiaW1wb3J0IHsgZnJvbUJhc2U2NHVybCwgdG9CYXNlNjR1cmwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3BsaXQoc3BsaXQpIHtcbiAgICBjb25zdCBbcHJvdGVjdGVkSGVhZGVyLCBlbmNyeXB0ZWRfa2V5LCBpdiwgY2lwaGVydGV4dCwgdGFnXSA9IHNwbGl0O1xuICAgIGNvbnN0IGp3ZSA9IHtcbiAgICAgICAgY2lwaGVydGV4dCxcbiAgICAgICAgaXYsXG4gICAgICAgIHByb3RlY3RlZDogcHJvdGVjdGVkSGVhZGVyLFxuICAgICAgICB0YWcsXG4gICAgfTtcbiAgICBpZiAoZW5jcnlwdGVkX2tleSlcbiAgICAgICAgandlLnJlY2lwaWVudHMgPSBbeyBlbmNyeXB0ZWRfa2V5IH1dO1xuICAgIHJldHVybiBqd2U7XG59XG5mdW5jdGlvbiBlbmNvZGVSZWNpcGllbnQocmVjaXBpZW50KSB7XG4gICAgY29uc3QgZW5jUmVjID0ge307XG4gICAgaWYgKHJlY2lwaWVudC5lbmNyeXB0ZWRfa2V5KVxuICAgICAgICBlbmNSZWMuZW5jcnlwdGVkX2tleSA9IGZyb21CYXNlNjR1cmwocmVjaXBpZW50LmVuY3J5cHRlZF9rZXkpO1xuICAgIGlmIChyZWNpcGllbnQuaGVhZGVyKVxuICAgICAgICBlbmNSZWMuaGVhZGVyID0gcmVjaXBpZW50LmhlYWRlcjtcbiAgICByZXR1cm4gZW5jUmVjO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShqd2UpIHtcbiAgICBjb25zdCBlbmNKd2UgPSB7XG4gICAgICAgIGNpcGhlcnRleHQ6IGZyb21CYXNlNjR1cmwoandlLmNpcGhlcnRleHQpLFxuICAgICAgICBwcm90ZWN0ZWQ6IGZyb21CYXNlNjR1cmwoandlLnByb3RlY3RlZCksXG4gICAgICAgIGl2OiBmcm9tQmFzZTY0dXJsKGp3ZS5pdiksXG4gICAgICAgIHRhZzogZnJvbUJhc2U2NHVybChqd2UudGFnKSxcbiAgICB9O1xuICAgIGlmIChqd2UuYWFkKVxuICAgICAgICBlbmNKd2UuYWFkID0gZnJvbUJhc2U2NHVybChqd2UuYWFkKTtcbiAgICBpZiAoandlLnJlY2lwaWVudHMpXG4gICAgICAgIGVuY0p3ZS5yZWNpcGllbnRzID0gandlLnJlY2lwaWVudHMubWFwKGVuY29kZVJlY2lwaWVudCk7XG4gICAgaWYgKGp3ZS51bnByb3RlY3RlZClcbiAgICAgICAgZW5jSndlLnVucHJvdGVjdGVkID0gandlLnVucHJvdGVjdGVkO1xuICAgIHJldHVybiBlbmNKd2U7XG59XG5mdW5jdGlvbiBkZWNvZGVSZWNpcGllbnQoZW5jb2RlZCkge1xuICAgIGNvbnN0IHJlY2lwaWVudCA9IHt9O1xuICAgIGlmIChlbmNvZGVkLmVuY3J5cHRlZF9rZXkpXG4gICAgICAgIHJlY2lwaWVudC5lbmNyeXB0ZWRfa2V5ID0gdG9CYXNlNjR1cmwoZW5jb2RlZC5lbmNyeXB0ZWRfa2V5KTtcbiAgICBpZiAoZW5jb2RlZC5oZWFkZXIpXG4gICAgICAgIHJlY2lwaWVudC5oZWFkZXIgPSBlbmNvZGVkLmhlYWRlcjtcbiAgICByZXR1cm4gcmVjaXBpZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShlbmNvZGVkKSB7XG4gICAgY29uc3QgandlID0ge1xuICAgICAgICBjaXBoZXJ0ZXh0OiB0b0Jhc2U2NHVybChlbmNvZGVkLmNpcGhlcnRleHQpLFxuICAgICAgICBwcm90ZWN0ZWQ6IHRvQmFzZTY0dXJsKGVuY29kZWQucHJvdGVjdGVkKSxcbiAgICAgICAgaXY6IHRvQmFzZTY0dXJsKGVuY29kZWQuaXYpLFxuICAgICAgICB0YWc6IHRvQmFzZTY0dXJsKGVuY29kZWQudGFnKSxcbiAgICB9O1xuICAgIGlmIChlbmNvZGVkLmFhZClcbiAgICAgICAgandlLmFhZCA9IHRvQmFzZTY0dXJsKGVuY29kZWQuYWFkKTtcbiAgICBpZiAoZW5jb2RlZC5yZWNpcGllbnRzKVxuICAgICAgICBqd2UucmVjaXBpZW50cyA9IGVuY29kZWQucmVjaXBpZW50cy5tYXAoZGVjb2RlUmVjaXBpZW50KTtcbiAgICBpZiAoZW5jb2RlZC51bnByb3RlY3RlZClcbiAgICAgICAgandlLnVucHJvdGVjdGVkID0gZW5jb2RlZC51bnByb3RlY3RlZDtcbiAgICByZXR1cm4gandlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jcnlwdGlvbi5qcy5tYXAiLCJpbXBvcnQgKiBhcyBzaWduaW5nIGZyb20gJy4vc2lnbmluZy5qcyc7XG5pbXBvcnQgKiBhcyBlbmNyeXB0aW9uIGZyb20gJy4vZW5jcnlwdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ0BpcGxkL2RhZy1jYm9yJztcbmV4cG9ydCBjb25zdCBuYW1lID0gJ2RhZy1qb3NlJztcbmV4cG9ydCBjb25zdCBjb2RlID0gMTMzO1xuZnVuY3Rpb24gaXNEYWdKV1Moam9zZSkge1xuICAgIHJldHVybiAoJ3BheWxvYWQnIGluIGpvc2UgJiZcbiAgICAgICAgdHlwZW9mIGpvc2UucGF5bG9hZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgJ3NpZ25hdHVyZXMnIGluIGpvc2UgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShqb3NlLnNpZ25hdHVyZXMpKTtcbn1cbmZ1bmN0aW9uIGlzRW5jb2RlZEpXUyhqb3NlKSB7XG4gICAgcmV0dXJuICgncGF5bG9hZCcgaW4gam9zZSAmJlxuICAgICAgICBqb3NlLnBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmXG4gICAgICAgICdzaWduYXR1cmVzJyBpbiBqb3NlICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoam9zZS5zaWduYXR1cmVzKSk7XG59XG5mdW5jdGlvbiBpc0VuY29kZWRKV0Uoam9zZSkge1xuICAgIHJldHVybiAoJ2NpcGhlcnRleHQnIGluIGpvc2UgJiZcbiAgICAgICAgam9zZS5jaXBoZXJ0ZXh0IGluc3RhbmNlb2YgVWludDhBcnJheSAmJlxuICAgICAgICAnaXYnIGluIGpvc2UgJiZcbiAgICAgICAgam9zZS5pdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiZcbiAgICAgICAgJ3Byb3RlY3RlZCcgaW4gam9zZSAmJlxuICAgICAgICBqb3NlLnByb3RlY3RlZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiZcbiAgICAgICAgJ3RhZycgaW4gam9zZSAmJlxuICAgICAgICBqb3NlLnRhZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xufVxuZnVuY3Rpb24gaXNEYWdKV0Uoam9zZSkge1xuICAgIHJldHVybiAoJ2NpcGhlcnRleHQnIGluIGpvc2UgJiZcbiAgICAgICAgdHlwZW9mIGpvc2UuY2lwaGVydGV4dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgJ2l2JyBpbiBqb3NlICYmXG4gICAgICAgIHR5cGVvZiBqb3NlLml2ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAncHJvdGVjdGVkJyBpbiBqb3NlICYmXG4gICAgICAgIHR5cGVvZiBqb3NlLnByb3RlY3RlZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgJ3RhZycgaW4gam9zZSAmJlxuICAgICAgICB0eXBlb2Ygam9zZS50YWcgPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0dlbmVyYWwoam9zZSkge1xuICAgIGlmICh0eXBlb2Ygam9zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBqb3NlLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduaW5nLmZyb21TcGxpdChzcGxpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BsaXQubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jcnlwdGlvbi5mcm9tU3BsaXQoc3BsaXQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgSk9TRSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGlzRGFnSldTKGpvc2UpIHx8IGlzRGFnSldFKGpvc2UpKSB7XG4gICAgICAgIHJldHVybiBqb3NlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIHVuZW5jb2RlZCBKT1NFIG9iamVjdCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqID0gdG9HZW5lcmFsKG9iaik7XG4gICAgfVxuICAgIGxldCBlbmNvZGVkSm9zZTtcbiAgICBpZiAoaXNEYWdKV1Mob2JqKSkge1xuICAgICAgICBlbmNvZGVkSm9zZSA9IHNpZ25pbmcuZW5jb2RlKG9iaik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGFnSldFKG9iaikpIHtcbiAgICAgICAgZW5jb2RlZEpvc2UgPSBlbmNyeXB0aW9uLmVuY29kZShvYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBKT1NFIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2Jvci5lbmNvZGUoZW5jb2RlZEpvc2UpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoZGF0YSkge1xuICAgIGxldCBlbmNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGVuY29kZWQgPSBjYm9yLmRlY29kZShkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBEQUctSk9TRSBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKGlzRW5jb2RlZEpXUyhlbmNvZGVkKSkge1xuICAgICAgICByZXR1cm4gc2lnbmluZy5kZWNvZGUoZW5jb2RlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRW5jb2RlZEpXRShlbmNvZGVkKSkge1xuICAgICAgICByZXR1cm4gZW5jcnlwdGlvbi5kZWNvZGUoZW5jb2RlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIERBRy1KT1NFIG9iamVjdCcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGZyb21CYXNlNjR1cmwsIHRvQmFzZTY0dXJsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3BsaXQoc3BsaXQpIHtcbiAgICBjb25zdCBbcHJvdGVjdGVkSGVhZGVyLCBwYXlsb2FkLCBzaWduYXR1cmVdID0gc3BsaXQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgc2lnbmF0dXJlczogW3sgcHJvdGVjdGVkOiBwcm90ZWN0ZWRIZWFkZXIsIHNpZ25hdHVyZSB9XSxcbiAgICAgICAgbGluazogQ0lELmRlY29kZShmcm9tQmFzZTY0dXJsKHBheWxvYWQpKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGVuY29kZWQgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogZnJvbUJhc2U2NHVybChzaWduYXR1cmUuc2lnbmF0dXJlKSxcbiAgICB9O1xuICAgIGlmIChzaWduYXR1cmUuaGVhZGVyKVxuICAgICAgICBlbmNvZGVkLmhlYWRlciA9IHNpZ25hdHVyZS5oZWFkZXI7XG4gICAgaWYgKHNpZ25hdHVyZS5wcm90ZWN0ZWQpXG4gICAgICAgIGVuY29kZWQucHJvdGVjdGVkID0gZnJvbUJhc2U2NHVybChzaWduYXR1cmUucHJvdGVjdGVkKTtcbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoandzKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGZyb21CYXNlNjR1cmwoandzLnBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICAgIENJRC5kZWNvZGUocGF5bG9hZCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgRGFnSldTJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHNpZ25hdHVyZXM6IGp3cy5zaWduYXR1cmVzLm1hcChlbmNvZGVTaWduYXR1cmUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBkZWNvZGVTaWduYXR1cmUoZW5jb2RlZCkge1xuICAgIGNvbnN0IHNpZ24gPSB7XG4gICAgICAgIHNpZ25hdHVyZTogdG9CYXNlNjR1cmwoZW5jb2RlZC5zaWduYXR1cmUpLFxuICAgIH07XG4gICAgaWYgKGVuY29kZWQuaGVhZGVyKVxuICAgICAgICBzaWduLmhlYWRlciA9IGVuY29kZWQuaGVhZGVyO1xuICAgIGlmIChlbmNvZGVkLnByb3RlY3RlZClcbiAgICAgICAgc2lnbi5wcm90ZWN0ZWQgPSB0b0Jhc2U2NHVybChlbmNvZGVkLnByb3RlY3RlZCk7XG4gICAgcmV0dXJuIHNpZ247XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGVuY29kZWQpIHtcbiAgICBjb25zdCBkZWNvZGVkID0ge1xuICAgICAgICBwYXlsb2FkOiB0b0Jhc2U2NHVybChlbmNvZGVkLnBheWxvYWQpLFxuICAgICAgICBzaWduYXR1cmVzOiBlbmNvZGVkLnNpZ25hdHVyZXMubWFwKGRlY29kZVNpZ25hdHVyZSksXG4gICAgfTtcbiAgICBkZWNvZGVkLmxpbmsgPSBDSUQuZGVjb2RlKG5ldyBVaW50OEFycmF5KGVuY29kZWQucGF5bG9hZCkpO1xuICAgIHJldHVybiBkZWNvZGVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmluZy5qcy5tYXAiLCJpbXBvcnQgeyBiYXNlNjR1cmwgfSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzZXMvYmFzZTY0JztcbmV4cG9ydCBmdW5jdGlvbiB0b0Jhc2U2NHVybChiKSB7XG4gICAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoYikuc2xpY2UoMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUJhc2U2NHVybChzKSB7XG4gICAgcmV0dXJuIGJhc2U2NHVybC5kZWNvZGUoYHUke3N9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyByYW5kb21GaWxsU3luYyB9IGZyb20gJ2NyeXB0bydcbmltcG9ydCB7IHVybEFscGhhYmV0IH0gZnJvbSAnLi91cmwtYWxwaGFiZXQvaW5kZXguanMnXG5leHBvcnQgeyB1cmxBbHBoYWJldCB9XG5jb25zdCBQT09MX1NJWkVfTVVMVElQTElFUiA9IDEyOFxubGV0IHBvb2wsIHBvb2xPZmZzZXRcbmxldCBmaWxsUG9vbCA9IGJ5dGVzID0+IHtcbiAgaWYgKCFwb29sIHx8IHBvb2wubGVuZ3RoIDwgYnl0ZXMpIHtcbiAgICBwb29sID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzICogUE9PTF9TSVpFX01VTFRJUExJRVIpXG4gICAgcmFuZG9tRmlsbFN5bmMocG9vbClcbiAgICBwb29sT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKHBvb2xPZmZzZXQgKyBieXRlcyA+IHBvb2wubGVuZ3RoKSB7XG4gICAgcmFuZG9tRmlsbFN5bmMocG9vbClcbiAgICBwb29sT2Zmc2V0ID0gMFxuICB9XG4gIHBvb2xPZmZzZXQgKz0gYnl0ZXNcbn1cbmV4cG9ydCBsZXQgcmFuZG9tID0gYnl0ZXMgPT4ge1xuICBmaWxsUG9vbCgoYnl0ZXMgLT0gMCkpXG4gIHJldHVybiBwb29sLnN1YmFycmF5KHBvb2xPZmZzZXQgLSBieXRlcywgcG9vbE9mZnNldClcbn1cbmV4cG9ydCBsZXQgY3VzdG9tUmFuZG9tID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKDMxIC0gTWF0aC5jbHozMigoYWxwaGFiZXQubGVuZ3RoIC0gMSkgfCAxKSkpIC0gMVxuICBsZXQgc3RlcCA9IE1hdGguY2VpbCgoMS42ICogbWFzayAqIGRlZmF1bHRTaXplKSAvIGFscGhhYmV0Lmxlbmd0aClcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBnZXRSYW5kb20oc3RlcClcbiAgICAgIGxldCBpID0gc3RlcFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZCArPSBhbHBoYWJldFtieXRlc1tpXSAmIG1hc2tdIHx8ICcnXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IHNpemUpIHJldHVybiBpZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IGxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgc2l6ZSA9IDIxKSA9PlxuICBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcbmV4cG9ydCBsZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBmaWxsUG9vbCgoc2l6ZSAtPSAwKSlcbiAgbGV0IGlkID0gJydcbiAgZm9yIChsZXQgaSA9IHBvb2xPZmZzZXQgLSBzaXplOyBpIDwgcG9vbE9mZnNldDsgaSsrKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbcG9vbFtpXSAmIDYzXVxuICB9XG4gIHJldHVybiBpZFxufVxuIiwiZXhwb3J0IGNvbnN0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG4iLCJpbXBvcnQgaHR0cCBmcm9tICdodHRwJ1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJ1xuXG4vKipcbiAqIEBwYXJhbSB7VVJMfSBbdXJsXVxuICovXG5leHBvcnQgZGVmYXVsdCAodXJsKSA9PiB7XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgcmVxdWlyZWQnKVxuICB9XG5cbiAgcmV0dXJuIHVybC5wcm90b2NvbC5zdGFydHNXaXRoKCdodHRwcycpID8gaHR0cHMuQWdlbnQgOiBodHRwLkFnZW50XG59XG4iLCJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSdcbmltcG9ydCBicm93c2VyU3RyZWFtVG9JdCBmcm9tICdicm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0J1xuaW1wb3J0IGl0UGVla2FibGUgZnJvbSAnaXQtcGVla2FibGUnXG5pbXBvcnQgbWFwIGZyb20gJ2l0LW1hcCdcbmltcG9ydCB7XG4gIGlzQnl0ZXMsXG4gIGlzQmxvYixcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNGaWxlT2JqZWN0XG59IGZyb20gJy4vdXRpbHMuanMnXG5pbXBvcnQge1xuICBwYXJzZU10aW1lLFxuICBwYXJzZU1vZGVcbn0gZnJvbSAnaXBmcy11bml4ZnMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLkltcG9ydENhbmRpZGF0ZX0gSW1wb3J0Q2FuZGlkYXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuVG9Db250ZW50fSBUb0NvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtdW5peGZzLWltcG9ydGVyJykuSW1wb3J0Q2FuZGlkYXRlfSBJbXBvcnRlckltcG9ydENhbmRpZGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLkltcG9ydENhbmRpZGF0ZVN0cmVhbX0gSW1wb3J0Q2FuZGlkYXRlU3RyZWFtXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ltcG9ydENhbmRpZGF0ZVN0cmVhbX0gaW5wdXRcbiAqIEBwYXJhbSB7KGNvbnRlbnQ6VG9Db250ZW50KSA9PiBQcm9taXNlPEFzeW5jSXRlcmFibGU8VWludDhBcnJheT4+fSBub3JtYWxpc2VDb250ZW50XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gKiBub3JtYWxpc2VDYW5kaWRhdGVNdWx0aXBsZSAoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpIHtcbiAgLy8gU3RyaW5nXG4gIC8vIFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8VHlwZWRBcnJheVxuICAvLyBCbG9ifEZpbGVcbiAgLy8gZnMuUmVhZFN0cmVhbVxuICAvLyBAdHMtZXhwZWN0LWVycm9yIF9yZWFkYWJsZVN0YXRlIGlzIGEgcHJvcGVydHkgb2YgYSBub2RlIGZzLlJlYWRTdHJlYW1cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgaXNCeXRlcyhpbnB1dCkgfHwgaXNCbG9iKGlucHV0KSB8fCBpbnB1dC5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiBzaW5nbGUgaXRlbSBwYXNzZWQgLSBpZiB5b3UgYXJlIHVzaW5nIGlwZnMuYWRkQWxsLCBwbGVhc2UgdXNlIGlwZnMuYWRkIGluc3RlYWQnKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJylcbiAgfVxuXG4gIC8vIEJyb3dzZXIgUmVhZGFibGVTdHJlYW1cbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBicm93c2VyU3RyZWFtVG9JdChpbnB1dClcbiAgfVxuXG4gIC8vIEl0ZXJhYmxlPD8+XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpXG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcGVla2FibGUucGVlaygpXG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgLy8gbWFrZSBzdXJlIGVtcHR5IGl0ZXJhdG9ycyByZXN1bHQgaW4gZW1wdHkgZmlsZXNcbiAgICAgIHlpZWxkICogW11cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHBlZWthYmxlLnB1c2godmFsdWUpXG5cbiAgICAvLyAoQXN5bmMpSXRlcmFibGU8TnVtYmVyPlxuICAgIC8vIChBc3luYylJdGVyYWJsZTxCeXRlcz5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiBzaW5nbGUgaXRlbSBwYXNzZWQgLSBpZiB5b3UgYXJlIHVzaW5nIGlwZnMuYWRkQWxsLCBwbGVhc2UgdXNlIGlwZnMuYWRkIGluc3RlYWQnKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJylcbiAgICB9XG5cbiAgICAvLyAoQXN5bmMpSXRlcmFibGU8ZnMuUmVhZFN0cmVhbT5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHByaXZhdGUgZmllbGRcbiAgICBpZiAodmFsdWUuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTm9kZSBmcy5SZWFkU3RyZWFtcyBoYXZlIGEgYC5wYXRoYCBwcm9wZXJ0eSBzbyB3ZSBuZWVkIHRvIHBhc3MgaXQgYXMgdGhlIGNvbnRlbnRcbiAgICAgIHlpZWxkICogbWFwKHBlZWthYmxlLCAoLyoqIEB0eXBlIHtJbXBvcnRDYW5kaWRhdGV9ICovIHZhbHVlKSA9PiB0b0ZpbGVPYmplY3QoeyBjb250ZW50OiB2YWx1ZSB9LCBub3JtYWxpc2VDb250ZW50KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwZWVrYWJsZSBpcyBzdGlsbCBhbiBpdGVyYWJsZSBvZiBJbXBvcnRDYW5kaWRhdGVzXG4gICAgICB5aWVsZCB0b0ZpbGVPYmplY3QoeyBjb250ZW50OiBwZWVrYWJsZSB9LCBub3JtYWxpc2VDb250ZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gKEFzeW5jKUl0ZXJhYmxlPChBc3luYylJdGVyYWJsZTw/Pj5cbiAgICAvLyAoQXN5bmMpSXRlcmFibGU8UmVhZGFibGVTdHJlYW08Pz4+XG4gICAgLy8gUmVhZGFibGVTdHJlYW08KEFzeW5jKUl0ZXJhYmxlPD8+PlxuICAgIC8vIFJlYWRhYmxlU3RyZWFtPFJlYWRhYmxlU3RyZWFtPD8+PlxuICAgIGlmIChpc0ZpbGVPYmplY3QodmFsdWUpIHx8IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gfHwgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdIHx8IGlzUmVhZGFibGVTdHJlYW0odmFsdWUpIHx8IGlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHlpZWxkICogbWFwKHBlZWthYmxlLCAoLyoqIEB0eXBlIHtJbXBvcnRDYW5kaWRhdGV9ICovIHZhbHVlKSA9PiB0b0ZpbGVPYmplY3QodmFsdWUsIG5vcm1hbGlzZUNvbnRlbnQpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy8geyBwYXRoLCBjb250ZW50OiA/IH1cbiAgLy8gTm90ZTogRGV0ZWN0ZWQgX2FmdGVyXyAoQXN5bmMpSXRlcmFibGU8Pz4gYmVjYXVzZSBOb2RlLmpzIGZzLlJlYWRTdHJlYW1zIGhhdmUgYVxuICAvLyBgcGF0aGAgcHJvcGVydHkgdGhhdCBwYXNzZXMgdGhpcyBjaGVjay5cbiAgaWYgKGlzRmlsZU9iamVjdChpbnB1dCkpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogc2luZ2xlIGl0ZW0gcGFzc2VkIC0gaWYgeW91IGFyZSB1c2luZyBpcGZzLmFkZEFsbCwgcGxlYXNlIHVzZSBpcGZzLmFkZCBpbnN0ZWFkJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpXG4gIH1cblxuICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJbXBvcnRDYW5kaWRhdGV9IGlucHV0XG4gKiBAcGFyYW0geyhjb250ZW50OlRvQ29udGVudCkgPT4gUHJvbWlzZTxBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+Pn0gbm9ybWFsaXNlQ29udGVudFxuICovXG5hc3luYyBmdW5jdGlvbiB0b0ZpbGVPYmplY3QgKGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUaG9zZSBwcm9wZXJ0aWVzIGRvbid0IGV4aXN0IG9uIG1vc3QgaW5wdXQgdHlwZXNcbiAgY29uc3QgeyBwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudCB9ID0gaW5wdXRcblxuICAvKiogQHR5cGUge0ltcG9ydGVySW1wb3J0Q2FuZGlkYXRlfSAqL1xuICBjb25zdCBmaWxlID0ge1xuICAgIHBhdGg6IHBhdGggfHwgJycsXG4gICAgbW9kZTogcGFyc2VNb2RlKG1vZGUpLFxuICAgIG10aW1lOiBwYXJzZU10aW1lKG10aW1lKVxuICB9XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSBhd2FpdCBub3JtYWxpc2VDb250ZW50KGNvbnRlbnQpXG4gIH0gZWxzZSBpZiAoIXBhdGgpIHsgLy8gTm90IGFscmVhZHkgYSBmaWxlIG9iamVjdCB3aXRoIHBhdGggb3IgY29udGVudCBwcm9wXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlucHV0IHN0aWxsIGNhbiBiZSBkaWZmZXJlbnQgVG9Db250ZW50XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChpbnB1dClcbiAgfVxuXG4gIHJldHVybiBmaWxlXG59XG4iLCJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSdcbmltcG9ydCBicm93c2VyU3RyZWFtVG9JdCBmcm9tICdicm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0J1xuaW1wb3J0IGl0UGVla2FibGUgZnJvbSAnaXQtcGVla2FibGUnXG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzRmlsZU9iamVjdFxufSBmcm9tICcuL3V0aWxzLmpzJ1xuaW1wb3J0IHtcbiAgcGFyc2VNdGltZSxcbiAgcGFyc2VNb2RlXG59IGZyb20gJ2lwZnMtdW5peGZzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5Ub0NvbnRlbnR9IFRvQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy11bml4ZnMtaW1wb3J0ZXInKS5JbXBvcnRDYW5kaWRhdGV9IEltcG9ydGVySW1wb3J0Q2FuZGlkYXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuSW1wb3J0Q2FuZGlkYXRlfSBJbXBvcnRDYW5kaWRhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5JbXBvcnRDYW5kaWRhdGVTdHJlYW19IEltcG9ydENhbmRpZGF0ZVN0cmVhbVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtJbXBvcnRDYW5kaWRhdGV9IGlucHV0XG4gKiBAcGFyYW0geyhjb250ZW50OlRvQ29udGVudCkgPT4gUHJvbWlzZTxBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+Pn0gbm9ybWFsaXNlQ29udGVudFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uICogbm9ybWFsaXNlQ2FuZGlkYXRlU2luZ2xlIChpbnB1dCwgbm9ybWFsaXNlQ29udGVudCkge1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiAke2lucHV0fWApLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKVxuICB9XG5cbiAgLy8gU3RyaW5nXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgeWllbGQgdG9GaWxlT2JqZWN0KGlucHV0LnRvU3RyaW5nKCksIG5vcm1hbGlzZUNvbnRlbnQpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBVaW50OEFycmF5fEFycmF5QnVmZmVyfFR5cGVkQXJyYXlcbiAgLy8gQmxvYnxGaWxlXG4gIGlmIChpc0J5dGVzKGlucHV0KSB8fCBpc0Jsb2IoaW5wdXQpKSB7XG4gICAgeWllbGQgdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gQnJvd3NlciBSZWFkYWJsZVN0cmVhbVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGJyb3dzZXJTdHJlYW1Ub0l0KGlucHV0KVxuICB9XG5cbiAgLy8gSXRlcmFibGU8Pz5cbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBpbnB1dCB8fCBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBpbnB1dCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQncyAoYXN5bmMpaXRlcmFibGVcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpXG5cbiAgICAvKiogQHR5cGUge2FueX0gdmFsdWUgKiovXG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcGVla2FibGUucGVlaygpXG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgLy8gbWFrZSBzdXJlIGVtcHR5IGl0ZXJhdG9ycyByZXN1bHQgaW4gZW1wdHkgZmlsZXNcbiAgICAgIHlpZWxkIHsgY29udGVudDogW10gfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSlcblxuICAgIC8vIChBc3luYylJdGVyYWJsZTxOdW1iZXI+XG4gICAgLy8gKEFzeW5jKUl0ZXJhYmxlPEJ5dGVzPlxuICAgIC8vIChBc3luYylJdGVyYWJsZTxTdHJpbmc+XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IGlzQnl0ZXModmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHlpZWxkIHRvRmlsZU9iamVjdChwZWVrYWJsZSwgbm9ybWFsaXNlQ29udGVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiBtdWx0aXBsZSBpdGVtcyBwYXNzZWQgLSBpZiB5b3UgYXJlIHVzaW5nIGlwZnMuYWRkLCBwbGVhc2UgdXNlIGlwZnMuYWRkQWxsIGluc3RlYWQnKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJylcbiAgfVxuXG4gIC8vIHsgcGF0aCwgY29udGVudDogPyB9XG4gIC8vIE5vdGU6IERldGVjdGVkIF9hZnRlcl8gKEFzeW5jKUl0ZXJhYmxlPD8+IGJlY2F1c2UgTm9kZS5qcyBmcy5SZWFkU3RyZWFtcyBoYXZlIGFcbiAgLy8gYHBhdGhgIHByb3BlcnR5IHRoYXQgcGFzc2VzIHRoaXMgY2hlY2suXG4gIGlmIChpc0ZpbGVPYmplY3QoaW5wdXQpKSB7XG4gICAgeWllbGQgdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQ6IGNhbm5vdCBjb252ZXJ0IFwiJyArIHR5cGVvZiBpbnB1dCArICdcIiBpbnRvIEltcG9ydENhbmRpZGF0ZScpLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW1wb3J0Q2FuZGlkYXRlfSBpbnB1dFxuICogQHBhcmFtIHsoY29udGVudDpUb0NvbnRlbnQpID0+IFByb21pc2U8QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pj59IG5vcm1hbGlzZUNvbnRlbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9GaWxlT2JqZWN0IChpbnB1dCwgbm9ybWFsaXNlQ29udGVudCkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVGhvc2UgcHJvcGVydGllcyBkb24ndCBleGlzdCBvbiBtb3N0IGlucHV0IHR5cGVzXG4gIGNvbnN0IHsgcGF0aCwgbW9kZSwgbXRpbWUsIGNvbnRlbnQgfSA9IGlucHV0XG5cbiAgLyoqIEB0eXBlIHtJbXBvcnRlckltcG9ydENhbmRpZGF0ZX0gKi9cbiAgY29uc3QgZmlsZSA9IHtcbiAgICBwYXRoOiBwYXRoIHx8ICcnLFxuICAgIG1vZGU6IHBhcnNlTW9kZShtb2RlKSxcbiAgICBtdGltZTogcGFyc2VNdGltZShtdGltZSlcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChjb250ZW50KVxuICB9IGVsc2UgaWYgKCFwYXRoKSB7IC8vIE5vdCBhbHJlYWR5IGEgZmlsZSBvYmplY3Qgd2l0aCBwYXRoIG9yIGNvbnRlbnQgcHJvcFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpbnB1dCBzdGlsbCBjYW4gYmUgZGlmZmVyZW50IFRvQ29udGVudFxuICAgIGZpbGUuY29udGVudCA9IGF3YWl0IG5vcm1hbGlzZUNvbnRlbnQoaW5wdXQpXG4gIH1cblxuICByZXR1cm4gZmlsZVxufVxuIiwiaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnXG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSdcbmltcG9ydCBicm93c2VyU3RyZWFtVG9JdCBmcm9tICdicm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0J1xuaW1wb3J0IGFsbCBmcm9tICdpdC1hbGwnXG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW1cbn0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLlRvQ29udGVudH0gaW5wdXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5vcm1hbGlzZUNvbnRlbnQgKGlucHV0KSB7XG4gIC8vIEJ5dGVzXG4gIGlmIChpc0J5dGVzKGlucHV0KSkge1xuICAgIHJldHVybiBuZXcgQmxvYihbaW5wdXRdKVxuICB9XG5cbiAgLy8gU3RyaW5nXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtpbnB1dC50b1N0cmluZygpXSlcbiAgfVxuXG4gIC8vIEJsb2IgfCBGaWxlXG4gIGlmIChpc0Jsb2IoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0XG4gIH1cblxuICAvLyBCcm93c2VyIHN0cmVhbVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGJyb3dzZXJTdHJlYW1Ub0l0KGlucHV0KVxuICB9XG5cbiAgLy8gKEFzeW5jKUl0ZXJhdG9yPD8+XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICAvKiogQHR5cGUge2FueX0gcGVla2FibGUgKi9cbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpXG5cbiAgICAvKiogQHR5cGUge2FueX0gdmFsdWUgKiovXG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcGVla2FibGUucGVlaygpXG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgLy8gbWFrZSBzdXJlIGVtcHR5IGl0ZXJhdG9ycyByZXN1bHQgaW4gZW1wdHkgZmlsZXNcbiAgICAgIHJldHVybiBpdFRvQmxvYihwZWVrYWJsZSlcbiAgICB9XG5cbiAgICBwZWVrYWJsZS5wdXNoKHZhbHVlKVxuXG4gICAgLy8gKEFzeW5jKUl0ZXJhYmxlPE51bWJlcj5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZXcgQmxvYihbVWludDhBcnJheS5mcm9tKGF3YWl0IGFsbChwZWVrYWJsZSkpXSlcbiAgICB9XG5cbiAgICAvLyAoQXN5bmMpSXRlcmFibGU8Qnl0ZXN8U3RyaW5nPlxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gaXRUb0Jsb2IocGVla2FibGUpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQ6ICR7aW5wdXR9YCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPEJsb2JQYXJ0PnxJdGVyYWJsZTxCbG9iUGFydD59IHN0cmVhbVxuICovXG5hc3luYyBmdW5jdGlvbiBpdFRvQmxvYiAoc3RyZWFtKSB7XG4gIGNvbnN0IHBhcnRzID0gW11cblxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIHBhcnRzLnB1c2goY2h1bmspXG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IocGFydHMpXG59XG4iLCJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSdcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZydcbmltcG9ydCBicm93c2VyU3RyZWFtVG9JdCBmcm9tICdicm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0J1xuaW1wb3J0IGJsb2JUb0l0IGZyb20gJ2Jsb2ItdG8taXQnXG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSdcbmltcG9ydCBhbGwgZnJvbSAnaXQtYWxsJ1xuaW1wb3J0IG1hcCBmcm9tICdpdC1tYXAnXG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc0Jsb2Jcbn0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0aGluZ1xuICovXG5hc3luYyBmdW5jdGlvbiAqIHRvQXN5bmNJdGVyYWJsZSAodGhpbmcpIHtcbiAgeWllbGQgdGhpbmdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLlRvQ29udGVudH0gaW5wdXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5vcm1hbGlzZUNvbnRlbnQgKGlucHV0KSB7XG4gIC8vIEJ5dGVzIHwgU3RyaW5nXG4gIGlmIChpc0J5dGVzKGlucHV0KSkge1xuICAgIHJldHVybiB0b0FzeW5jSXRlcmFibGUodG9CeXRlcyhpbnB1dCkpXG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiB0b0FzeW5jSXRlcmFibGUodG9CeXRlcyhpbnB1dC50b1N0cmluZygpKSlcbiAgfVxuXG4gIC8vIEJsb2JcbiAgaWYgKGlzQmxvYihpbnB1dCkpIHtcbiAgICByZXR1cm4gYmxvYlRvSXQoaW5wdXQpXG4gIH1cblxuICAvLyBCcm93c2VyIHN0cmVhbVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGJyb3dzZXJTdHJlYW1Ub0l0KGlucHV0KVxuICB9XG5cbiAgLy8gKEFzeW5jKUl0ZXJhdG9yPD8+XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICAvKiogQHR5cGUge2FueX0gcGVla2FibGUgKi9cbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpXG5cbiAgICAvKiogQHR5cGUge2FueX0gdmFsdWUgKi9cbiAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKClcblxuICAgIGlmIChkb25lKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgZW1wdHkgaXRlcmF0b3JzIHJlc3VsdCBpbiBlbXB0eSBmaWxlc1xuICAgICAgcmV0dXJuIHRvQXN5bmNJdGVyYWJsZShuZXcgVWludDhBcnJheSgwKSlcbiAgICB9XG5cbiAgICBwZWVrYWJsZS5wdXNoKHZhbHVlKVxuXG4gICAgLy8gKEFzeW5jKUl0ZXJhYmxlPE51bWJlcj5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b0FzeW5jSXRlcmFibGUoVWludDhBcnJheS5mcm9tKGF3YWl0IGFsbChwZWVrYWJsZSkpKVxuICAgIH1cblxuICAgIC8vIChBc3luYylJdGVyYWJsZTxCeXRlc3xTdHJpbmc+XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHJldHVybiBtYXAocGVla2FibGUsIHRvQnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQ6ICR7aW5wdXR9YCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlciB8IEFycmF5QnVmZmVyVmlldyB8IHN0cmluZyB8IEluc3RhbmNlVHlwZTx0eXBlb2Ygd2luZG93LlN0cmluZz4gfCBudW1iZXJbXX0gY2h1bmtcbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyAoY2h1bmspIHtcbiAgaWYgKGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjaHVua1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKVxuICB9XG5cbiAgaWYgKGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjaHVuaykpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNodW5rKVxuICB9XG5cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGNodW5rLnRvU3RyaW5nKCkpXG59XG4iLCJpbXBvcnQgeyBub3JtYWxpc2VDb250ZW50IH0gZnJvbSAnLi9ub3JtYWxpc2UtY29udGVudC5icm93c2VyLmpzJ1xuaW1wb3J0IHsgbm9ybWFsaXNlQ2FuZGlkYXRlTXVsdGlwbGUgfSBmcm9tICcuL25vcm1hbGlzZS1jYW5kaWRhdGUtbXVsdGlwbGUuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLkltcG9ydENhbmRpZGF0ZVN0cmVhbX0gSW1wb3J0Q2FuZGlkYXRlU3RyZWFtXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuQnJvd3NlckltcG9ydENhbmRpZGF0ZX0gQnJvd3NlckltcG9ydENhbmRpZGF0ZVxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbnkgb2YgdGhlIGBpcGZzLmFkZEFsbGAgaW5wdXQgdHlwZXMgaW50b1xuICpcbiAqIGBgYFxuICogQXN5bmNJdGVyYWJsZTx7IHBhdGgsIG1vZGUsIG10aW1lLCBjb250ZW50OiBCbG9iIH0+XG4gKiBgYGBcbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvanMtaXBmcy9ibG9iL21hc3Rlci9kb2NzL2NvcmUtYXBpL0ZJTEVTLm1kI2lwZnNhZGRkYXRhLW9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge0ltcG9ydENhbmRpZGF0ZVN0cmVhbX0gaW5wdXRcbiAqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxCcm93c2VySW1wb3J0Q2FuZGlkYXRlLCB2b2lkLCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXNlSW5wdXQgKGlucHV0KSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgYnJvd3NlciBub3JtYWxpc2VDb250ZW50IHJldHVybnMgYSBCbG9iIG5vdCBhbiBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+XG4gIHJldHVybiBub3JtYWxpc2VDYW5kaWRhdGVNdWx0aXBsZShpbnB1dCwgbm9ybWFsaXNlQ29udGVudCwgdHJ1ZSlcbn1cbiIsImltcG9ydCB7IG5vcm1hbGlzZUNvbnRlbnQgfSBmcm9tICcuL25vcm1hbGlzZS1jb250ZW50LmpzJ1xuaW1wb3J0IHsgbm9ybWFsaXNlQ2FuZGlkYXRlTXVsdGlwbGUgfSBmcm9tICcuL25vcm1hbGlzZS1jYW5kaWRhdGUtbXVsdGlwbGUuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLkltcG9ydENhbmRpZGF0ZVN0cmVhbX0gSW1wb3J0Q2FuZGlkYXRlU3RyZWFtXG4gKi9cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFueSBvZiB0aGUgYGlwZnMuYWRkQWxsYCBpbnB1dCB0eXBlcyBpbnRvXG4gKlxuICogYGBgXG4gKiBBc3luY0l0ZXJhYmxlPHsgcGF0aCwgbW9kZSwgbXRpbWUsIGNvbnRlbnQ6IEFzeW5jSXRlcmFibGU8VWludDhBcnJheT4gfT5cbiAqIGBgYFxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaXBmcy9qcy1pcGZzL2Jsb2IvbWFzdGVyL2RvY3MvY29yZS1hcGkvRklMRVMubWQjaXBmc2FkZGRhdGEtb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7SW1wb3J0Q2FuZGlkYXRlU3RyZWFtfSBpbnB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXNlSW5wdXQgKGlucHV0KSB7XG4gIHJldHVybiBub3JtYWxpc2VDYW5kaWRhdGVNdWx0aXBsZShpbnB1dCwgbm9ybWFsaXNlQ29udGVudClcbn1cbiIsImltcG9ydCB7IG5vcm1hbGlzZUNvbnRlbnQgfSBmcm9tICcuL25vcm1hbGlzZS1jb250ZW50LmpzJ1xuaW1wb3J0IHsgbm9ybWFsaXNlQ2FuZGlkYXRlU2luZ2xlIH0gZnJvbSAnLi9ub3JtYWxpc2UtY2FuZGlkYXRlLXNpbmdsZS5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuSW1wb3J0Q2FuZGlkYXRlfSBJbXBvcnRDYW5kaWRhdGVcbiAqL1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW55IG9mIHRoZSBgaXBmcy5hZGRgIGlucHV0IHR5cGVzIGludG9cbiAqXG4gKiBgYGBcbiAqIEFzeW5jSXRlcmFibGU8eyBwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudDogQXN5bmNJdGVyYWJsZTxVaW50OEFycmF5PiB9PlxuICogYGBgXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2pzLWlwZnMvYmxvYi9tYXN0ZXIvZG9jcy9jb3JlLWFwaS9GSUxFUy5tZCNpcGZzYWRkZGF0YS1vcHRpb25zXG4gKlxuICogQHBhcmFtIHtJbXBvcnRDYW5kaWRhdGV9IGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpc2VJbnB1dCAoaW5wdXQpIHtcbiAgcmV0dXJuIG5vcm1hbGlzZUNhbmRpZGF0ZVNpbmdsZShpbnB1dCwgbm9ybWFsaXNlQ29udGVudClcbn1cbiIsIi8qKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHJldHVybnMge29iaiBpcyBBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzIChvYmopIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8IG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHJldHVybnMge29iaiBpcyBnbG9iYWxUaGlzLkJsb2J9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jsb2IgKG9iaikge1xuICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yICYmXG4gICAgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmxvYicgfHwgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGaWxlJykgJiZcbiAgICB0eXBlb2Ygb2JqLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB3aXRoIGEgcGF0aCBvciBjb250ZW50IHByb3BlcnR5XG4gKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHJldHVybnMge29iaiBpcyBpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5JbXBvcnRDYW5kaWRhdGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVPYmplY3QgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKG9iai5wYXRoIHx8IG9iai5jb250ZW50KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFJlYWRhYmxlU3RyZWFtfVxuICovXG5leHBvcnQgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9ICh2YWx1ZSkgPT5cbiAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJ1xuIiwiXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkfSBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2RlVG9TdHJpbmcgKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbW9kZVxuICB9XG5cbiAgcmV0dXJuIG1vZGUudG9TdHJpbmcoOCkucGFkU3RhcnQoNCwgJzAnKVxufVxuIiwiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtdWx0aWZvcm1hdHMvYmFzZXMvaW50ZXJmYWNlJykuTXVsdGliYXNlQ29kZWM8YW55Pn0gTXVsdGliYXNlQ29kZWNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5Mb2FkQmFzZUZufSBMb2FkQmFzZUZuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuQWJvcnRPcHRpb25zfSBBYm9ydE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtMb2FkQmFzZUZufVxuICovXG5jb25zdCBMT0FEX0JBU0UgPSAobmFtZSkgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBObyBiYXNlIGZvdW5kIGZvciBcIiR7bmFtZX1cImApKVxuXG5leHBvcnQgY2xhc3MgTXVsdGliYXNlcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0xvYWRCYXNlRm59IFtvcHRpb25zLmxvYWRCYXNlXVxuICAgKiBAcGFyYW0ge011bHRpYmFzZUNvZGVjW119IG9wdGlvbnMuYmFzZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgLy8gT2JqZWN0IHdpdGggY3VycmVudCBsaXN0IG9mIGFjdGl2ZSByZXNvbHZlcnNcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIE11bHRpYmFzZUNvZGVjPn19ICovXG4gICAgdGhpcy5fYmFzZXNCeU5hbWUgPSB7fVxuXG4gICAgLy8gT2JqZWN0IHdpdGggY3VycmVudCBsaXN0IG9mIGFjdGl2ZSByZXNvbHZlcnNcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIE11bHRpYmFzZUNvZGVjPn19ICovXG4gICAgdGhpcy5fYmFzZXNCeVByZWZpeCA9IHt9XG5cbiAgICB0aGlzLl9sb2FkQmFzZSA9IG9wdGlvbnMubG9hZEJhc2UgfHwgTE9BRF9CQVNFXG5cbiAgICAvLyBFbmFibGUgYWxsIHN1cHBsaWVkIGNvZGVjc1xuICAgIGZvciAoY29uc3QgYmFzZSBvZiBvcHRpb25zLmJhc2VzKSB7XG4gICAgICB0aGlzLmFkZEJhc2UoYmFzZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHN1cHBvcnQgZm9yIGEgbXVsdGliYXNlIGNvZGVjXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGliYXNlQ29kZWN9IGJhc2VcbiAgICovXG4gIGFkZEJhc2UgKGJhc2UpIHtcbiAgICBpZiAodGhpcy5fYmFzZXNCeU5hbWVbYmFzZS5uYW1lXSB8fCB0aGlzLl9iYXNlc0J5UHJlZml4W2Jhc2UucHJlZml4XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlYyBhbHJlYWR5IGV4aXN0cyBmb3IgY29kZWMgXCIke2Jhc2UubmFtZX1cImApXG4gICAgfVxuXG4gICAgdGhpcy5fYmFzZXNCeU5hbWVbYmFzZS5uYW1lXSA9IGJhc2VcbiAgICB0aGlzLl9iYXNlc0J5UHJlZml4W2Jhc2UucHJlZml4XSA9IGJhc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc3VwcG9ydCBmb3IgYSBtdWx0aWJhc2UgY29kZWNcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWJhc2VDb2RlY30gYmFzZVxuICAgKi9cbiAgcmVtb3ZlQmFzZSAoYmFzZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9iYXNlc0J5TmFtZVtiYXNlLm5hbWVdXG4gICAgZGVsZXRlIHRoaXMuX2Jhc2VzQnlQcmVmaXhbYmFzZS5wcmVmaXhdXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVPclByZWZpeFxuICAgKi9cbiAgYXN5bmMgZ2V0QmFzZSAobmFtZU9yUHJlZml4KSB7XG4gICAgaWYgKHRoaXMuX2Jhc2VzQnlOYW1lW25hbWVPclByZWZpeF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9iYXNlc0J5TmFtZVtuYW1lT3JQcmVmaXhdXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Jhc2VzQnlQcmVmaXhbbmFtZU9yUHJlZml4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VzQnlQcmVmaXhbbmFtZU9yUHJlZml4XVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBzdXBwb3J0ZWQsIGF0dGVtcHQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGlzIGNvZGVjXG4gICAgY29uc3QgYmFzZSA9IGF3YWl0IHRoaXMuX2xvYWRCYXNlKG5hbWVPclByZWZpeClcblxuICAgIGlmICh0aGlzLl9iYXNlc0J5TmFtZVtiYXNlLm5hbWVdID09IG51bGwgJiYgdGhpcy5fYmFzZXNCeVByZWZpeFtiYXNlLnByZWZpeF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRCYXNlKGJhc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VcbiAgfVxuXG4gIGxpc3RCYXNlcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fYmFzZXNCeU5hbWUpXG4gIH1cbn1cbiIsIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbXVsdGlmb3JtYXRzL2NvZGVjcy9pbnRlcmZhY2UnKS5CbG9ja0NvZGVjPGFueSwgYW55Pn0gQmxvY2tDb2RlY1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkxvYWRDb2RlY0ZufSBMb2FkQ29kZWNGblxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLkFib3J0T3B0aW9uc30gQWJvcnRPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7TG9hZENvZGVjRm59XG4gKi9cbmNvbnN0IExPQURfQ09ERUMgPSAoY29kZU9yTmFtZSkgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBObyBjb2RlYyBmb3VuZCBmb3IgXCIke2NvZGVPck5hbWV9XCJgKSlcblxuZXhwb3J0IGNsYXNzIE11bHRpY29kZWNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TG9hZENvZGVjRm59IFtvcHRpb25zLmxvYWRDb2RlY11cbiAgICogQHBhcmFtIHtCbG9ja0NvZGVjW119IG9wdGlvbnMuY29kZWNzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIC8vIE9iamVjdCB3aXRoIGN1cnJlbnQgbGlzdCBvZiBhY3RpdmUgcmVzb2x2ZXJzXG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBCbG9ja0NvZGVjPn19ICovXG4gICAgdGhpcy5fY29kZWNzQnlOYW1lID0ge31cblxuICAgIC8vIE9iamVjdCB3aXRoIGN1cnJlbnQgbGlzdCBvZiBhY3RpdmUgcmVzb2x2ZXJzXG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8bnVtYmVyLCBCbG9ja0NvZGVjPn19ICovXG4gICAgdGhpcy5fY29kZWNzQnlDb2RlID0ge31cblxuICAgIHRoaXMuX2xvYWRDb2RlYyA9IG9wdGlvbnMubG9hZENvZGVjIHx8IExPQURfQ09ERUNcblxuICAgIC8vIEVuYWJsZSBhbGwgc3VwcGxpZWQgY29kZWNzXG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBvcHRpb25zLmNvZGVjcykge1xuICAgICAgdGhpcy5hZGRDb2RlYyhjb2RlYylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHN1cHBvcnQgZm9yIGEgYmxvY2sgY29kZWNcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja0NvZGVjfSBjb2RlY1xuICAgKi9cbiAgYWRkQ29kZWMgKGNvZGVjKSB7XG4gICAgaWYgKHRoaXMuX2NvZGVjc0J5TmFtZVtjb2RlYy5uYW1lXSB8fCB0aGlzLl9jb2RlY3NCeUNvZGVbY29kZWMuY29kZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb2x2ZXIgYWxyZWFkeSBleGlzdHMgZm9yIGNvZGVjIFwiJHtjb2RlYy5uYW1lfVwiYClcbiAgICB9XG5cbiAgICB0aGlzLl9jb2RlY3NCeU5hbWVbY29kZWMubmFtZV0gPSBjb2RlY1xuICAgIHRoaXMuX2NvZGVjc0J5Q29kZVtjb2RlYy5jb2RlXSA9IGNvZGVjXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHN1cHBvcnQgZm9yIGEgYmxvY2sgY29kZWNcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja0NvZGVjfSBjb2RlY1xuICAgKi9cbiAgcmVtb3ZlQ29kZWMgKGNvZGVjKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NvZGVjc0J5TmFtZVtjb2RlYy5uYW1lXVxuICAgIGRlbGV0ZSB0aGlzLl9jb2RlY3NCeUNvZGVbY29kZWMuY29kZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gY29kZVxuICAgKi9cbiAgYXN5bmMgZ2V0Q29kZWMgKGNvZGUpIHtcbiAgICBjb25zdCB0YWJsZSA9IHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJyA/IHRoaXMuX2NvZGVjc0J5TmFtZSA6IHRoaXMuX2NvZGVjc0J5Q29kZVxuXG4gICAgaWYgKHRhYmxlW2NvZGVdKSB7XG4gICAgICByZXR1cm4gdGFibGVbY29kZV1cbiAgICB9XG5cbiAgICAvLyBJZiBub3Qgc3VwcG9ydGVkLCBhdHRlbXB0IHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhpcyBjb2RlY1xuICAgIGNvbnN0IGNvZGVjID0gYXdhaXQgdGhpcy5fbG9hZENvZGVjKGNvZGUpXG5cbiAgICBpZiAodGFibGVbY29kZV0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRDb2RlYyhjb2RlYylcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZWNcbiAgfVxuXG4gIGxpc3RDb2RlY3MgKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvZGVjc0J5TmFtZSlcbiAgfVxufVxuIiwiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtdWx0aWZvcm1hdHMvaGFzaGVzL2ludGVyZmFjZScpLk11bHRpaGFzaEhhc2hlcn0gTXVsdGloYXNoSGFzaGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuTG9hZEhhc2hlckZufSBMb2FkSGFzaGVyRm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5BYm9ydE9wdGlvbnN9IEFib3J0T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGUge0xvYWRIYXNoZXJGbn1cbiAqL1xuY29uc3QgTE9BRF9IQVNIRVIgPSAoY29kZU9yTmFtZSkgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBObyBoYXNoZXIgZm91bmQgZm9yIFwiJHtjb2RlT3JOYW1lfVwiYCkpXG5cbmV4cG9ydCBjbGFzcyBNdWx0aWhhc2hlcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0xvYWRIYXNoZXJGbn0gW29wdGlvbnMubG9hZEhhc2hlcl1cbiAgICogQHBhcmFtIHtNdWx0aWhhc2hIYXNoZXJbXX0gb3B0aW9ucy5oYXNoZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIC8vIE9iamVjdCB3aXRoIGN1cnJlbnQgbGlzdCBvZiBhY3RpdmUgaGFzaGVyc1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTXVsdGloYXNoSGFzaGVyPn19ICovXG4gICAgdGhpcy5faGFzaGVyc0J5TmFtZSA9IHt9XG5cbiAgICAvLyBPYmplY3Qgd2l0aCBjdXJyZW50IGxpc3Qgb2YgYWN0aXZlIGhhc2hlcnNcbiAgICAvKiogQHR5cGUge1JlY29yZDxudW1iZXIsIE11bHRpaGFzaEhhc2hlcj59fSAqL1xuICAgIHRoaXMuX2hhc2hlcnNCeUNvZGUgPSB7fVxuXG4gICAgdGhpcy5fbG9hZEhhc2hlciA9IG9wdGlvbnMubG9hZEhhc2hlciB8fCBMT0FEX0hBU0hFUlxuXG4gICAgLy8gRW5hYmxlIGFsbCBzdXBwbGllZCBoYXNoZXJzXG4gICAgZm9yIChjb25zdCBoYXNoZXIgb2Ygb3B0aW9ucy5oYXNoZXJzKSB7XG4gICAgICB0aGlzLmFkZEhhc2hlcihoYXNoZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBzdXBwb3J0IGZvciBhIG11bHRpYmFzZSBoYXNoZXJcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWhhc2hIYXNoZXJ9IGhhc2hlclxuICAgKi9cbiAgYWRkSGFzaGVyIChoYXNoZXIpIHtcbiAgICBpZiAodGhpcy5faGFzaGVyc0J5TmFtZVtoYXNoZXIubmFtZV0gfHwgdGhpcy5faGFzaGVyc0J5Q29kZVtoYXNoZXIuY29kZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb2x2ZXIgYWxyZWFkeSBleGlzdHMgZm9yIGNvZGVjIFwiJHtoYXNoZXIubmFtZX1cImApXG4gICAgfVxuXG4gICAgdGhpcy5faGFzaGVyc0J5TmFtZVtoYXNoZXIubmFtZV0gPSBoYXNoZXJcbiAgICB0aGlzLl9oYXNoZXJzQnlDb2RlW2hhc2hlci5jb2RlXSA9IGhhc2hlclxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzdXBwb3J0IGZvciBhIG11bHRpYmFzZSBoYXNoZXJcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWhhc2hIYXNoZXJ9IGhhc2hlclxuICAgKi9cbiAgcmVtb3ZlSGFzaGVyIChoYXNoZXIpIHtcbiAgICBkZWxldGUgdGhpcy5faGFzaGVyc0J5TmFtZVtoYXNoZXIubmFtZV1cbiAgICBkZWxldGUgdGhpcy5faGFzaGVyc0J5Q29kZVtoYXNoZXIuY29kZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gY29kZVxuICAgKi9cbiAgYXN5bmMgZ2V0SGFzaGVyIChjb2RlKSB7XG4gICAgY29uc3QgdGFibGUgPSB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9oYXNoZXJzQnlOYW1lIDogdGhpcy5faGFzaGVyc0J5Q29kZVxuXG4gICAgaWYgKHRhYmxlW2NvZGVdKSB7XG4gICAgICByZXR1cm4gdGFibGVbY29kZV1cbiAgICB9XG5cbiAgICAvLyBJZiBub3Qgc3VwcG9ydGVkLCBhdHRlbXB0IHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhpcyBoYXNoZXJcbiAgICBjb25zdCBoYXNoZXIgPSBhd2FpdCB0aGlzLl9sb2FkSGFzaGVyKGNvZGUpXG5cbiAgICBpZiAodGFibGVbY29kZV0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRIYXNoZXIoaGFzaGVyKVxuICAgIH1cblxuICAgIHJldHVybiBoYXNoZXJcbiAgfVxuXG4gIGxpc3RIYXNoZXJzICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9oYXNoZXJzQnlOYW1lKVxuICB9XG59XG4iLCJcbi8vIEltcG9ydCBicm93c2VyIHZlcnNpb24gb3RoZXJ3aXNlIGVsZWN0cm9uLXJlbmRlcmVyIHdpbGwgZW5kIHVwIHdpdGggbm9kZVxuLy8gdmVyc2lvbiBhbmQgZmFpbC5cbmltcG9ydCB7IG5vcm1hbGlzZUlucHV0IH0gZnJvbSAnLi9maWxlcy9ub3JtYWxpc2UtaW5wdXQtbXVsdGlwbGUuYnJvd3Nlci5qcydcbmltcG9ydCB7IG1vZGVUb1N0cmluZyB9IGZyb20gJy4vbW9kZS10by1zdHJpbmcuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLkltcG9ydENhbmRpZGF0ZVN0cmVhbX0gSW1wb3J0Q2FuZGlkYXRlU3RyZWFtXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ltcG9ydENhbmRpZGF0ZVN0cmVhbX0gc291cmNlXG4gKiBAcGFyYW0ge0Fib3J0Q29udHJvbGxlcn0gYWJvcnRDb250cm9sbGVyXG4gKiBAcGFyYW0ge0hlYWRlcnN8UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnNdXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtdWx0aXBhcnRSZXF1ZXN0IChzb3VyY2UsIGFib3J0Q29udHJvbGxlciwgaGVhZGVycyA9IHt9KSB7XG4gIGNvbnN0IHBhcnRzID0gW11cbiAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICBsZXQgaW5kZXggPSAwXG4gIGxldCB0b3RhbCA9IDBcblxuICBmb3IgYXdhaXQgKGNvbnN0IHsgY29udGVudCwgcGF0aCwgbW9kZSwgbXRpbWUgfSBvZiBub3JtYWxpc2VJbnB1dChzb3VyY2UpKSB7XG4gICAgbGV0IGZpbGVTdWZmaXggPSAnJ1xuICAgIGNvbnN0IHR5cGUgPSBjb250ZW50ID8gJ2ZpbGUnIDogJ2RpcidcblxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIGZpbGVTdWZmaXggPSBgLSR7aW5kZXh9YFxuICAgIH1cblxuICAgIGxldCBmaWVsZE5hbWUgPSB0eXBlICsgZmlsZVN1ZmZpeFxuICAgIGNvbnN0IHFzID0gW11cblxuICAgIGlmIChtb2RlICE9PSBudWxsICYmIG1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcXMucHVzaChgbW9kZT0ke21vZGVUb1N0cmluZyhtb2RlKX1gKVxuICAgIH1cblxuICAgIGlmICgobXRpbWUpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgc2VjcywgbnNlY3MgfSA9IChtdGltZSlcblxuICAgICAgcXMucHVzaChgbXRpbWU9JHtzZWNzfWApXG5cbiAgICAgIGlmIChuc2VjcyAhPSBudWxsKSB7XG4gICAgICAgIHFzLnB1c2goYG10aW1lLW5zZWNzPSR7bnNlY3N9YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXMubGVuZ3RoKSB7XG4gICAgICBmaWVsZE5hbWUgPSBgJHtmaWVsZE5hbWV9PyR7cXMuam9pbignJicpfWBcbiAgICB9XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgZm9ybURhdGEuc2V0KGZpZWxkTmFtZSwgY29udGVudCwgcGF0aCAhPSBudWxsID8gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpIDogdW5kZWZpbmVkKVxuICAgICAgY29uc3QgZW5kID0gdG90YWwgKyBjb250ZW50LnNpemVcbiAgICAgIHBhcnRzLnB1c2goeyBuYW1lOiBwYXRoLCBzdGFydDogdG90YWwsIGVuZCB9KVxuICAgICAgdG90YWwgPSBlbmRcbiAgICB9IGVsc2UgaWYgKHBhdGggIT0gbnVsbCkge1xuICAgICAgZm9ybURhdGEuc2V0KGZpZWxkTmFtZSwgbmV3IEZpbGUoWycnXSwgZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yeScgfSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBvciBjb250ZW50IG9yIGJvdGggbXVzdCBiZSBzZXQnKVxuICAgIH1cblxuICAgIGluZGV4KytcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG90YWwsXG4gICAgcGFydHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5OiBmb3JtRGF0YVxuICB9XG59XG4iLCJpbXBvcnQgeyBpc0VsZWN0cm9uUmVuZGVyZXIgfSBmcm9tICdpcGZzLXV0aWxzL3NyYy9lbnYuanMnXG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IGFzIG11bHRpcGFydFJlcXVlc3ROb2RlIH0gZnJvbSAnLi9tdWx0aXBhcnQtcmVxdWVzdC5ub2RlLmpzJ1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCBhcyBtdWx0aXBhcnRSZXF1ZXN0QnJvd3NlciB9IGZyb20gJy4vbXVsdGlwYXJ0LXJlcXVlc3QuYnJvd3Nlci5qcydcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJ25hbm9pZCdcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuSW1wb3J0Q2FuZGlkYXRlU3RyZWFtfSBJbXBvcnRDYW5kaWRhdGVTdHJlYW1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SW1wb3J0Q2FuZGlkYXRlU3RyZWFtfSBzb3VyY2VcbiAqIEBwYXJhbSB7QWJvcnRDb250cm9sbGVyfSBhYm9ydENvbnRyb2xsZXJcbiAqIEBwYXJhbSB7SGVhZGVyc3xSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYm91bmRhcnldXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtdWx0aXBhcnRSZXF1ZXN0IChzb3VyY2UsIGFib3J0Q29udHJvbGxlciwgaGVhZGVycyA9IHt9LCBib3VuZGFyeSA9IGAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSR7bmFub2lkKCl9YCkge1xuICBsZXQgcmVxID0gbXVsdGlwYXJ0UmVxdWVzdE5vZGVcblxuICAvLyBJbiBlbGVjdHJvbi1yZW5kZXJlciB3ZSB1c2UgbmF0aXZlIGZldGNoIGFuZCBzaG91bGQgZW5jb2RlIGJvZHkgdXNpbmcgbmF0aXZlXG4gIC8vIGZvcm0gZGF0YS5cbiAgaWYgKGlzRWxlY3Ryb25SZW5kZXJlcikge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZXMgYXJlIGRpZmZlcmVudFxuICAgIHJlcSA9IG11bHRpcGFydFJlcXVlc3RCcm93c2VyXG4gIH1cblxuICByZXR1cm4gcmVxKHNvdXJjZSwgYWJvcnRDb250cm9sbGVyLCBoZWFkZXJzLCBib3VuZGFyeSlcbn1cbiIsImltcG9ydCB7IG5vcm1hbGlzZUlucHV0IH0gZnJvbSAnLi9maWxlcy9ub3JtYWxpc2UtaW5wdXQtbXVsdGlwbGUuanMnXG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICduYW5vaWQnXG5pbXBvcnQgeyBtb2RlVG9TdHJpbmcgfSBmcm9tICcuL21vZGUtdG8tc3RyaW5nLmpzJ1xuaW1wb3J0IG1lcmdlT3B0cyBmcm9tICdtZXJnZS1vcHRpb25zJ1xuLy8gQHRzLWV4cGVjdC1lcnJvciBubyB0eXBlc1xuaW1wb3J0IHRvU3RyZWFtIGZyb20gJ2l0LXRvLXN0cmVhbSdcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0BsaWJwMnAvbG9nZ2VyJ1xuaW1wb3J0IGl0UGVla2FibGUgZnJvbSAnaXQtcGVla2FibGUnXG5cbmNvbnN0IG1lcmdlID0gbWVyZ2VPcHRzLmJpbmQoeyBpZ25vcmVVbmRlZmluZWQ6IHRydWUgfSlcbmNvbnN0IGxvZyA9IGxvZ2dlcignaXBmczpjb3JlLXV0aWxzOm11bHRpcGFydC1yZXF1ZXN0JylcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzJykuSW1wb3J0Q2FuZGlkYXRlU3RyZWFtfSBJbXBvcnRDYW5kaWRhdGVTdHJlYW1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SW1wb3J0Q2FuZGlkYXRlU3RyZWFtfSBzb3VyY2VcbiAqIEBwYXJhbSB7QWJvcnRDb250cm9sbGVyfSBhYm9ydENvbnRyb2xsZXJcbiAqIEBwYXJhbSB7SGVhZGVyc3xSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYm91bmRhcnldXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtdWx0aXBhcnRSZXF1ZXN0IChzb3VyY2UsIGFib3J0Q29udHJvbGxlciwgaGVhZGVycyA9IHt9LCBib3VuZGFyeSA9IGAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSR7bmFub2lkKCl9YCkge1xuICAvKipcbiAgICogQHBhcmFtIHtJbXBvcnRDYW5kaWRhdGVTdHJlYW19IHNvdXJjZVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBzdHJlYW1GaWxlcyAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpbmRleCA9IDBcblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IGNvbnRlbnQsIHBhdGgsIG1vZGUsIG10aW1lIH0gb2Ygc291cmNlKSB7XG4gICAgICAgIGxldCBmaWxlU3VmZml4ID0gJydcbiAgICAgICAgY29uc3QgdHlwZSA9IGNvbnRlbnQgPyAnZmlsZScgOiAnZGlyJ1xuXG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICB5aWVsZCAnXFxyXFxuJ1xuXG4gICAgICAgICAgZmlsZVN1ZmZpeCA9IGAtJHtpbmRleH1gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmllbGROYW1lID0gdHlwZSArIGZpbGVTdWZmaXhcbiAgICAgICAgY29uc3QgcXMgPSBbXVxuXG4gICAgICAgIGlmIChtb2RlICE9PSBudWxsICYmIG1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHFzLnB1c2goYG1vZGU9JHttb2RlVG9TdHJpbmcobW9kZSl9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtdGltZSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgeyBzZWNzLCBuc2VjcyB9ID0gbXRpbWVcblxuICAgICAgICAgIHFzLnB1c2goYG10aW1lPSR7c2Vjc31gKVxuXG4gICAgICAgICAgaWYgKG5zZWNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHFzLnB1c2goYG10aW1lLW5zZWNzPSR7bnNlY3N9YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmllbGROYW1lID0gYCR7ZmllbGROYW1lfT8ke3FzLmpvaW4oJyYnKX1gXG4gICAgICAgIH1cblxuICAgICAgICB5aWVsZCBgLS0ke2JvdW5kYXJ5fVxcclxcbmBcbiAgICAgICAgeWllbGQgYENvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiR7ZmllbGROYW1lfVwiOyBmaWxlbmFtZT1cIiR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhdGggfHwgJycpfVwiXFxyXFxuYFxuICAgICAgICB5aWVsZCBgQ29udGVudC1UeXBlOiAke2NvbnRlbnQgPyAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyA6ICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yeSd9XFxyXFxuYFxuICAgICAgICB5aWVsZCAnXFxyXFxuJ1xuXG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgeWllbGQgKiBjb250ZW50XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrXG4gICAgICB9XG4gICAgfSBjYXRjaCAoLyoqIEB0eXBlIHthbnl9ICovIGVycikge1xuICAgICAgbG9nKGVycilcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzc1M1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgeWllbGQgYFxcclxcbi0tJHtib3VuZGFyeX0tLVxcclxcbmBcbiAgICB9XG4gIH1cblxuICAvLyBwZWVrIGF0IHRoZSBmaXJzdCB2YWx1ZSBpbiBvcmRlciB0byBnZXQgdGhlIGlucHV0IHN0cmVhbSBtb3ZpbmdcbiAgLy8gYW5kIHRvIHZhbGlkYXRlIGl0cyBjb250ZW50cy5cbiAgLy8gV2UgY2Fubm90IGRvIHRoaXMgaW4gdGhlIGBmb3IgYXdhaXQuLm9mYCBpbiBzdHJlYW1GaWxlcyBkdWUgdG9cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvNzUzXG4gIGNvbnN0IHBlZWthYmxlID0gaXRQZWVrYWJsZShub3JtYWxpc2VJbnB1dChzb3VyY2UpKVxuXG4gIC8qKiBAdHlwZSB7YW55fSB2YWx1ZSAqKi9cbiAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcGVla2FibGUucGVlaygpXG5cbiAgaWYgKCFkb25lKSB7XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFydHM6IG51bGwsXG4gICAgdG90YWw6IC0xLFxuICAgIGhlYWRlcnM6IG1lcmdlKGhlYWRlcnMsIHtcbiAgICAgICdDb250ZW50LVR5cGUnOiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtib3VuZGFyeX1gXG4gICAgfSksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3JtYWxpc2VJbnB1dCByZXR1cm5zIHVuaXhmcyBpbXBvcnRlciBpbXBvcnQgY2FuZGlkYXRlc1xuICAgIGJvZHk6IHRvU3RyZWFtKHN0cmVhbUZpbGVzKHBlZWthYmxlKSlcbiAgfVxufVxuIiwiaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnXG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFBpbm5hYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IEluc3RhbmNlVHlwZTx0eXBlb2Ygd2luZG93LlN0cmluZz4gfCBDSUR9IFtwYXRoXVxuICogQHByb3BlcnR5IHtDSUR9IFtjaWRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWN1cnNpdmVdXG4gKiBAcHJvcGVydHkge2FueX0gW21ldGFkYXRhXVxuICpcbiAqIEB0eXBlZGVmIHtDSUR8c3RyaW5nfEluc3RhbmNlVHlwZTx0eXBlb2Ygd2luZG93LlN0cmluZz58UGlubmFibGV9IFRvUGluXG4gKiBAdHlwZWRlZiB7VG9QaW58SXRlcmFibGU8VG9QaW4+fEFzeW5jSXRlcmFibGU8VG9QaW4+fSBTb3VyY2VcbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQaW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfENJRH0gcGF0aFxuICogQHByb3BlcnR5IHtib29sZWFufSByZWN1cnNpdmVcbiAqIEBwcm9wZXJ0eSB7YW55fSBbbWV0YWRhdGFdXG4gKi9cblxuLyoqXG4gKiBUcmFuc2Zvcm0gb25lIG9mOlxuICpcbiAqIGBgYHRzXG4gKiBDSURcbiAqIFN0cmluZ1xuICogeyBjaWQ6IENJRCByZWN1cnNpdmUsIG1ldGFkYXRhIH1cbiAqIHsgcGF0aDogU3RyaW5nIHJlY3Vyc2l2ZSwgbWV0YWRhdGEgfVxuICogSXRlcmFibGU8Q0lEPlxuICogSXRlcmFibGU8U3RyaW5nPlxuICogSXRlcmFibGU8eyBjaWQ6IENJRCByZWN1cnNpdmUsIG1ldGFkYXRhIH0+XG4gKiBJdGVyYWJsZTx7IHBhdGg6IFN0cmluZyByZWN1cnNpdmUsIG1ldGFkYXRhIH0+XG4gKiBBc3luY0l0ZXJhYmxlPENJRD5cbiAqIEFzeW5jSXRlcmFibGU8U3RyaW5nPlxuICogQXN5bmNJdGVyYWJsZTx7IGNpZDogQ0lEIHJlY3Vyc2l2ZSwgbWV0YWRhdGEgfT5cbiAqIEFzeW5jSXRlcmFibGU8eyBwYXRoOiBTdHJpbmcgcmVjdXJzaXZlLCBtZXRhZGF0YSB9PlxuICogYGBgXG4gKiBJbnRvOlxuICpcbiAqIGBgYHRzXG4gKiBBc3luY0l0ZXJhYmxlPHsgcGF0aDogQ0lEfFN0cmluZywgcmVjdXJzaXZlOmJvb2xlYW4sIG1ldGFkYXRhIH0+XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1NvdXJjZX0gaW5wdXRcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFBpbj59XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gKiBub3JtYWxpc2VJbnB1dCAoaW5wdXQpIHtcbiAgLy8gbXVzdCBnaXZlIHVzIHNvbWV0aGluZ1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiAke2lucHV0fWApLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKVxuICB9XG5cbiAgLy8gQ0lEXG4gIGNvbnN0IGNpZCA9IENJRC5hc0NJRChpbnB1dClcblxuICBpZiAoY2lkKSB7XG4gICAgeWllbGQgdG9QaW4oeyBjaWQgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgeWllbGQgdG9QaW4oeyBwYXRoOiBpbnB1dCB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8geyBjaWQ6IENJRCByZWN1cnNpdmUsIG1ldGFkYXRhIH1cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGl0IHN0aWxsIGNvdWxkIGJlIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlXG4gIGlmIChpbnB1dC5jaWQgIT0gbnVsbCB8fCBpbnB1dC5wYXRoICE9IG51bGwpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcmV0dXJuIHlpZWxkIHRvUGluKGlucHV0KVxuICB9XG5cbiAgLy8gSXRlcmFibGU8Pz5cbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBpbnB1dCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBpdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKVxuICAgIGNvbnN0IGZpcnN0ID0gaXRlcmF0b3IubmV4dCgpXG4gICAgaWYgKGZpcnN0LmRvbmUpIHJldHVybiBpdGVyYXRvclxuXG4gICAgLy8gSXRlcmFibGU8Q0lEfFN0cmluZz5cbiAgICBpZiAoQ0lELmFzQ0lEKGZpcnN0LnZhbHVlKSB8fCBmaXJzdC52YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgZmlyc3QudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB5aWVsZCB0b1Bpbih7IGNpZDogZmlyc3QudmFsdWUgfSlcbiAgICAgIGZvciAoY29uc3QgY2lkIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkIHRvUGluKHsgY2lkIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJdGVyYWJsZTx7IGNpZDogQ0lEIHJlY3Vyc2l2ZSwgbWV0YWRhdGEgfT5cbiAgICBpZiAoZmlyc3QudmFsdWUuY2lkICE9IG51bGwgfHwgZmlyc3QudmFsdWUucGF0aCAhPSBudWxsKSB7XG4gICAgICB5aWVsZCB0b1BpbihmaXJzdC52YWx1ZSlcbiAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkIHRvUGluKG9iailcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiAnICsgdHlwZW9mIGlucHV0KSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJylcbiAgfVxuXG4gIC8vIEFzeW5jSXRlcmFibGU8Pz5cbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGlucHV0KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGl0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICBjb25zdCBmaXJzdCA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKVxuICAgIGlmIChmaXJzdC5kb25lKSByZXR1cm4gaXRlcmF0b3JcblxuICAgIC8vIEFzeW5jSXRlcmFibGU8Q0lEfFN0cmluZz5cbiAgICBpZiAoQ0lELmFzQ0lEKGZpcnN0LnZhbHVlKSB8fCBmaXJzdC52YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgZmlyc3QudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB5aWVsZCB0b1Bpbih7IGNpZDogZmlyc3QudmFsdWUgfSlcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2lkIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkIHRvUGluKHsgY2lkIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBBc3luY0l0ZXJhYmxlPHsgY2lkOiBDSUR8U3RyaW5nIHJlY3Vyc2l2ZSwgbWV0YWRhdGEgfT5cbiAgICBpZiAoZmlyc3QudmFsdWUuY2lkICE9IG51bGwgfHwgZmlyc3QudmFsdWUucGF0aCAhPSBudWxsKSB7XG4gICAgICB5aWVsZCB0b1BpbihmaXJzdC52YWx1ZSlcbiAgICAgIGZvciBhd2FpdCAoY29uc3Qgb2JqIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkIHRvUGluKG9iailcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiAnICsgdHlwZW9mIGlucHV0KSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJylcbiAgfVxuXG4gIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiAnICsgdHlwZW9mIGlucHV0KSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Bpbm5hYmxlfSBpbnB1dFxuICovXG5mdW5jdGlvbiB0b1BpbiAoaW5wdXQpIHtcbiAgY29uc3QgcGF0aCA9IGlucHV0LmNpZCB8fCBgJHtpbnB1dC5wYXRofWBcblxuICBpZiAoIXBhdGgpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogUGxlYXNlIHBhdGggZWl0aGVyIGEgQ0lEIG9yIGFuIElQRlMgcGF0aCcpLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQaW59ICovXG4gIGNvbnN0IHBpbiA9IHtcbiAgICBwYXRoLFxuICAgIHJlY3Vyc2l2ZTogaW5wdXQucmVjdXJzaXZlICE9PSBmYWxzZVxuICB9XG5cbiAgaWYgKGlucHV0Lm1ldGFkYXRhICE9IG51bGwpIHtcbiAgICBwaW4ubWV0YWRhdGEgPSBpbnB1dC5tZXRhZGF0YVxuICB9XG5cbiAgcmV0dXJuIHBpblxufVxuIiwiaW1wb3J0IHsgbXVsdGlhZGRyIH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHInXG5pbXBvcnQgeyBtdWx0aWFkZHJUb1VyaSB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyLXRvLXVyaSdcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAbXVsdGlmb3JtYXRzL211bHRpYWRkcicpLk11bHRpYWRkcn0gTXVsdGlhZGRyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xNdWx0aWFkZHJ8VVJMfSB1cmwgLSBBIHN0cmluZywgbXVsdGlhZGRyIG9yIFVSTCB0byBjb252ZXJ0IHRvIGEgdXJsIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXJsU3RyaW5nICh1cmwpIHtcbiAgdHJ5IHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdXJsID0gbXVsdGlhZGRyVG9VcmkobXVsdGlhZGRyKHVybCkpXG4gIH0gY2F0Y2ggKC8qKiBAdHlwZSB7YW55fSAqLyBlcnIpIHsgfVxuXG4gIHVybCA9IHVybC50b1N0cmluZygpXG5cbiAgcmV0dXJuIHVybFxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0J1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi9saWIvYWJvcnQtc2lnbmFsLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtdXRpbHMvc3JjL3R5cGVzJykuUHJvZ3Jlc3NGbn0gSVBGU1V0aWxzSHR0cFVwbG9hZFByb2dyZXNzRm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFkZFByb2dyZXNzRm59IElQRlNDb3JlQWRkUHJvZ3Jlc3NGblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUm9vdEFQSVxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yb290JykuQWRkUmVzdWx0fSBBZGRSZXN1bHRcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQWRkQWxsID0gY29uZmlndXJlKChhcGkpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSb290QVBJW1wiYWRkQWxsXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBhZGRBbGwgKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gYWxsb3cgYWJvcnRpbmcgcmVxdWVzdHMgb24gYm9keSBlcnJvcnNcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3Qgc2lnbmFsID0gYWJvcnRTaWduYWwoY29udHJvbGxlci5zaWduYWwsIG9wdGlvbnMuc2lnbmFsKVxuICAgIGNvbnN0IHsgaGVhZGVycywgYm9keSwgdG90YWwsIHBhcnRzIH0gPVxuICAgICAgYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdChzb3VyY2UsIGNvbnRyb2xsZXIsIG9wdGlvbnMuaGVhZGVycylcblxuICAgIC8vIEluIGJyb3dzZXIgcmVzcG9uc2UgYm9keSBvbmx5IHN0YXJ0cyBzdHJlYW1pbmcgb25jZSB1cGxvYWQgaXNcbiAgICAvLyBjb21wbGV0ZSwgYXQgd2hpY2ggcG9pbnQgYWxsIHRoZSBwcm9ncmVzcyB1cGRhdGVzIGFyZSBpbnZhbGlkLiBJZlxuICAgIC8vIGxlbmd0aCBvZiB0aGUgY29udGVudCBpcyBjb21wdXRhYmxlIHdlIGNhbiBpbnRlcnByZXQgcHJvZ3Jlc3MgZnJvbVxuICAgIC8vIGB7IHRvdGFsLCBsb2FkZWR9YCBwYXNzZWQgdG8gYG9uVXBsb2FkUHJvZ3Jlc3NgIGFuZCBgbXVsdGlwYXJ0LnRvdGFsYFxuICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgZGlzYWJsZSBwcm9ncmVzcyB1cGRhdGVzIHRvIGJlIHdyaXR0ZW4gb3V0LlxuICAgIGNvbnN0IFtwcm9ncmVzc0ZuLCBvblVwbG9hZFByb2dyZXNzXSA9IHR5cGVvZiBvcHRpb25zLnByb2dyZXNzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGNyZWF0ZVByb2dyZXNzSGFuZGxlcih0b3RhbCwgcGFydHMsIG9wdGlvbnMucHJvZ3Jlc3MpXG4gICAgICA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdhZGQnLCB7XG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgJ3N0cmVhbS1jaGFubmVscyc6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHByb2dyZXNzOiBCb29sZWFuKHByb2dyZXNzRm4pXG4gICAgICB9KSxcbiAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICBzaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH0pXG5cbiAgICBmb3IgYXdhaXQgKGxldCBmaWxlIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgZmlsZSA9IG9iamVjdFRvQ2FtZWwoZmlsZSlcblxuICAgICAgaWYgKGZpbGUuaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlpZWxkIHRvQ29yZUludGVyZmFjZShmaWxlKVxuICAgICAgfSBlbHNlIGlmIChwcm9ncmVzc0ZuKSB7XG4gICAgICAgIHByb2dyZXNzRm4oZmlsZS5ieXRlcyB8fCAwLCBmaWxlLm5hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGRBbGxcbn0pXG5cbi8qKlxuICogUmV0dXJucyBzaW1wbGUgcHJvZ3Jlc3MgY2FsbGJhY2sgd2hlbiBjb250ZW50IGxlbmd0aCBpc24ndCBjb21wdXRhYmxlIG9yIGFcbiAqIHByb2dyZXNzIGV2ZW50IGhhbmRsZXIgdGhhdCBjYWxjdWxhdGVzIHByb2dyZXNzIGZyb20gdXBsb2FkIHByb2dyZXNzIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAqIEBwYXJhbSB7e25hbWU6c3RyaW5nLCBzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9W118bnVsbH0gcGFydHNcbiAqIEBwYXJhbSB7SVBGU0NvcmVBZGRQcm9ncmVzc0ZufSBwcm9ncmVzc1xuICogQHJldHVybnMge1tJUEZTQ29yZUFkZFByb2dyZXNzRm58dW5kZWZpbmVkLCBJUEZTVXRpbHNIdHRwVXBsb2FkUHJvZ3Jlc3NGbnx1bmRlZmluZWRdfVxuICovXG5jb25zdCBjcmVhdGVQcm9ncmVzc0hhbmRsZXIgPSAodG90YWwsIHBhcnRzLCBwcm9ncmVzcykgPT5cbiAgcGFydHMgPyBbdW5kZWZpbmVkLCBjcmVhdGVPblVwbG9hZFByb2dyZXNzKHRvdGFsLCBwYXJ0cywgcHJvZ3Jlc3MpXSA6IFtwcm9ncmVzcywgdW5kZWZpbmVkXVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmVzcyBoYW5kbGVyIHRoYXQgaW50ZXJwb2xhdGVzIHByb2dyZXNzIGZyb20gdXBsb2FkIHByb2dyZXNzXG4gKiBldmVudHMgYW5kIHRvdGFsIHNpemUgb2YgdGhlIGNvbnRlbnQgdGhhdCBpcyBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIGFjdHVhbCBjb250ZW50IHNpemVcbiAqIEBwYXJhbSB7e25hbWU6c3RyaW5nLCBzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9W119IHBhcnRzXG4gKiBAcGFyYW0ge0lQRlNDb3JlQWRkUHJvZ3Jlc3NGbn0gcHJvZ3Jlc3NcbiAqIEByZXR1cm5zIHtJUEZTVXRpbHNIdHRwVXBsb2FkUHJvZ3Jlc3NGbn1cbiAqL1xuY29uc3QgY3JlYXRlT25VcGxvYWRQcm9ncmVzcyA9IChzaXplLCBwYXJ0cywgcHJvZ3Jlc3MpID0+IHtcbiAgbGV0IGluZGV4ID0gMFxuICBjb25zdCBjb3VudCA9IHBhcnRzLmxlbmd0aFxuICByZXR1cm4gKHsgbG9hZGVkLCB0b3RhbCB9KSA9PiB7XG4gICAgLy8gRGVyaXZlIHBvc2l0aW9uIGZyb20gdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAgY29uc3QgcG9zaXRpb24gPSBNYXRoLmZsb29yKGxvYWRlZCAvIHRvdGFsICogc2l6ZSlcbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCBuYW1lIH0gPSBwYXJ0c1tpbmRleF1cbiAgICAgIC8vIElmIHdpdGhpbiBjdXJyZW50IHBhcnQgcmFuZ2UgcmVwb3J0IHByb2dyZXNzIGFuZCBicmVhayB0aGUgbG9vcFxuICAgICAgaWYgKHBvc2l0aW9uIDwgZW5kKSB7XG4gICAgICAgIHByb2dyZXNzKHBvc2l0aW9uIC0gc3RhcnQsIG5hbWUpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiBwYXNzZWQgY3VycmVudCBwYXJ0IHJhbmdlIHJlcG9ydCBmaW5hbCBieXRlIGZvciB0aGUgY2h1bmsgYW5kXG4gICAgICAvLyBtb3ZlIHRvIG5leHQgb25lLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MoZW5kIC0gc3RhcnQsIG5hbWUpXG4gICAgICAgIGluZGV4ICs9IDFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dC5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQuaGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0LnNpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXQubW9kZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXQubXRpbWVdXG4gKiBAcGFyYW0ge251bWJlcn0gW2lucHV0Lm10aW1lTnNlY3NdXG4gKi9cbmZ1bmN0aW9uIHRvQ29yZUludGVyZmFjZSAoeyBuYW1lLCBoYXNoLCBzaXplLCBtb2RlLCBtdGltZSwgbXRpbWVOc2VjcyB9KSB7XG4gIC8qKiBAdHlwZSB7QWRkUmVzdWx0fSAqL1xuICBjb25zdCBvdXRwdXQgPSB7XG4gICAgcGF0aDogbmFtZSxcbiAgICBjaWQ6IENJRC5wYXJzZShoYXNoKSxcbiAgICBzaXplOiBwYXJzZUludChzaXplKVxuICB9XG5cbiAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgIG91dHB1dC5tb2RlID0gcGFyc2VJbnQobW9kZSwgOClcbiAgfVxuXG4gIGlmIChtdGltZSAhPSBudWxsKSB7XG4gICAgb3V0cHV0Lm10aW1lID0ge1xuICAgICAgc2VjczogbXRpbWUsXG4gICAgICBuc2VjczogbXRpbWVOc2VjcyB8fCAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQWRkQWxsIH0gZnJvbSAnLi9hZGQtYWxsLmpzJ1xuaW1wb3J0IGxhc3QgZnJvbSAnaXQtbGFzdCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IG5vcm1hbGlzZUlucHV0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL2ZpbGVzL25vcm1hbGlzZS1pbnB1dC1zaW5nbGUnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUm9vdEFQSVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMnKS5PcHRpb25zfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZGQgKG9wdGlvbnMpIHtcbiAgY29uc3QgYWxsID0gY3JlYXRlQWRkQWxsKG9wdGlvbnMpXG4gIHJldHVybiBjb25maWd1cmUoKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSb290QVBJW1wiYWRkXCJdfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGFkZCAoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGxhc3QgbWF5IHJldHVybiB1bmRlZmluZWQgaWYgc291cmNlIGlzIGVtcHR5XG4gICAgICByZXR1cm4gYXdhaXQgbGFzdChhbGwobm9ybWFsaXNlSW5wdXQoaW5wdXQpLCBvcHRpb25zKSlcbiAgICB9XG4gICAgcmV0dXJuIGFkZFxuICB9KShvcHRpb25zKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlV2FudGxpc3QgfSBmcm9tICcuL3dhbnRsaXN0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlV2FudGxpc3RGb3JQZWVyIH0gZnJvbSAnLi93YW50bGlzdC1mb3ItcGVlci5qcydcbmltcG9ydCB7IGNyZWF0ZVN0YXQgfSBmcm9tICcuL3N0YXQuanMnXG5pbXBvcnQgeyBjcmVhdGVVbndhbnQgfSBmcm9tICcuL3Vud2FudC5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpdHN3YXAgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHdhbnRsaXN0OiBjcmVhdGVXYW50bGlzdChjb25maWcpLFxuICAgIHdhbnRsaXN0Rm9yUGVlcjogY3JlYXRlV2FudGxpc3RGb3JQZWVyKGNvbmZpZyksXG4gICAgdW53YW50OiBjcmVhdGVVbndhbnQoY29uZmlnKSxcbiAgICBzdGF0OiBjcmVhdGVTdGF0KGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IHBlZXJJZEZyb21TdHJpbmcgfSBmcm9tICdAbGlicDJwL3BlZXItaWQnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2JpdHN3YXAnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEJpdHN3YXBBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0JpdHN3YXBBUElbXCJzdGF0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhdCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2JpdHN3YXAvc3RhdCcsIHtcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIHJldHVybiB0b0NvcmVJbnRlcmZhY2UoYXdhaXQgcmVzLmpzb24oKSlcbiAgfVxuICByZXR1cm4gc3RhdFxufSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcmVzXG4gKi9cbmZ1bmN0aW9uIHRvQ29yZUludGVyZmFjZSAocmVzKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZUJ1ZkxlbjogcmVzLlByb3ZpZGVCdWZMZW4sXG4gICAgd2FudGxpc3Q6IChyZXMuV2FudGxpc3QgfHwgW10pLm1hcCgoLyoqIEB0eXBlIHt7ICcvJzogc3RyaW5nIH19ICovIGspID0+IENJRC5wYXJzZShrWycvJ10pKSxcbiAgICBwZWVyczogKHJlcy5QZWVycyB8fCBbXSkubWFwKCgvKiogQHR5cGUge3N0cmluZ30gKi8gc3RyKSA9PiBwZWVySWRGcm9tU3RyaW5nKHN0cikpLFxuICAgIGJsb2Nrc1JlY2VpdmVkOiBCaWdJbnQocmVzLkJsb2Nrc1JlY2VpdmVkKSxcbiAgICBkYXRhUmVjZWl2ZWQ6IEJpZ0ludChyZXMuRGF0YVJlY2VpdmVkKSxcbiAgICBibG9ja3NTZW50OiBCaWdJbnQocmVzLkJsb2Nrc1NlbnQpLFxuICAgIGRhdGFTZW50OiBCaWdJbnQocmVzLkRhdGFTZW50KSxcbiAgICBkdXBCbGtzUmVjZWl2ZWQ6IEJpZ0ludChyZXMuRHVwQmxrc1JlY2VpdmVkKSxcbiAgICBkdXBEYXRhUmVjZWl2ZWQ6IEJpZ0ludChyZXMuRHVwRGF0YVJlY2VpdmVkKVxuICB9XG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2JpdHN3YXAnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEJpdHN3YXBBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVW53YW50ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Qml0c3dhcEFQSVtcInVud2FudFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHVud2FudCAoY2lkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYml0c3dhcC91bndhbnQnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH1cbiAgcmV0dXJuIHVud2FudFxufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2JpdHN3YXAnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEJpdHN3YXBBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlV2FudGxpc3RGb3JQZWVyID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Qml0c3dhcEFQSVtcIndhbnRsaXN0Rm9yUGVlclwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHdhbnRsaXN0Rm9yUGVlciAocGVlcklkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCAoYXdhaXQgYXBpLnBvc3QoJ2JpdHN3YXAvd2FudGxpc3QnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHBlZXI6IHBlZXJJZC50b1N0cmluZygpXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pKS5qc29uKClcblxuICAgIHJldHVybiAocmVzLktleXMgfHwgW10pLm1hcCgoLyoqIEB0eXBlIHt7ICcvJzogc3RyaW5nIH19ICovIGspID0+IENJRC5wYXJzZShrWycvJ10pKVxuICB9XG4gIHJldHVybiB3YW50bGlzdEZvclBlZXJcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9iaXRzd2FwJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBCaXRzd2FwQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhbnRsaXN0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Qml0c3dhcEFQSVtcIndhbnRsaXN0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gd2FudGxpc3QgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IChhd2FpdCBhcGkucG9zdCgnYml0c3dhcC93YW50bGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSkpLmpzb24oKVxuXG4gICAgcmV0dXJuIChyZXMuS2V5cyB8fCBbXSkubWFwKCgvKiogQHR5cGUge3sgJy8nOiBzdHJpbmcgfX0gKi8gaykgPT4gQ0lELnBhcnNlKGtbJy8nXSkpXG4gIH1cbiAgcmV0dXJuIHdhbnRsaXN0XG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9ibG9jaycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gQmxvY2tBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlR2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QmxvY2tBUElbXCJnZXRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBnZXQgKGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2Jsb2NrL2dldCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBjaWQudG9TdHJpbmcoKSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpKVxuICB9XG4gIHJldHVybiBnZXRcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVHZXQgfSBmcm9tICcuL2dldC5qcydcbmltcG9ydCB7IGNyZWF0ZVB1dCB9IGZyb20gJy4vcHV0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJ1xuaW1wb3J0IHsgY3JlYXRlU3RhdCB9IGZyb20gJy4vc3RhdC5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrIChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGNyZWF0ZUdldChjb25maWcpLFxuICAgIHB1dDogY3JlYXRlUHV0KGNvbmZpZyksXG4gICAgcm06IGNyZWF0ZVJtKGNvbmZpZyksXG4gICAgc3RhdDogY3JlYXRlU3RhdChjb25maWcpXG4gIH1cbn1cbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0J1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuaW1wb3J0IHsgYWJvcnRTaWduYWwgfSBmcm9tICcuLi9saWIvYWJvcnQtc2lnbmFsLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9ibG9jaycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gQmxvY2tBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUHV0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QmxvY2tBUElbXCJwdXRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBwdXQgKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGFsbG93IGFib3J0aW5nIHJlcXVlc3RzIG9uIGJvZHkgZXJyb3JzXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsKGNvbnRyb2xsZXIuc2lnbmFsLCBvcHRpb25zLnNpZ25hbClcblxuICAgIGxldCByZXNcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnYmxvY2svcHV0Jywge1xuICAgICAgICBzaWduYWw6IHNpZ25hbCxcbiAgICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgICAgLi4uKFxuICAgICAgICAgIGF3YWl0IG11bHRpcGFydFJlcXVlc3QoW2RhdGFdLCBjb250cm9sbGVyLCBvcHRpb25zLmhlYWRlcnMpXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgICByZXMgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICB9IGNhdGNoICgvKiogQHR5cGUge2FueX0gKi8gZXJyKSB7XG4gICAgICAvLyBSZXRyeSB3aXRoIFwicHJvdG9idWZcIi9cImNib3JcIiBmb3JtYXQgZm9yIGdvLWlwZnNcbiAgICAgIC8vIFRPRE86IHJlbW92ZSB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2dvLWNpZC9pc3N1ZXMvNzUgcmVzb2x2ZWRcbiAgICAgIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ2RhZy1wYicpIHtcbiAgICAgICAgcmV0dXJuIHB1dChkYXRhLCB7IC4uLm9wdGlvbnMsIGZvcm1hdDogJ3Byb3RvYnVmJyB9KVxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ2RhZy1jYm9yJykge1xuICAgICAgICByZXR1cm4gcHV0KGRhdGEsIHsgLi4ub3B0aW9ucywgZm9ybWF0OiAnY2JvcicgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIENJRC5wYXJzZShyZXMuS2V5KVxuICB9XG5cbiAgcmV0dXJuIHB1dFxufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2Jsb2NrJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBCbG9ja0FQSVxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9ibG9jaycpLlJtUmVzdWx0fSBSbVJlc3VsdFxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSbSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0Jsb2NrQVBJW1wicm1cIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiAqIHJtIChjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjaWQpKSB7XG4gICAgICBjaWQgPSBbY2lkXVxuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdibG9jay9ybScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBjaWQubWFwKGNpZCA9PiBjaWQudG9TdHJpbmcoKSksXG4gICAgICAgICdzdHJlYW0tY2hhbm5lbHMnOiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHJlbW92ZWQgb2YgcmVzLm5kanNvbigpKSB7XG4gICAgICB5aWVsZCB0b0NvcmVJbnRlcmZhY2UocmVtb3ZlZClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm1cbn0pXG5cbi8qKlxuICogQHBhcmFtIHsqfSByZW1vdmVkXG4gKi9cbmZ1bmN0aW9uIHRvQ29yZUludGVyZmFjZSAocmVtb3ZlZCkge1xuICAvKiogQHR5cGUge1JtUmVzdWx0fSAqL1xuICBjb25zdCBvdXQgPSB7XG4gICAgY2lkOiBDSUQucGFyc2UocmVtb3ZlZC5IYXNoKVxuICB9XG5cbiAgaWYgKHJlbW92ZWQuRXJyb3IpIHtcbiAgICBvdXQuZXJyb3IgPSBuZXcgRXJyb3IocmVtb3ZlZC5FcnJvcilcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2Jsb2NrJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBCbG9ja0FQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTdGF0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QmxvY2tBUElbXCJzdGF0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhdCAoY2lkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYmxvY2svc3RhdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBjaWQudG9TdHJpbmcoKSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4geyBjaWQ6IENJRC5wYXJzZShkYXRhLktleSksIHNpemU6IGRhdGEuU2l6ZSB9XG4gIH1cblxuICByZXR1cm4gc3RhdFxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9ib290c3RyYXAnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEJvb3RzdHJhcEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVBZGQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtCb290c3RyYXBBUElbXCJhZGRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBhZGQgKGFkZHIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdib290c3RyYXAvYWRkJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGFkZHIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IHsgUGVlcnMgfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiB7IFBlZXJzOiBQZWVycy5tYXAoKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBtYSkgPT4gbXVsdGlhZGRyKG1hKSkgfVxuICB9XG5cbiAgcmV0dXJuIGFkZFxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9ib290c3RyYXAnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEJvb3RzdHJhcEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDbGVhciA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0Jvb3RzdHJhcEFQSVtcImNsZWFyXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY2xlYXIgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdib290c3RyYXAvcm0nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGFsbDogdHJ1ZVxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3QgeyBQZWVycyB9ID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIHsgUGVlcnM6IFBlZXJzLm1hcCgoLyoqIEB0eXBlIHtzdHJpbmd9ICovIG1hKSA9PiBtdWx0aWFkZHIobWEpKSB9XG4gIH1cblxuICByZXR1cm4gY2xlYXJcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVBZGQgfSBmcm9tICcuL2FkZC5qcydcbmltcG9ydCB7IGNyZWF0ZUNsZWFyIH0gZnJvbSAnLi9jbGVhci5qcydcbmltcG9ydCB7IGNyZWF0ZUxpc3QgfSBmcm9tICcuL2xpc3QuanMnXG5pbXBvcnQgeyBjcmVhdGVSZXNldCB9IGZyb20gJy4vcmVzZXQuanMnXG5pbXBvcnQgeyBjcmVhdGVSbSB9IGZyb20gJy4vcm0uanMnXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCb290c3RyYXAgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGFkZDogY3JlYXRlQWRkKGNvbmZpZyksXG4gICAgY2xlYXI6IGNyZWF0ZUNsZWFyKGNvbmZpZyksXG4gICAgbGlzdDogY3JlYXRlTGlzdChjb25maWcpLFxuICAgIHJlc2V0OiBjcmVhdGVSZXNldChjb25maWcpLFxuICAgIHJtOiBjcmVhdGVSbShjb25maWcpXG4gIH1cbn1cbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9ib290c3RyYXAnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEJvb3RzdHJhcEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vdHN0cmFwQVBJW1wibGlzdFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3QgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdib290c3RyYXAvbGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IHsgUGVlcnMgfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiB7IFBlZXJzOiBQZWVycy5tYXAoKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBtYSkgPT4gbXVsdGlhZGRyKG1hKSkgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Rcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBtdWx0aWFkZHIgfSBmcm9tICdAbXVsdGlmb3JtYXRzL211bHRpYWRkcidcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvYm9vdHN0cmFwJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBCb290c3RyYXBBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVzZXQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtCb290c3RyYXBBUElbXCJyZXNldFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHJlc2V0IChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYm9vdHN0cmFwL2FkZCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3QgeyBQZWVycyB9ID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIHsgUGVlcnM6IFBlZXJzLm1hcCgoLyoqIEB0eXBlIHtzdHJpbmd9ICovIG1hKSA9PiBtdWx0aWFkZHIobWEpKSB9XG4gIH1cblxuICByZXR1cm4gcmVzZXRcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBtdWx0aWFkZHIgfSBmcm9tICdAbXVsdGlmb3JtYXRzL211bHRpYWRkcidcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvYm9vdHN0cmFwJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBCb290c3RyYXBBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUm0gPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtCb290c3RyYXBBUElbXCJybVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHJtIChhZGRyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYm9vdHN0cmFwL3JtJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGFkZHIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IHsgUGVlcnMgfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiB7IFBlZXJzOiBQZWVycy5tYXAoKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBtYSkgPT4gbXVsdGlhZGRyKG1hKSkgfVxuICB9XG5cbiAgcmV0dXJuIHJtXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yb290JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBSb290QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1Jvb3RBUElbXCJjYXRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiAqIGNhdCAocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2NhdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLnRvU3RyaW5nKCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIHlpZWxkICogcmVzLml0ZXJhdG9yKClcbiAgfVxuXG4gIHJldHVybiBjYXRcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3Jvb3QnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJvb3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29tbWFuZHMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSb290QVBJW1wiY29tbWFuZHNcIl19XG4gICAqL1xuICBjb25zdCBjb21tYW5kcyA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29tbWFuZHMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9XG4gIHJldHVybiBjb21tYW5kc1xufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvY29uZmlnJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBDb25maWdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlR2V0QWxsID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29uZmlnQVBJW1wiZ2V0QWxsXCJdfVxuICAgKi9cbiAgY29uc3QgZ2V0QWxsID0gYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdjb25maWcvc2hvdycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgcmV0dXJuIGdldEFsbFxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvY29uZmlnJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBDb25maWdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlR2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29uZmlnQVBJW1wiZ2V0XCJdfVxuICAgKi9cbiAgY29uc3QgZ2V0ID0gYXN5bmMgKGtleSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigna2V5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGtleSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gZGF0YS5WYWx1ZVxuICB9XG5cbiAgcmV0dXJuIGdldFxufSlcbiIsImltcG9ydCB7IGNyZWF0ZVByb2ZpbGVzIH0gZnJvbSAnLi9wcm9maWxlcy9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZUdldCB9IGZyb20gJy4vZ2V0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlR2V0QWxsIH0gZnJvbSAnLi9nZXQtYWxsLmpzJ1xuaW1wb3J0IHsgY3JlYXRlUmVwbGFjZSB9IGZyb20gJy4vcmVwbGFjZS5qcydcbmltcG9ydCB7IGNyZWF0ZVNldCB9IGZyb20gJy4vc2V0LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29uZmlnIChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRBbGw6IGNyZWF0ZUdldEFsbChjb25maWcpLFxuICAgIGdldDogY3JlYXRlR2V0KGNvbmZpZyksXG4gICAgc2V0OiBjcmVhdGVTZXQoY29uZmlnKSxcbiAgICByZXBsYWNlOiBjcmVhdGVSZXBsYWNlKGNvbmZpZyksXG4gICAgcHJvZmlsZXM6IGNyZWF0ZVByb2ZpbGVzKGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9jb25maWcvcHJvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IENvbmZpZ1Byb2ZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUFwcGx5ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29uZmlnUHJvZmlsZXNBUElbXCJhcHBseVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGFwcGx5IChwcm9maWxlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnL3Byb2ZpbGUvYXBwbHknLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogcHJvZmlsZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luYWw6IGRhdGEuT2xkQ2ZnLCB1cGRhdGVkOiBkYXRhLk5ld0NmZ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcHBseVxufSlcbiIsImltcG9ydCB7IGNyZWF0ZUFwcGx5IH0gZnJvbSAnLi9hcHBseS5qcydcbmltcG9ydCB7IGNyZWF0ZUxpc3QgfSBmcm9tICcuL2xpc3QuanMnXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzJykuT3B0aW9uc30gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9maWxlcyAoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgYXBwbHk6IGNyZWF0ZUFwcGx5KGNvbmZpZyksXG4gICAgbGlzdDogY3JlYXRlTGlzdChjb25maWcpXG4gIH1cbn1cbiIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi8uLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9jb25maWcvcHJvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IENvbmZpZ1Byb2ZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUxpc3QgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtDb25maWdQcm9maWxlc0FQSVtcImxpc3RcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBsaXN0IChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnL3Byb2ZpbGUvbGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gZGF0YS5tYXAoKC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi8gcHJvZmlsZSkgPT4gb2JqZWN0VG9DYW1lbChwcm9maWxlKSlcbiAgfVxuICByZXR1cm4gbGlzdFxufSlcbiIsImltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZydcbmltcG9ydCB7IG11bHRpcGFydFJlcXVlc3QgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGlwYXJ0LXJlcXVlc3QnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2NvbmZpZycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gQ29uZmlnQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlcGxhY2UgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtDb25maWdBUElbXCJyZXBsYWNlXCJdfVxuICAgKi9cbiAgY29uc3QgcmVwbGFjZSA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIC8vIGFsbG93IGFib3J0aW5nIHJlcXVlc3RzIG9uIGJvZHkgZXJyb3JzXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsKGNvbnRyb2xsZXIuc2lnbmFsLCBvcHRpb25zLnNpZ25hbClcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdjb25maWcvcmVwbGFjZScsIHtcbiAgICAgIHNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICAuLi4oXG4gICAgICAgIGF3YWl0IG11bHRpcGFydFJlcXVlc3QoW3VpbnQ4QXJyYXlGcm9tU3RyaW5nKEpTT04uc3RyaW5naWZ5KGNvbmZpZykpXSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgKVxuICAgIH0pXG5cbiAgICBhd2FpdCByZXMudGV4dCgpXG4gIH1cblxuICByZXR1cm4gcmVwbGFjZVxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvY29uZmlnJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBDb25maWdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29uZmlnQVBJW1wic2V0XCJdfVxuICAgKi9cbiAgY29uc3Qgc2V0ID0gYXN5bmMgKGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSB0eXBlJylcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4uZW5jb2RlUGFyYW0oa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMocGFyYW1zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBhd2FpdCByZXMudGV4dCgpXG4gIH1cblxuICByZXR1cm4gc2V0XG59KVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmNvbnN0IGVuY29kZVBhcmFtID0gKGtleSwgdmFsdWUpID0+IHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB7IGFyZzogW2tleSwgdmFsdWUudG9TdHJpbmcoKV0sIGJvb2w6IHRydWUgfVxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4geyBhcmc6IFtrZXksIHZhbHVlXSB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IGFyZzogW2tleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpXSwganNvbjogdHJ1ZSB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZGFnJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBEQUdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRXhwb3J0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7REFHQVBJW1wiZXhwb3J0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBkYWdFeHBvcnQgKHJvb3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkYWcvZXhwb3J0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHJvb3QudG9TdHJpbmcoKVxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgeWllbGQgKiByZXMuaXRlcmF0b3IoKVxuICB9XG5cbiAgcmV0dXJuIGRhZ0V4cG9ydFxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAnLi4vbGliL3Jlc29sdmUuanMnXG5pbXBvcnQgZmlyc3QgZnJvbSAnaXQtZmlyc3QnXG5pbXBvcnQgbGFzdCBmcm9tICdpdC1sYXN0J1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnXG5pbXBvcnQgeyBjcmVhdGVHZXQgYXMgY3JlYXRlQmxvY2tHZXQgfSBmcm9tICcuLi9ibG9jay9nZXQuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2RhZycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gREFHQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jb3JlLXV0aWxzL211bHRpY29kZWNzJykuTXVsdGljb2RlY3N9IGNvZGVjc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gb3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlR2V0ID0gKGNvZGVjcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmbiA9IGNvbmZpZ3VyZSgoYXBpLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgZ2V0QmxvY2sgPSBjcmVhdGVCbG9ja0dldChvcHRzKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0RBR0FQSVtcImdldFwiXX1cbiAgICAgKi9cbiAgICBjb25zdCBnZXQgPSBhc3luYyAoY2lkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBvcHRpb25zLmxvY2FsUmVzb2x2ZVxuICAgICAgICAgID8gYXdhaXQgZmlyc3QocmVzb2x2ZShjaWQsIG9wdGlvbnMucGF0aCwgY29kZWNzLCBnZXRCbG9jaywgb3B0aW9ucykpXG4gICAgICAgICAgOiBhd2FpdCBsYXN0KHJlc29sdmUoY2lkLCBvcHRpb25zLnBhdGgsIGNvZGVjcywgZ2V0QmxvY2ssIG9wdGlvbnMpKVxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9kYWcnKS5HZXRSZXN1bHQgfCB1bmRlZmluZWR9IC0gZmlyc3QgYW5kIGxhc3Qgd2lsbCByZXR1cm4gdW5kZWZpbmVkIHdoZW4gZW1wdHkgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKGVudHJ5KVxuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vdCBmb3VuZCcpLCAnRVJSX05PVF9GT1VORCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvZGVjID0gYXdhaXQgY29kZWNzLmdldENvZGVjKGNpZC5jb2RlKVxuICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBnZXRCbG9jayhjaWQsIG9wdGlvbnMpXG4gICAgICBjb25zdCBub2RlID0gY29kZWMuZGVjb2RlKGJsb2NrKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbm9kZSxcbiAgICAgICAgcmVtYWluZGVyUGF0aDogJydcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0XG4gIH0pXG5cbiAgcmV0dXJuIGZuKG9wdGlvbnMpXG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnXG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0J1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZGFnJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBEQUdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW1wb3J0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7REFHQVBJW1wiaW1wb3J0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBkYWdJbXBvcnQgKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsKGNvbnRyb2xsZXIuc2lnbmFsLCBvcHRpb25zLnNpZ25hbClcbiAgICBjb25zdCB7IGhlYWRlcnMsIGJvZHkgfSA9IGF3YWl0IG11bHRpcGFydFJlcXVlc3Qoc291cmNlLCBjb250cm9sbGVyLCBvcHRpb25zLmhlYWRlcnMpXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGFnL2ltcG9ydCcsIHtcbiAgICAgIHNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7ICdwaW4tcm9vdHMnOiBvcHRpb25zLnBpblJvb3RzIH0pXG4gICAgfSlcblxuICAgIGZvciBhd2FpdCAoY29uc3QgeyBSb290IH0gb2YgcmVzLm5kanNvbigpKSB7XG4gICAgICBpZiAoUm9vdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgQ2lkOiB7ICcvJzogQ2lkIH0sIFBpbkVycm9yTXNnIH0gPSBSb290XG5cbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGNpZDogQ0lELnBhcnNlKENpZCksXG4gICAgICAgICAgICBwaW5FcnJvck1zZzogUGluRXJyb3JNc2dcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGFnSW1wb3J0XG59KVxuIiwiaW1wb3J0IHsgY3JlYXRlRXhwb3J0IH0gZnJvbSAnLi9leHBvcnQuanMnXG5pbXBvcnQgeyBjcmVhdGVHZXQgfSBmcm9tICcuL2dldC5qcydcbmltcG9ydCB7IGNyZWF0ZUltcG9ydCB9IGZyb20gJy4vaW1wb3J0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUHV0IH0gZnJvbSAnLi9wdXQuanMnXG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZlIH0gZnJvbSAnLi9yZXNvbHZlLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNvcmUtdXRpbHMvbXVsdGljb2RlY3MnKS5NdWx0aWNvZGVjc30gY29kZWNzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURhZyAoY29kZWNzLCBjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBvcnQ6IGNyZWF0ZUV4cG9ydChjb25maWcpLFxuICAgIGdldDogY3JlYXRlR2V0KGNvZGVjcywgY29uZmlnKSxcbiAgICBpbXBvcnQ6IGNyZWF0ZUltcG9ydChjb25maWcpLFxuICAgIHB1dDogY3JlYXRlUHV0KGNvZGVjcywgY29uZmlnKSxcbiAgICByZXNvbHZlOiBjcmVhdGVSZXNvbHZlKGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0J1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2RhZycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gREFHQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jb3JlLXV0aWxzL211bHRpY29kZWNzJykuTXVsdGljb2RlY3N9IGNvZGVjc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gb3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUHV0ID0gKGNvZGVjcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmbiA9IGNvbmZpZ3VyZSgoYXBpKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RBR0FQSVtcInB1dFwiXX1cbiAgICAgKi9cbiAgICBjb25zdCBwdXQgPSBhc3luYyAoZGFnTm9kZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgc3RvcmVDb2RlYzogJ2RhZy1jYm9yJyxcbiAgICAgICAgaGFzaEFsZzogJ3NoYTItMjU2JyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBsZXQgc2VyaWFsaXplZFxuXG4gICAgICBpZiAoc2V0dGluZ3MuaW5wdXRDb2RlYykge1xuICAgICAgICAvLyBpZiB5b3Ugc3VwcGx5IGFuIGlucHV0Q29kZWMsIHdlIGFzc3VtZSB5b3UncmUgcGFzc2luZyBpbiBhIHJhdywgZW5jb2RlZFxuICAgICAgICAvLyBibG9jayB1c2luZyB0aGF0IGNvZGVjLCBzbyB3ZSdsbCBqdXN0IHBhc3MgdGhhdCBvbiB0byB0aGUgc2VydmVyIGFuZCBsZXRcbiAgICAgICAgLy8gaXQgZGVhbCB3aXRoIHRoZSBkZWNvZGUvZW5jb2RlL3N0b3JlIGN5Y2xlXG4gICAgICAgIGlmICghKGRhZ05vZGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgaW5wdXRDb2RlYyBvbiByYXcgYnl0ZXMgdGhhdCBjYW4gYmUgZGVjb2RlZCcpXG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZCA9IGRhZ05vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHlvdSBkb24ndCBzdXBwbHkgYW4gaW5wdXRDb2RlYywgd2UgYXNzdW1lIHlvdSd2ZSBwYXNzZWQgaW4gYSBKYXZhU2NyaXB0XG4gICAgICAgIC8vIG9iamVjdCB5b3Ugd2FudCB0byBoYXZlIGVuY29kZWQgdXNpbmcgc3RvcmVDb2RlYywgc28gd2UnbGwgcHJlcGFyZSBpdCBmb3JcbiAgICAgICAgLy8geW91IGlmIHdlIGhhdmUgdGhlIGNvZGVjXG4gICAgICAgIGNvbnN0IHN0b3JlQ29kZWMgPSBhd2FpdCBjb2RlY3MuZ2V0Q29kZWMoc2V0dGluZ3Muc3RvcmVDb2RlYylcbiAgICAgICAgc2VyaWFsaXplZCA9IHN0b3JlQ29kZWMuZW5jb2RlKGRhZ05vZGUpXG4gICAgICAgIC8vIG5vdyB3ZSBoYXZlIGEgc2VyaWFsaXplZCBmb3JtLCB0aGUgc2VydmVyIHNob3VsZCBiZSB0b2xkIHRvIHJlY2VpdmUgaXRcbiAgICAgICAgLy8gaW4gdGhhdCBmb3JtYXRcbiAgICAgICAgc2V0dGluZ3MuaW5wdXRDb2RlYyA9IHNldHRpbmdzLnN0b3JlQ29kZWNcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb3cgYWJvcnRpbmcgcmVxdWVzdHMgb24gYm9keSBlcnJvcnNcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsKGNvbnRyb2xsZXIuc2lnbmFsLCBzZXR0aW5ncy5zaWduYWwpXG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkYWcvcHV0Jywge1xuICAgICAgICB0aW1lb3V0OiBzZXR0aW5ncy50aW1lb3V0LFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoc2V0dGluZ3MpLFxuICAgICAgICAuLi4oXG4gICAgICAgICAgYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdChbc2VyaWFsaXplZF0sIGNvbnRyb2xsZXIsIHNldHRpbmdzLmhlYWRlcnMpXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgICByZXR1cm4gQ0lELnBhcnNlKGRhdGEuQ2lkWycvJ10pXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1dFxuICB9KVxuXG4gIHJldHVybiBmbihvcHRpb25zKVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZGFnJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBEQUdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVzb2x2ZSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0RBR0FQSVtcInJlc29sdmVcIl19XG4gICAqL1xuICBjb25zdCByZXNvbHZlID0gYXN5bmMgKGlwZnNQYXRoLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGFnL3Jlc29sdmUnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYCR7aXBmc1BhdGh9JHtvcHRpb25zLnBhdGggPyBgLyR7b3B0aW9ucy5wYXRofWAucmVwbGFjZSgvXFwvWy9dKy9nLCAnLycpIDogJyd9YCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiB7IGNpZDogQ0lELnBhcnNlKGRhdGEuQ2lkWycvJ10pLCByZW1haW5kZXJQYXRoOiBkYXRhLlJlbVBhdGggfVxuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBtYXBFdmVudCB9IGZyb20gJy4vbWFwLWV2ZW50LmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9kaHQnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IERIVEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVGaW5kUGVlciA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0RIVEFQSVtcImZpbmRQZWVyXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBmaW5kUGVlciAocGVlcklkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGh0L2ZpbmRwZWVyJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBlZXJJZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIHlpZWxkIG1hcEV2ZW50KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kUGVlclxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IG1hcEV2ZW50IH0gZnJvbSAnLi9tYXAtZXZlbnQuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2RodCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gREhUQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUZpbmRQcm92cyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0RIVEFQSVtcImZpbmRQcm92c1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogZmluZFByb3ZzIChjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkaHQvZmluZHByb3ZzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGNpZC50b1N0cmluZygpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgeWllbGQgbWFwRXZlbnQoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmRQcm92c1xufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IG1hcEV2ZW50IH0gZnJvbSAnLi9tYXAtZXZlbnQuanMnXG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2RodCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gREhUQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0RIVEFQSVtcImdldFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogZ2V0IChrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkaHQvZ2V0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAvLyBhcmc6IGJhc2UzNi5lbmNvZGUoa2V5KSxcbiAgICAgICAgYXJnOiBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdWludDhBcnJheVRvU3RyaW5nKGtleSkgOiBrZXkudG9TdHJpbmcoKSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIHlpZWxkIG1hcEV2ZW50KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVGaW5kUGVlciB9IGZyb20gJy4vZmluZC1wZWVyLmpzJ1xuaW1wb3J0IHsgY3JlYXRlRmluZFByb3ZzIH0gZnJvbSAnLi9maW5kLXByb3ZzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlR2V0IH0gZnJvbSAnLi9nZXQuanMnXG5pbXBvcnQgeyBjcmVhdGVQcm92aWRlIH0gZnJvbSAnLi9wcm92aWRlLmpzJ1xuaW1wb3J0IHsgY3JlYXRlUHV0IH0gZnJvbSAnLi9wdXQuanMnXG5pbXBvcnQgeyBjcmVhdGVRdWVyeSB9IGZyb20gJy4vcXVlcnkuanMnXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEaHQgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGZpbmRQZWVyOiBjcmVhdGVGaW5kUGVlcihjb25maWcpLFxuICAgIGZpbmRQcm92czogY3JlYXRlRmluZFByb3ZzKGNvbmZpZyksXG4gICAgZ2V0OiBjcmVhdGVHZXQoY29uZmlnKSxcbiAgICBwcm92aWRlOiBjcmVhdGVQcm92aWRlKGNvbmZpZyksXG4gICAgcHV0OiBjcmVhdGVQdXQoY29uZmlnKSxcbiAgICBxdWVyeTogY3JlYXRlUXVlcnkoY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBmcm9tU3RyaW5nIGFzIHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvZnJvbS1zdHJpbmcnXG5pbXBvcnQge1xuICBTZW5kaW5nUXVlcnksXG4gIFBlZXJSZXNwb25zZSxcbiAgRmluYWxQZWVyLFxuICBRdWVyeUVycm9yLFxuICBQcm92aWRlcixcbiAgVmFsdWUsXG4gIEFkZGluZ1BlZXIsXG4gIERpYWxpbmdQZWVyXG59IGZyb20gJy4vcmVzcG9uc2UtdHlwZXMuanMnXG5pbXBvcnQgeyBtdWx0aWFkZHIgfSBmcm9tICdAbXVsdGlmb3JtYXRzL211bHRpYWRkcidcbmltcG9ydCB7IHBlZXJJZEZyb21TdHJpbmcgfSBmcm9tICdAbGlicDJwL3BlZXItaWQnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnQGxpYnAycC9pbnRlcmZhY2UtcGVlci1pZCcpLlBlZXJJZH0gUGVlcklkXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAbXVsdGlmb3JtYXRzL211bHRpYWRkcicpLk11bHRpYWRkcn0gTXVsdGlhZGRyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3tUeXBlOiBudW1iZXIsIElEOiBzdHJpbmcsIEV4dHJhOiBzdHJpbmcsIFJlc3BvbnNlczoge0lEOiBzdHJpbmcsIEFkZHJzOiBzdHJpbmdbXX1bXX19IGV2ZW50XG4gKiBAcmV0dXJucyB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2RodCcpLlF1ZXJ5RXZlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBFdmVudCA9IChldmVudCkgPT4ge1xuICBpZiAoZXZlbnQuVHlwZSA9PT0gU2VuZGluZ1F1ZXJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdTRU5ESU5HX1FVRVJZJyxcbiAgICAgIHR5cGU6IGV2ZW50LlR5cGVcbiAgICB9XG4gIH1cblxuICBpZiAoZXZlbnQuVHlwZSA9PT0gUGVlclJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IHBlZXJJZEZyb21TdHJpbmcoZXZlbnQuSUQpLFxuICAgICAgbmFtZTogJ1BFRVJfUkVTUE9OU0UnLFxuICAgICAgdHlwZTogZXZlbnQuVHlwZSxcbiAgICAgIC8vIFRPRE86IGhvdyB0byBpbmZlciB0aGlzIGZyb20gdGhlIGdvLWlwZnMgcmVzcG9uc2VcbiAgICAgIG1lc3NhZ2VUeXBlOiAwLFxuICAgICAgLy8gVE9ETzogaG93IHRvIGluZmVyIHRoaXMgZnJvbSB0aGUgZ28taXBmcyByZXNwb25zZVxuICAgICAgbWVzc2FnZU5hbWU6ICdQVVRfVkFMVUUnLFxuICAgICAgY2xvc2VyOiAoZXZlbnQuUmVzcG9uc2VzIHx8IFtdKS5tYXAoKHsgSUQsIEFkZHJzIH0pID0+ICh7IGlkOiBwZWVySWRGcm9tU3RyaW5nKElEKSwgbXVsdGlhZGRyczogQWRkcnMubWFwKGFkZHIgPT4gbXVsdGlhZGRyKGFkZHIpKSwgcHJvdG9jb2xzOiBbXSB9KSksXG4gICAgICBwcm92aWRlcnM6IChldmVudC5SZXNwb25zZXMgfHwgW10pLm1hcCgoeyBJRCwgQWRkcnMgfSkgPT4gKHsgaWQ6IHBlZXJJZEZyb21TdHJpbmcoSUQpLCBtdWx0aWFkZHJzOiBBZGRycy5tYXAoYWRkciA9PiBtdWx0aWFkZHIoYWRkcikpLCBwcm90b2NvbHM6IFtdIH0pKVxuICAgICAgLy8gVE9ETzogaG93IHRvIGluZmVyIHRoaXMgZnJvbSB0aGUgZ28taXBmcyByZXNwb25zZVxuICAgICAgLy8gcmVjb3JkOiA/Pz9cbiAgICB9XG4gIH1cblxuICBpZiAoZXZlbnQuVHlwZSA9PT0gRmluYWxQZWVyKSB7XG4gICAgLy8gZGh0LnF1ZXJ5IGVuZHMgd2l0aCBhIEZpbmFsUGVlciBldmVudCB3aXRoIG5vIFJlc3BvbnNlc1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCdAbGlicDJwL2ludGVyZmFjZS1wZWVyLWluZm8nKS5QZWVySW5mb30gKi9cbiAgICBsZXQgcGVlciA9IHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZ28taXBmcyBkb2VzIG5vdCByZXR1cm4gdGhpc1xuICAgICAgaWQ6IGV2ZW50LklEID8/IHBlZXJJZEZyb21TdHJpbmcoZXZlbnQuSUQpLFxuICAgICAgLyoqIEB0eXBlIHtNdWx0aWFkZHJbXX0gKi9cbiAgICAgIG11bHRpYWRkcnM6IFtdLFxuICAgICAgcHJvdG9jb2xzOiBbXVxuICAgIH1cblxuICAgIGlmIChldmVudC5SZXNwb25zZXMgJiYgZXZlbnQuUmVzcG9uc2VzLmxlbmd0aCkge1xuICAgICAgLy8gZGh0LmZpbmRQZWVyIGhhcyB0aGUgcmVzdWx0IGluIHRoZSBSZXNwb25zZXMgZmllbGRcbiAgICAgIHBlZXIgPSB7XG4gICAgICAgIGlkOiBwZWVySWRGcm9tU3RyaW5nKGV2ZW50LlJlc3BvbnNlc1swXS5JRCksXG4gICAgICAgIG11bHRpYWRkcnM6IGV2ZW50LlJlc3BvbnNlc1swXS5BZGRycy5tYXAoYWRkciA9PiBtdWx0aWFkZHIoYWRkcikpLFxuICAgICAgICBwcm90b2NvbHM6IFtdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdGSU5BTF9QRUVSJyxcbiAgICAgIHR5cGU6IGV2ZW50LlR5cGUsXG4gICAgICBwZWVyXG4gICAgfVxuICB9XG5cbiAgaWYgKGV2ZW50LlR5cGUgPT09IFF1ZXJ5RXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ1FVRVJZX0VSUk9SJyxcbiAgICAgIHR5cGU6IGV2ZW50LlR5cGUsXG4gICAgICBlcnJvcjogbmV3IEVycm9yKGV2ZW50LkV4dHJhKVxuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudC5UeXBlID09PSBQcm92aWRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnUFJPVklERVInLFxuICAgICAgdHlwZTogZXZlbnQuVHlwZSxcbiAgICAgIHByb3ZpZGVyczogZXZlbnQuUmVzcG9uc2VzLm1hcCgoeyBJRCwgQWRkcnMgfSkgPT4gKHsgaWQ6IHBlZXJJZEZyb21TdHJpbmcoSUQpLCBtdWx0aWFkZHJzOiBBZGRycy5tYXAoYWRkciA9PiBtdWx0aWFkZHIoYWRkcikpLCBwcm90b2NvbHM6IFtdIH0pKVxuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudC5UeXBlID09PSBWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnVkFMVUUnLFxuICAgICAgdHlwZTogZXZlbnQuVHlwZSxcbiAgICAgIHZhbHVlOiB1aW50OEFycmF5RnJvbVN0cmluZyhldmVudC5FeHRyYSwgJ2Jhc2U2NHBhZCcpXG4gICAgfVxuICB9XG5cbiAgaWYgKGV2ZW50LlR5cGUgPT09IEFkZGluZ1BlZXIpIHtcbiAgICBjb25zdCBwZWVycyA9IGV2ZW50LlJlc3BvbnNlcy5tYXAoKHsgSUQgfSkgPT4gcGVlcklkRnJvbVN0cmluZyhJRCkpXG5cbiAgICBpZiAoIXBlZXJzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwZWVyIGZvdW5kJylcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0FERElOR19QRUVSJyxcbiAgICAgIHR5cGU6IGV2ZW50LlR5cGUsXG4gICAgICBwZWVyOiBwZWVyc1swXVxuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudC5UeXBlID09PSBEaWFsaW5nUGVlcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnRElBTElOR19QRUVSJyxcbiAgICAgIHR5cGU6IGV2ZW50LlR5cGUsXG4gICAgICBwZWVyOiBwZWVySWRGcm9tU3RyaW5nKGV2ZW50LklEKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBESFQgZXZlbnQgdHlwZScpXG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBtYXBFdmVudCB9IGZyb20gJy4vbWFwLWV2ZW50LmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9kaHQnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IERIVEFQSVxuICogQHR5cGVkZWYge2ltcG9ydCgnbXVsdGlmb3JtYXRzL2NpZCcpLkNJRH0gQ0lEXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVByb3ZpZGUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtESFRBUElbXCJwcm92aWRlXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBwcm92aWRlIChjaWRzLCBvcHRpb25zID0geyByZWN1cnNpdmU6IGZhbHNlIH0pIHtcbiAgICAvKiogQHR5cGUge0NJRFtdfSAqL1xuICAgIGNvbnN0IGNpZEFyciA9IEFycmF5LmlzQXJyYXkoY2lkcykgPyBjaWRzIDogW2NpZHNdXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGh0L3Byb3ZpZGUnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogY2lkQXJyLm1hcChjaWQgPT4gY2lkLnRvU3RyaW5nKCkpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgeWllbGQgbWFwRXZlbnQoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3ZpZGVcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0J1xuaW1wb3J0IHsgYWJvcnRTaWduYWwgfSBmcm9tICcuLi9saWIvYWJvcnQtc2lnbmFsLmpzJ1xuaW1wb3J0IHsgdG9TdHJpbmcgYXMgdWludDhBcnJheVRvU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvdG8tc3RyaW5nJ1xuaW1wb3J0IHsgbWFwRXZlbnQgfSBmcm9tICcuL21hcC1ldmVudC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZGh0JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBESFRBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUHV0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7REhUQVBJW1wicHV0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBwdXQgKGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGFsbG93IGFib3J0aW5nIHJlcXVlc3RzIG9uIGJvZHkgZXJyb3JzXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsKGNvbnRyb2xsZXIuc2lnbmFsLCBvcHRpb25zLnNpZ25hbClcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkaHQvcHV0Jywge1xuICAgICAgc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzoga2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHVpbnQ4QXJyYXlUb1N0cmluZyhrZXkpIDoga2V5LnRvU3RyaW5nKCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgLi4uKFxuICAgICAgICBhd2FpdCBtdWx0aXBhcnRSZXF1ZXN0KFt2YWx1ZV0sIGNvbnRyb2xsZXIsIG9wdGlvbnMuaGVhZGVycylcbiAgICAgIClcbiAgICB9KVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIHlpZWxkIG1hcEV2ZW50KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdXRcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBtYXBFdmVudCB9IGZyb20gJy4vbWFwLWV2ZW50LmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9kaHQnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IERIVEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVRdWVyeSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0RIVEFQSVtcInF1ZXJ5XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBxdWVyeSAocGVlcklkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGh0L3F1ZXJ5Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBlZXJJZC50b1N0cmluZygpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgeWllbGQgbWFwRXZlbnQoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5XG59KVxuIiwiXG4vLyBSZXNwb25zZSB0eXBlcyBhcmUgZGVmaW5lZCBoZXJlID1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJwMnAvZ28tbGlicDJwLWNvcmUvYmxvYi82ZTU2NmQxMGY0YTU0NDczMTdhNjZkNjRjNzQ1OTk1NGI5NjliZGFiL3JvdXRpbmcvcXVlcnkuZ28jTDE1LUwyNFxuZXhwb3J0IGNvbnN0IFNlbmRpbmdRdWVyeSA9IDBcbmV4cG9ydCBjb25zdCBQZWVyUmVzcG9uc2UgPSAxXG5leHBvcnQgY29uc3QgRmluYWxQZWVyID0gMlxuZXhwb3J0IGNvbnN0IFF1ZXJ5RXJyb3IgPSAzXG5leHBvcnQgY29uc3QgUHJvdmlkZXIgPSA0XG5leHBvcnQgY29uc3QgVmFsdWUgPSA1XG5leHBvcnQgY29uc3QgQWRkaW5nUGVlciA9IDZcbmV4cG9ydCBjb25zdCBEaWFsaW5nUGVlciA9IDdcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZGlhZycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gRGlhZ0FQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDbWRzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RGlhZ0FQSVtcImNtZHNcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBjbWRzIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGlhZy9jbWRzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfVxuICByZXR1cm4gY21kc1xufSlcbiIsImltcG9ydCB7IGNyZWF0ZUNtZHMgfSBmcm9tICcuL2NtZHMuanMnXG5pbXBvcnQgeyBjcmVhdGVOZXQgfSBmcm9tICcuL25ldC5qcydcbmltcG9ydCB7IGNyZWF0ZVN5cyB9IGZyb20gJy4vc3lzLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGlhZyAoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgY21kczogY3JlYXRlQ21kcyhjb25maWcpLFxuICAgIG5ldDogY3JlYXRlTmV0KGNvbmZpZyksXG4gICAgc3lzOiBjcmVhdGVTeXMoY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2RpYWcnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IERpYWdBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTmV0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RGlhZ0FQSVtcIm5ldFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIG5ldCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2RpYWcvbmV0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH1cbiAgcmV0dXJuIG5ldFxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZGlhZycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gRGlhZ0FQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTeXMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtEaWFnQVBJW1wic3lzXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3lzIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGlhZy9zeXMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9XG4gIHJldHVybiBzeXNcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3Jvb3QnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJvb3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRG5zID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Um9vdEFQSVtcImRuc1wiXX1cbiAgICovXG4gIGNvbnN0IGRucyA9IGFzeW5jIChkb21haW4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkbnMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogZG9tYWluLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiBkYXRhLlBhdGhcbiAgfVxuXG4gIHJldHVybiBkbnNcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2ZpbGVzJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBGaWxlc0FQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDaG1vZCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0ZpbGVzQVBJW1wiY2htb2RcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBjaG1vZCAocGF0aCwgbW9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2ZpbGVzL2NobW9kJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGF3YWl0IHJlcy50ZXh0KClcbiAgfVxuICByZXR1cm4gY2htb2Rcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9maWxlcycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gRmlsZXNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ3AgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcImNwXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY3AgKHNvdXJjZXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscycpLklQRlNQYXRoW119ICovXG4gICAgY29uc3Qgc291cmNlQXJyID0gQXJyYXkuaXNBcnJheShzb3VyY2VzKSA/IHNvdXJjZXMgOiBbc291cmNlc11cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy9jcCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBzb3VyY2VBcnIuY29uY2F0KGRlc3RpbmF0aW9uKS5tYXAoc3JjID0+IENJRC5hc0NJRChzcmMpID8gYC9pcGZzLyR7c3JjfWAgOiBzcmMpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBhd2FpdCByZXMudGV4dCgpXG4gIH1cbiAgcmV0dXJuIGNwXG59KVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUZsdXNoID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RmlsZXNBUElbXCJmbHVzaFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGZsdXNoIChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwZnMuZmlsZXMuZmx1c2ggcmVxdWlyZXMgYSBwYXRoJylcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvZmx1c2gnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogcGF0aCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gQ0lELnBhcnNlKGRhdGEuQ2lkKVxuICB9XG4gIHJldHVybiBmbHVzaFxufSlcbiIsImltcG9ydCB7IGNyZWF0ZUNobW9kIH0gZnJvbSAnLi9jaG1vZC5qcydcbmltcG9ydCB7IGNyZWF0ZUNwIH0gZnJvbSAnLi9jcC5qcydcbmltcG9ydCB7IGNyZWF0ZUZsdXNoIH0gZnJvbSAnLi9mbHVzaC5qcydcbmltcG9ydCB7IGNyZWF0ZUxzIH0gZnJvbSAnLi9scy5qcydcbmltcG9ydCB7IGNyZWF0ZU1rZGlyIH0gZnJvbSAnLi9ta2Rpci5qcydcbmltcG9ydCB7IGNyZWF0ZU12IH0gZnJvbSAnLi9tdi5qcydcbmltcG9ydCB7IGNyZWF0ZVJlYWQgfSBmcm9tICcuL3JlYWQuanMnXG5pbXBvcnQgeyBjcmVhdGVSbSB9IGZyb20gJy4vcm0uanMnXG5pbXBvcnQgeyBjcmVhdGVTdGF0IH0gZnJvbSAnLi9zdGF0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlVG91Y2ggfSBmcm9tICcuL3RvdWNoLmpzJ1xuaW1wb3J0IHsgY3JlYXRlV3JpdGUgfSBmcm9tICcuL3dyaXRlLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmlsZXMgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGNobW9kOiBjcmVhdGVDaG1vZChjb25maWcpLFxuICAgIGNwOiBjcmVhdGVDcChjb25maWcpLFxuICAgIGZsdXNoOiBjcmVhdGVGbHVzaChjb25maWcpLFxuICAgIGxzOiBjcmVhdGVMcyhjb25maWcpLFxuICAgIG1rZGlyOiBjcmVhdGVNa2Rpcihjb25maWcpLFxuICAgIG12OiBjcmVhdGVNdihjb25maWcpLFxuICAgIHJlYWQ6IGNyZWF0ZVJlYWQoY29uZmlnKSxcbiAgICBybTogY3JlYXRlUm0oY29uZmlnKSxcbiAgICBzdGF0OiBjcmVhdGVTdGF0KGNvbmZpZyksXG4gICAgdG91Y2g6IGNyZWF0ZVRvdWNoKGNvbmZpZyksXG4gICAgd3JpdGU6IGNyZWF0ZVdyaXRlKGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IG9iamVjdFRvQ2FtZWxXaXRoTWV0YWRhdGEgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLXdpdGgtbWV0YWRhdGEuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2ZpbGVzJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBGaWxlc0FQSVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTHMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcImxzXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBscyAocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwZnMuZmlsZXMubHMgcmVxdWlyZXMgYSBwYXRoJylcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvbHMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogQ0lELmFzQ0lEKHBhdGgpID8gYC9pcGZzLyR7cGF0aH1gIDogcGF0aCxcbiAgICAgICAgLy8gZGVmYXVsdCBsb25nIHRvIHRydWUsIGRpdmVyZ2VzIGZyb20gZ28taXBmcyB3aGVyZSBpdHMgZmFsc2UgYnkgZGVmYXVsdFxuICAgICAgICBsb25nOiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzdHJlYW06IHRydWVcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgLy8gZ28taXBmcyBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgXCJzdHJlYW1cIiBvcHRpb25cbiAgICAgIGlmICgnRW50cmllcycgaW4gcmVzdWx0KSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVzdWx0LkVudHJpZXMgfHwgW10pIHtcbiAgICAgICAgICB5aWVsZCB0b0NvcmVJbnRlcmZhY2Uob2JqZWN0VG9DYW1lbFdpdGhNZXRhZGF0YShlbnRyeSkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRvQ29yZUludGVyZmFjZShvYmplY3RUb0NhbWVsV2l0aE1ldGFkYXRhKHJlc3VsdCkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsc1xufSlcblxuLyoqXG4gKiBAcGFyYW0geyp9IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIHRvQ29yZUludGVyZmFjZSAoZW50cnkpIHtcbiAgaWYgKGVudHJ5Lmhhc2gpIHtcbiAgICBlbnRyeS5jaWQgPSBDSUQucGFyc2UoZW50cnkuaGFzaClcbiAgfVxuXG4gIGRlbGV0ZSBlbnRyeS5oYXNoXG5cbiAgZW50cnkudHlwZSA9IGVudHJ5LnR5cGUgPT09IDEgPyAnZGlyZWN0b3J5JyA6ICdmaWxlJ1xuXG4gIHJldHVybiBlbnRyeVxufVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9maWxlcycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gRmlsZXNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWtkaXIgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcIm1rZGlyXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gbWtkaXIgKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy9ta2RpcicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICBhd2FpdCByZXMudGV4dCgpXG4gIH1cbiAgcmV0dXJuIG1rZGlyXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9maWxlcycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gRmlsZXNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTXYgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcIm12XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gbXYgKHNvdXJjZXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlcykpIHtcbiAgICAgIHNvdXJjZXMgPSBbc291cmNlc11cbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvbXYnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogc291cmNlcy5jb25jYXQoZGVzdGluYXRpb24pLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgYXdhaXQgcmVzLnRleHQoKVxuICB9XG5cbiAgcmV0dXJuIG12XG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuLy8gQHRzLWV4cGVjdC1lcnJvciBubyB0eXBlc1xuaW1wb3J0IHRvSXRlcmFibGUgZnJvbSAnc3RyZWFtLXRvLWl0L3NvdXJjZS5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlYWQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcInJlYWRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiAqIHJlYWQgKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy9yZWFkJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIGNvdW50OiBvcHRpb25zLmxlbmd0aCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgeWllbGQgKiB0b0l0ZXJhYmxlKHJlcy5ib2R5KVxuICB9XG4gIHJldHVybiByZWFkXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuaW1wb3J0IEhUVFAgZnJvbSAnaXBmcy11dGlscy9zcmMvaHR0cC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJtID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RmlsZXNBUElbXCJybVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHJtIChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvcm0nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogcGF0aCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy50ZXh0KClcbiAgICAvLyB3ZSBkb24ndCBleHBlY3QgdGV4dCBib2R5IHRvIGJlIGV2ZXIgcHJlc2VudFxuICAgIC8vIChpZiBzbywgaXQgbWVhbnMgYW4gZXJyb3Igc3VjaCBhcyBodHRwczovL2dpdGh1Yi5jb20vaXBmcy9nby1pcGZzL2lzc3Vlcy84NjA2KVxuICAgIGlmIChib2R5ICE9PSAnJykge1xuICAgICAgLyoqIEB0eXBlIHtFcnJvcn0gKi9cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEhUVFAuSFRUUEVycm9yKHJlcylcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBib2R5XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuICByZXR1cm4gcm1cbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgb2JqZWN0VG9DYW1lbFdpdGhNZXRhZGF0YSB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwtd2l0aC1tZXRhZGF0YS5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YXQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcInN0YXRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGF0IChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvc3RhdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIGRhdGEuV2l0aExvY2FsaXR5ID0gZGF0YS5XaXRoTG9jYWxpdHkgfHwgZmFsc2VcbiAgICByZXR1cm4gdG9Db3JlSW50ZXJmYWNlKG9iamVjdFRvQ2FtZWxXaXRoTWV0YWRhdGEoZGF0YSkpXG4gIH1cbiAgcmV0dXJuIHN0YXRcbn0pXG5cbi8qKlxuICogQHBhcmFtIHsqfSBlbnRyeVxuICovXG5mdW5jdGlvbiB0b0NvcmVJbnRlcmZhY2UgKGVudHJ5KSB7XG4gIGVudHJ5LmNpZCA9IENJRC5wYXJzZShlbnRyeS5oYXNoKVxuICBkZWxldGUgZW50cnkuaGFzaFxuICByZXR1cm4gZW50cnlcbn1cbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvZmlsZXMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEZpbGVzQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRvdWNoID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RmlsZXNBUElbXCJ0b3VjaFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHRvdWNoIChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvdG91Y2gnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogcGF0aCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgYXdhaXQgcmVzLnRleHQoKVxuICB9XG4gIHJldHVybiB0b3VjaFxufSlcbiIsImltcG9ydCB7IG1vZGVUb1N0cmluZyB9IGZyb20gJy4uL2xpYi9tb2RlLXRvLXN0cmluZy5qcydcbmltcG9ydCB7IHBhcnNlTXRpbWUgfSBmcm9tICcuLi9saWIvcGFyc2UtbXRpbWUuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCdcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuaW1wb3J0IHsgYWJvcnRTaWduYWwgfSBmcm9tICcuLi9saWIvYWJvcnQtc2lnbmFsLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9maWxlcycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gRmlsZXNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlV3JpdGUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaWxlc0FQSVtcIndyaXRlXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gd3JpdGUgKHBhdGgsIGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBhbGxvdyBhYm9ydGluZyByZXF1ZXN0cyBvbiBib2R5IGVycm9yc1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvd3JpdGUnLCB7XG4gICAgICBzaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICBzdHJlYW1DaGFubmVsczogdHJ1ZSxcbiAgICAgICAgY291bnQ6IG9wdGlvbnMubGVuZ3RoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIC4uLihcbiAgICAgICAgYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdChbe1xuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgICAgIHBhdGg6ICdhcmcnLFxuICAgICAgICAgIG1vZGU6IG1vZGVUb1N0cmluZyhvcHRpb25zLm1vZGUpLFxuICAgICAgICAgIG10aW1lOiBwYXJzZU10aW1lKG9wdGlvbnMubXRpbWUpXG4gICAgICAgIH1dLCBjb250cm9sbGVyLCBvcHRpb25zLmhlYWRlcnMpXG4gICAgICApXG4gICAgfSlcblxuICAgIGF3YWl0IHJlcy50ZXh0KClcbiAgfVxuICByZXR1cm4gd3JpdGVcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVHZXRFbmRwb2ludENvbmZpZyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXBpLm9wdHMuYmFzZSB8fCAnJylcbiAgICByZXR1cm4ge1xuICAgICAgaG9zdDogdXJsLmhvc3RuYW1lLFxuICAgICAgcG9ydDogdXJsLnBvcnQsXG4gICAgICBwcm90b2NvbDogdXJsLnByb3RvY29sLFxuICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICdhcGktcGF0aCc6IHVybC5wYXRobmFtZVxuICAgIH1cbiAgfVxufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3Jvb3QnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJvb3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlR2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Um9vdEFQSVtcImdldFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogZ2V0IChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGFyZzogYCR7cGF0aCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBDSUQuZGVjb2RlKHBhdGgpIDogcGF0aH1gLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH1cblxuICAgIGlmIChvcHRzLmNvbXByZXNzaW9uTGV2ZWwpIHtcbiAgICAgIG9wdHNbJ2NvbXByZXNzaW9uLWxldmVsJ10gPSBvcHRzLmNvbXByZXNzaW9uTGV2ZWxcbiAgICAgIGRlbGV0ZSBvcHRzLmNvbXByZXNzaW9uTGV2ZWxcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZ2V0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0cyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgeWllbGQgKiByZXMuaXRlcmF0b3IoKVxuICB9XG5cbiAgcmV0dXJuIGdldFxufSlcbiIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBtdWx0aWFkZHIgfSBmcm9tICdAbXVsdGlmb3JtYXRzL211bHRpYWRkcidcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBwZWVySWRGcm9tU3RyaW5nIH0gZnJvbSAnQGxpYnAycC9wZWVyLWlkJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3Jvb3QnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJvb3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSWQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSb290QVBJW1wiaWRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBpZCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2lkJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IG9wdGlvbnMucGVlcklkID8gb3B0aW9ucy5wZWVySWQudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAuLi5vYmplY3RUb0NhbWVsKGRhdGEpXG4gICAgfVxuXG4gICAgb3V0cHV0LmlkID0gcGVlcklkRnJvbVN0cmluZyhvdXRwdXQuaWQpXG5cbiAgICBpZiAob3V0cHV0LmFkZHJlc3Nlcykge1xuICAgICAgb3V0cHV0LmFkZHJlc3NlcyA9IG91dHB1dC5hZGRyZXNzZXMubWFwKCgvKiogQHR5cGUge3N0cmluZ30gKi8gbWEpID0+IG11bHRpYWRkcihtYSkpXG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXJ2ZXIgb3V0cHV0IGlzIG5vdCB0eXBlZFxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuICByZXR1cm4gaWRcbn0pXG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuaW1wb3J0IHsgTXVsdGliYXNlcyB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aWJhc2VzJ1xuaW1wb3J0IHsgTXVsdGljb2RlY3MgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGljb2RlY3MnXG5pbXBvcnQgeyBNdWx0aWhhc2hlcyB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aWhhc2hlcydcbmltcG9ydCAqIGFzIGRhZ1BCIGZyb20gJ0BpcGxkL2RhZy1wYidcbmltcG9ydCAqIGFzIGRhZ0NCT1IgZnJvbSAnQGlwbGQvZGFnLWNib3InXG5pbXBvcnQgKiBhcyBkYWdKU09OIGZyb20gJ0BpcGxkL2RhZy1qc29uJ1xuaW1wb3J0ICogYXMgZGFnSk9TRSBmcm9tICdkYWctam9zZSdcbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9pZGVudGl0eSdcbmltcG9ydCB7IGJhc2VzLCBoYXNoZXMsIGNvZGVjcyB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNpY3MnXG5pbXBvcnQgeyBjcmVhdGVCaXRzd2FwIH0gZnJvbSAnLi9iaXRzd2FwL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlQmxvY2sgfSBmcm9tICcuL2Jsb2NrL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlQm9vdHN0cmFwIH0gZnJvbSAnLi9ib290c3RyYXAvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVDb25maWcgfSBmcm9tICcuL2NvbmZpZy9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZURhZyB9IGZyb20gJy4vZGFnL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRGh0IH0gZnJvbSAnLi9kaHQvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVEaWFnIH0gZnJvbSAnLi9kaWFnL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRmlsZXMgfSBmcm9tICcuL2ZpbGVzL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlS2V5IH0gZnJvbSAnLi9rZXkvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVMb2cgfSBmcm9tICcuL2xvZy9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZU5hbWUgfSBmcm9tICcuL25hbWUvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVPYmplY3QgfSBmcm9tICcuL29iamVjdC9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZVBpbiB9IGZyb20gJy4vcGluL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUHVic3ViIH0gZnJvbSAnLi9wdWJzdWIvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVSZWZzIH0gZnJvbSAnLi9yZWZzL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUmVwbyB9IGZyb20gJy4vcmVwby9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZVN0YXRzIH0gZnJvbSAnLi9zdGF0cy9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZVN3YXJtIH0gZnJvbSAnLi9zd2FybS9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZUFkZCB9IGZyb20gJy4vYWRkLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQWRkQWxsIH0gZnJvbSAnLi9hZGQtYWxsLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2F0IH0gZnJvbSAnLi9jYXQuanMnXG5pbXBvcnQgeyBjcmVhdGVDb21tYW5kcyB9IGZyb20gJy4vY29tbWFuZHMuanMnXG5pbXBvcnQgeyBjcmVhdGVEbnMgfSBmcm9tICcuL2Rucy5qcydcbmltcG9ydCB7IGNyZWF0ZUdldEVuZHBvaW50Q29uZmlnIH0gZnJvbSAnLi9nZXQtZW5kcG9pbnQtY29uZmlnLmpzJ1xuaW1wb3J0IHsgY3JlYXRlR2V0IH0gZnJvbSAnLi9nZXQuanMnXG5pbXBvcnQgeyBjcmVhdGVJZCB9IGZyb20gJy4vaWQuanMnXG5pbXBvcnQgeyBjcmVhdGVJc09ubGluZSB9IGZyb20gJy4vaXMtb25saW5lLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTHMgfSBmcm9tICcuL2xzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTW91bnQgfSBmcm9tICcuL21vdW50LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUGluZyB9IGZyb20gJy4vcGluZy5qcydcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmUgfSBmcm9tICcuL3Jlc29sdmUuanMnXG5pbXBvcnQgeyBjcmVhdGVTdGFydCB9IGZyb20gJy4vc3RhcnQuanMnXG5pbXBvcnQgeyBjcmVhdGVTdG9wIH0gZnJvbSAnLi9zdG9wLmpzJ1xuaW1wb3J0IHsgY3JlYXRlVmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcydcbmltcG9ydCBnbG9iU291cmNlSW1wb3J0IGZyb20gJ2lwZnMtdXRpbHMvc3JjL2ZpbGVzL2dsb2Itc291cmNlLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ211bHRpZm9ybWF0cy9jb2RlY3MvaW50ZXJmYWNlJykuQmxvY2tDb2RlYzxhbnksIGFueT59IEJsb2NrQ29kZWNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ211bHRpZm9ybWF0cy9oYXNoZXMvaW50ZXJmYWNlJykuTXVsdGloYXNoSGFzaGVyfSBNdWx0aWhhc2hIYXNoZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ211bHRpZm9ybWF0cy9iYXNlcy9pbnRlcmZhY2UnKS5NdWx0aWJhc2VDb2RlYzxhbnk+fSBNdWx0aWJhc2VDb2RlY1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLk9wdGlvbnN9IE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5Mb2FkQmFzZUZufSBMb2FkQmFzZUZuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuTG9hZENvZGVjRm59IExvYWRDb2RlY0ZuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuTG9hZEhhc2hlckZufSBMb2FkSGFzaGVyRm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5JUExET3B0aW9uc30gSVBMRE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuRW5kcG9pbnRDb25maWd9IEVuZHBvaW50Q29uZmlnXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuSVBGU0hUVFBDbGllbnR9IElQRlNIVFRQQ2xpZW50XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSAob3B0aW9ucyA9IHt9KSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QmxvY2tDb2RlY31cbiAgICovXG4gIGNvbnN0IGlkID0ge1xuICAgIG5hbWU6IGlkZW50aXR5Lm5hbWUsXG4gICAgY29kZTogaWRlbnRpdHkuY29kZSxcbiAgICBlbmNvZGU6IChpZCkgPT4gaWQsXG4gICAgZGVjb2RlOiAoaWQpID0+IGlkXG4gIH1cblxuICAvKiogQHR5cGUge011bHRpYmFzZUNvZGVjW119ICovXG4gIGNvbnN0IG11bHRpYmFzZUNvZGVjcyA9IE9iamVjdC52YWx1ZXMoYmFzZXMpO1xuXG4gIChvcHRpb25zLmlwbGQgJiYgb3B0aW9ucy5pcGxkLmJhc2VzID8gb3B0aW9ucy5pcGxkLmJhc2VzIDogW10pLmZvckVhY2goYmFzZSA9PiBtdWx0aWJhc2VDb2RlY3MucHVzaChiYXNlKSlcblxuICBjb25zdCBtdWx0aWJhc2VzID0gbmV3IE11bHRpYmFzZXMoe1xuICAgIGJhc2VzOiBtdWx0aWJhc2VDb2RlY3MsXG4gICAgbG9hZEJhc2U6IG9wdGlvbnMuaXBsZCAmJiBvcHRpb25zLmlwbGQubG9hZEJhc2VcbiAgfSlcblxuICAvKiogQHR5cGUge0Jsb2NrQ29kZWNbXX0gKi9cbiAgY29uc3QgYmxvY2tDb2RlY3MgPSBPYmplY3QudmFsdWVzKGNvZGVjcyk7XG5cbiAgW2RhZ1BCLCBkYWdDQk9SLCBkYWdKU09OLCBkYWdKT1NFLCBpZF0uY29uY2F0KChvcHRpb25zLmlwbGQgJiYgb3B0aW9ucy5pcGxkLmNvZGVjcykgfHwgW10pLmZvckVhY2goY29kZWMgPT4gYmxvY2tDb2RlY3MucHVzaChjb2RlYykpXG5cbiAgY29uc3QgbXVsdGljb2RlY3MgPSBuZXcgTXVsdGljb2RlY3Moe1xuICAgIGNvZGVjczogYmxvY2tDb2RlY3MsXG4gICAgbG9hZENvZGVjOiBvcHRpb25zLmlwbGQgJiYgb3B0aW9ucy5pcGxkLmxvYWRDb2RlY1xuICB9KVxuXG4gIC8qKiBAdHlwZSB7TXVsdGloYXNoSGFzaGVyW119ICovXG4gIGNvbnN0IG11bHRpaGFzaEhhc2hlcnMgPSBPYmplY3QudmFsdWVzKGhhc2hlcyk7XG5cbiAgKG9wdGlvbnMuaXBsZCAmJiBvcHRpb25zLmlwbGQuaGFzaGVycyA/IG9wdGlvbnMuaXBsZC5oYXNoZXJzIDogW10pLmZvckVhY2goaGFzaGVyID0+IG11bHRpaGFzaEhhc2hlcnMucHVzaChoYXNoZXIpKVxuXG4gIGNvbnN0IG11bHRpaGFzaGVzID0gbmV3IE11bHRpaGFzaGVzKHtcbiAgICBoYXNoZXJzOiBtdWx0aWhhc2hIYXNoZXJzLFxuICAgIGxvYWRIYXNoZXI6IG9wdGlvbnMuaXBsZCAmJiBvcHRpb25zLmlwbGQubG9hZEhhc2hlclxuICB9KVxuXG4gIC8qKiBAdHlwZSB7SVBGU0hUVFBDbGllbnR9ICovXG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBhZGQ6IGNyZWF0ZUFkZChvcHRpb25zKSxcbiAgICBhZGRBbGw6IGNyZWF0ZUFkZEFsbChvcHRpb25zKSxcbiAgICBiaXRzd2FwOiBjcmVhdGVCaXRzd2FwKG9wdGlvbnMpLFxuICAgIGJsb2NrOiBjcmVhdGVCbG9jayhvcHRpb25zKSxcbiAgICBib290c3RyYXA6IGNyZWF0ZUJvb3RzdHJhcChvcHRpb25zKSxcbiAgICBjYXQ6IGNyZWF0ZUNhdChvcHRpb25zKSxcbiAgICBjb21tYW5kczogY3JlYXRlQ29tbWFuZHMob3B0aW9ucyksXG4gICAgY29uZmlnOiBjcmVhdGVDb25maWcob3B0aW9ucyksXG4gICAgZGFnOiBjcmVhdGVEYWcobXVsdGljb2RlY3MsIG9wdGlvbnMpLFxuICAgIGRodDogY3JlYXRlRGh0KG9wdGlvbnMpLFxuICAgIGRpYWc6IGNyZWF0ZURpYWcob3B0aW9ucyksXG4gICAgZG5zOiBjcmVhdGVEbnMob3B0aW9ucyksXG4gICAgZmlsZXM6IGNyZWF0ZUZpbGVzKG9wdGlvbnMpLFxuICAgIGdldDogY3JlYXRlR2V0KG9wdGlvbnMpLFxuICAgIGdldEVuZHBvaW50Q29uZmlnOiBjcmVhdGVHZXRFbmRwb2ludENvbmZpZyhvcHRpb25zKSxcbiAgICBpZDogY3JlYXRlSWQob3B0aW9ucyksXG4gICAgaXNPbmxpbmU6IGNyZWF0ZUlzT25saW5lKG9wdGlvbnMpLFxuICAgIGtleTogY3JlYXRlS2V5KG9wdGlvbnMpLFxuICAgIGxvZzogY3JlYXRlTG9nKG9wdGlvbnMpLFxuICAgIGxzOiBjcmVhdGVMcyhvcHRpb25zKSxcbiAgICBtb3VudDogY3JlYXRlTW91bnQob3B0aW9ucyksXG4gICAgbmFtZTogY3JlYXRlTmFtZShvcHRpb25zKSxcbiAgICBvYmplY3Q6IGNyZWF0ZU9iamVjdChtdWx0aWNvZGVjcywgb3B0aW9ucyksXG4gICAgcGluOiBjcmVhdGVQaW4ob3B0aW9ucyksXG4gICAgcGluZzogY3JlYXRlUGluZyhvcHRpb25zKSxcbiAgICBwdWJzdWI6IGNyZWF0ZVB1YnN1YihvcHRpb25zKSxcbiAgICByZWZzOiBjcmVhdGVSZWZzKG9wdGlvbnMpLFxuICAgIHJlcG86IGNyZWF0ZVJlcG8ob3B0aW9ucyksXG4gICAgcmVzb2x2ZTogY3JlYXRlUmVzb2x2ZShvcHRpb25zKSxcbiAgICBzdGFydDogY3JlYXRlU3RhcnQob3B0aW9ucyksXG4gICAgc3RhdHM6IGNyZWF0ZVN0YXRzKG9wdGlvbnMpLFxuICAgIHN0b3A6IGNyZWF0ZVN0b3Aob3B0aW9ucyksXG4gICAgc3dhcm06IGNyZWF0ZVN3YXJtKG9wdGlvbnMpLFxuICAgIHZlcnNpb246IGNyZWF0ZVZlcnNpb24ob3B0aW9ucyksXG4gICAgYmFzZXM6IG11bHRpYmFzZXMsXG4gICAgY29kZWNzOiBtdWx0aWNvZGVjcyxcbiAgICBoYXNoZXJzOiBtdWx0aWhhc2hlc1xuICB9XG5cbiAgcmV0dXJuIGNsaWVudFxufVxuXG5leHBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuZXhwb3J0IHsgbXVsdGlhZGRyIH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHInXG5leHBvcnQgeyBkZWZhdWx0IGFzIHVybFNvdXJjZSB9IGZyb20gJ2lwZnMtdXRpbHMvc3JjL2ZpbGVzL3VybC1zb3VyY2UuanMnXG5leHBvcnQgY29uc3QgZ2xvYlNvdXJjZSA9IGdsb2JTb3VyY2VJbXBvcnRcbiIsImltcG9ydCB7IGNyZWF0ZUlkIH0gZnJvbSAnLi9pZC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yb290JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBSb290QVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcycpLk9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUlzT25saW5lID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGlkID0gY3JlYXRlSWQob3B0aW9ucylcblxuICAvKipcbiAgICogQHR5cGUge1Jvb3RBUElbXCJpc09ubGluZVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGlzT25saW5lIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBpZChvcHRpb25zKVxuXG4gICAgcmV0dXJuIEJvb2xlYW4ocmVzICYmIHJlcy5hZGRyZXNzZXMgJiYgcmVzLmFkZHJlc3Nlcy5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGlzT25saW5lXG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2tleScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gS2V5QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUV4cG9ydCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0tleUFQSVtcImV4cG9ydFwiXX1cbiAgICovXG4gIGNvbnN0IGV4cG9ydEtleSA9IGFzeW5jIChuYW1lLCBwYXNzd29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpLCAnRVJSX05PVF9JTVBMRU1FTlRFRCcpXG4gIH1cblxuICByZXR1cm4gZXhwb3J0S2V5XG59KVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2tleScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gS2V5QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdlbiA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0tleUFQSVtcImdlblwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGdlbiAobmFtZSwgb3B0aW9ucyA9IHsgdHlwZTogJ0VkMjU1MTknIH0pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgna2V5L2dlbicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBuYW1lLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2VydmVyIG91dHB1dCBpcyBub3QgdHlwZWRcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChkYXRhKVxuICB9XG4gIHJldHVybiBnZW5cbn0pXG4iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMva2V5JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBLZXlBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW1wb3J0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7S2V5QVBJW1wiaW1wb3J0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5IChuYW1lLCBwZW0sIHBhc3N3b3JkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgna2V5L2ltcG9ydCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBuYW1lLFxuICAgICAgICBwZW0sXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2VydmVyIG91dHB1dCBpcyBub3QgdHlwZWRcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChkYXRhKVxuICB9XG4gIHJldHVybiBpbXBvcnRLZXlcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVFeHBvcnQgfSBmcm9tICcuL2V4cG9ydC5qcydcbmltcG9ydCB7IGNyZWF0ZUdlbiB9IGZyb20gJy4vZ2VuLmpzJ1xuaW1wb3J0IHsgY3JlYXRlSW1wb3J0IH0gZnJvbSAnLi9pbXBvcnQuanMnXG5pbXBvcnQgeyBjcmVhdGVJbmZvIH0gZnJvbSAnLi9pbmZvLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTGlzdCB9IGZyb20gJy4vbGlzdC5qcydcbmltcG9ydCB7IGNyZWF0ZVJlbmFtZSB9IGZyb20gJy4vcmVuYW1lLmpzJ1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlS2V5IChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBvcnQ6IGNyZWF0ZUV4cG9ydChjb25maWcpLFxuICAgIGdlbjogY3JlYXRlR2VuKGNvbmZpZyksXG4gICAgaW1wb3J0OiBjcmVhdGVJbXBvcnQoY29uZmlnKSxcbiAgICBpbmZvOiBjcmVhdGVJbmZvKGNvbmZpZyksXG4gICAgbGlzdDogY3JlYXRlTGlzdChjb25maWcpLFxuICAgIHJlbmFtZTogY3JlYXRlUmVuYW1lKGNvbmZpZyksXG4gICAgcm06IGNyZWF0ZVJtKGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9rZXknKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEtleUFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbmZvID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7S2V5QVBJW1wiaW5mb1wiXX1cbiAgICovXG4gIGNvbnN0IGluZm8gPSBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpLCAnRVJSX05PVF9JTVBMRU1FTlRFRCcpXG4gIH1cblxuICByZXR1cm4gaW5mb1xufSlcbiIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9rZXknKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IEtleUFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7S2V5QVBJW1wibGlzdFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3QgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdrZXkvbGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIChkYXRhLktleXMgfHwgW10pLm1hcCgoLyoqIEB0eXBlIHthbnl9ICoqLyBrKSA9PiBvYmplY3RUb0NhbWVsKGspKVxuICB9XG4gIHJldHVybiBsaXN0XG59KVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2tleScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gS2V5QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbmFtZSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0tleUFQSVtcInJlbmFtZVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHJlbmFtZSAob2xkTmFtZSwgbmV3TmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2tleS9yZW5hbWUnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogW1xuICAgICAgICAgIG9sZE5hbWUsXG4gICAgICAgICAgbmV3TmFtZVxuICAgICAgICBdLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHNlcnZlciBvdXRwdXQgaXMgbm90IHR5cGVkXG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSlcbiAgfVxuICByZXR1cm4gcmVuYW1lXG59KVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2tleScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gS2V5QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJtID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7S2V5QVBJW1wicm1cIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBybSAobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2tleS9ybScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBuYW1lLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2VydmVyIG91dHB1dCBpcyBub3QgdHlwZWRcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChkYXRhLktleXNbMF0pXG4gIH1cbiAgcmV0dXJuIHJtXG59KVxuIiwiaW1wb3J0IHsgYW55U2lnbmFsIH0gZnJvbSAnYW55LXNpZ25hbCdcblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBzaWduYWxzXG4gKiBAcmV0dXJucyB7QWJvcnRTaWduYWxbXX1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyIChzaWduYWxzKSB7XG4gIHJldHVybiBzaWduYWxzLmZpbHRlcihCb29sZWFuKVxufVxuXG4vKipcbiAqIEBwYXJhbSAgey4uLkFib3J0U2lnbmFsfHVuZGVmaW5lZH0gc2lnbmFsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRTaWduYWwgKC4uLnNpZ25hbHMpIHtcbiAgcmV0dXJuIGFueVNpZ25hbChmaWx0ZXIoc2lnbmFscykpXG59XG4iLCJcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICcuL2NvcmUuanMnXG5cbi8vIFNldCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYW5kIGNhbGwgY3JlYXRlIGZ1bmN0aW9uIHdpdGggdGhlbVxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcIi4uL3R5cGVzXCIpLk9wdGlvbnMgfSBPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYgeyhjbGllbnQ6IENsaWVudCwgY2xpZW50T3B0aW9uczogT3B0aW9ucykgPT4gVH0gRm5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7KGNsaWVudE9wdGlvbnM6IE9wdGlvbnMpID0+IFR9IEZhY3RvcnlcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0ZuPFQ+fSBmblxuICogQHJldHVybnMge0ZhY3Rvcnk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBjb25maWd1cmUgPSAoZm4pID0+IHtcbiAgcmV0dXJuIChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGZuKG5ldyBDbGllbnQob3B0aW9ucyksIG9wdGlvbnMpXG4gIH1cbn1cbiIsIlxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmltcG9ydCB7IGlzTXVsdGlhZGRyIH0gZnJvbSAnQG11bHRpZm9ybWF0cy9tdWx0aWFkZHInXG5pbXBvcnQgeyBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyLCBpc05vZGUgfSBmcm9tICdpcGZzLXV0aWxzL3NyYy9lbnYuanMnXG5pbXBvcnQgcGFyc2VEdXJhdGlvbiBmcm9tICdwYXJzZS1kdXJhdGlvbidcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0BsaWJwMnAvbG9nZ2VyJ1xuaW1wb3J0IEhUVFAgZnJvbSAnaXBmcy11dGlscy9zcmMvaHR0cC5qcydcbmltcG9ydCBtZXJnZU9wdHMgZnJvbSAnbWVyZ2Utb3B0aW9ucydcbmltcG9ydCB7IHRvVXJsU3RyaW5nIH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL3RvLXVybC1zdHJpbmcnXG5pbXBvcnQgZ2V0QWdlbnQgZnJvbSAnaXBmcy1jb3JlLXV0aWxzL2FnZW50J1xuXG5jb25zdCBsb2cgPSBsb2dnZXIoJ2lwZnMtaHR0cC1jbGllbnQ6bGliOmVycm9yLWhhbmRsZXInKVxuY29uc3QgbWVyZ2UgPSBtZXJnZU9wdHMuYmluZCh7IGlnbm9yZVVuZGVmaW5lZDogdHJ1ZSB9KVxuXG5jb25zdCBERUZBVUxUX1BST1RPQ09MID0gaXNCcm93c2VyIHx8IGlzV2ViV29ya2VyID8gbG9jYXRpb24ucHJvdG9jb2wgOiAnaHR0cCdcbmNvbnN0IERFRkFVTFRfSE9TVCA9IGlzQnJvd3NlciB8fCBpc1dlYldvcmtlciA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCdcbmNvbnN0IERFRkFVTFRfUE9SVCA9IGlzQnJvd3NlciB8fCBpc1dlYldvcmtlciA/IGxvY2F0aW9uLnBvcnQgOiAnNTAwMSdcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLXV0aWxzL3NyYy90eXBlcycpLkhUVFBPcHRpb25zfSBIVFRQT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAbXVsdGlmb3JtYXRzL211bHRpYWRkcicpLk11bHRpYWRkcn0gTXVsdGlhZGRyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN8VVJMfE11bHRpYWRkcnxzdHJpbmd9IFtvcHRpb25zXVxuICogQHJldHVybnMge09wdGlvbnN9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZU9wdGlvbnMgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB1cmxcbiAgLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xuICBsZXQgb3B0cyA9IHt9XG4gIGxldCBhZ2VudFxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgaXNNdWx0aWFkZHIob3B0aW9ucykpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHRvVXJsU3RyaW5nKG9wdGlvbnMpKVxuICB9IGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICB1cmwgPSBvcHRpb25zXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMudXJsID09PSAnc3RyaW5nJyB8fCBpc011bHRpYWRkcihvcHRpb25zLnVybCkpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHRvVXJsU3RyaW5nKG9wdGlvbnMudXJsKSlcbiAgICBvcHRzID0gb3B0aW9uc1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudXJsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgdXJsID0gb3B0aW9ucy51cmxcbiAgICBvcHRzID0gb3B0aW9uc1xuICB9IGVsc2Uge1xuICAgIG9wdHMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IChvcHRzLnByb3RvY29sIHx8IERFRkFVTFRfUFJPVE9DT0wpLnJlcGxhY2UoJzonLCAnJylcbiAgICBjb25zdCBob3N0ID0gKG9wdHMuaG9zdCB8fCBERUZBVUxUX0hPU1QpLnNwbGl0KCc6JylbMF1cbiAgICBjb25zdCBwb3J0ID0gKG9wdHMucG9ydCB8fCBERUZBVUxUX1BPUlQpXG5cbiAgICB1cmwgPSBuZXcgVVJMKGAke3Byb3RvY29sfTovLyR7aG9zdH06JHtwb3J0fWApXG4gIH1cblxuICBpZiAob3B0cy5hcGlQYXRoKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gb3B0cy5hcGlQYXRoXG4gIH0gZWxzZSBpZiAodXJsLnBhdGhuYW1lID09PSAnLycgfHwgdXJsLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnYXBpL3YwJ1xuICB9XG5cbiAgaWYgKGlzTm9kZSkge1xuICAgIGNvbnN0IEFnZW50ID0gZ2V0QWdlbnQodXJsKVxuXG4gICAgYWdlbnQgPSBvcHRzLmFnZW50IHx8IG5ldyBBZ2VudCh7XG4gICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAvLyBTaW1pbGFyIHRvIGJyb3dzZXJzIHdoaWNoIGxpbWl0IGNvbm5lY3Rpb25zIHRvIHNpeCBwZXIgaG9zdFxuICAgICAgbWF4U29ja2V0czogNlxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLm9wdHMsXG4gICAgaG9zdDogdXJsLmhvc3QsXG4gICAgcHJvdG9jb2w6IHVybC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpLFxuICAgIHBvcnQ6IE51bWJlcih1cmwucG9ydCksXG4gICAgYXBpUGF0aDogdXJsLnBhdGhuYW1lLFxuICAgIHVybCxcbiAgICBhZ2VudFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGVycm9ySGFuZGxlciA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICBsZXQgbXNnXG5cbiAgdHJ5IHtcbiAgICBpZiAoKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSB8fCAnJykuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBsb2coZGF0YSlcbiAgICAgIG1zZyA9IGRhdGEuTWVzc2FnZSB8fCBkYXRhLm1lc3NhZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgfVxuICB9IGNhdGNoICgvKiogQHR5cGUge2FueX0gKi8gZXJyKSB7XG4gICAgbG9nKCdGYWlsZWQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UnLCBlcnIpXG4gICAgLy8gRmFpbGVkIHRvIGV4dHJhY3QvcGFyc2UgZXJyb3IgbWVzc2FnZSBmcm9tIHJlc3BvbnNlXG4gICAgbXNnID0gZXJyLm1lc3NhZ2VcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RXJyb3J9ICovXG4gIGxldCBlcnJvciA9IG5ldyBIVFRQLkhUVFBFcnJvcihyZXNwb25zZSlcblxuICBpZiAobXNnKSB7XG4gICAgLy8gVGhpcyBpcyB3aGF0IHJzLWlwZnMgcmV0dXJucyB3aGVyZSB0aGVyZSdzIGEgdGltZW91dFxuICAgIGlmIChtc2cuaW5jbHVkZXMoJ2RlYWRsaW5lIGhhcyBlbGFwc2VkJykpIHtcbiAgICAgIGVycm9yID0gbmV3IEhUVFAuVGltZW91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHdoYXQgZ28taXBmcyByZXR1cm5zIHdoZXJlIHRoZXJlJ3MgYSB0aW1lb3V0XG4gICAgaWYgKG1zZyAmJiBtc2cuaW5jbHVkZXMoJ2NvbnRleHQgZGVhZGxpbmUgZXhjZWVkZWQnKSkge1xuICAgICAgZXJyb3IgPSBuZXcgSFRUUC5UaW1lb3V0RXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgYWxzbyBnZXRzIHJldHVybmVkXG4gIGlmIChtc2cgJiYgbXNnLmluY2x1ZGVzKCdyZXF1ZXN0IHRpbWVkIG91dCcpKSB7XG4gICAgZXJyb3IgPSBuZXcgSFRUUC5UaW1lb3V0RXJyb3IoKVxuICB9XG5cbiAgLy8gSWYgd2UgbWFuYWdlZCB0byBleHRyYWN0IGEgbWVzc2FnZSBmcm9tIHRoZSByZXNwb25zZSwgdXNlIGl0XG4gIGlmIChtc2cpIHtcbiAgICBlcnJvci5tZXNzYWdlID0gbXNnXG4gIH1cblxuICB0aHJvdyBlcnJvclxufVxuXG5jb25zdCBLRUJBQl9SRUdFWCA9IC9bQS1aXFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMERFXS9nXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5jb25zdCBrZWJhYkNhc2UgPSAoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShLRUJBQl9SRUdFWCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gdmFsdWVcbiAqL1xuY29uc3QgcGFyc2VUaW1lb3V0ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VEdXJhdGlvbih2YWx1ZSkgOiB2YWx1ZVxufVxuXG5leHBvcnQgY2xhc3MgQ2xpZW50IGV4dGVuZHMgSFRUUCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN8VVJMfE11bHRpYWRkcnxzdHJpbmd9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBzdXBlcih7XG4gICAgICB0aW1lb3V0OiBwYXJzZVRpbWVvdXQob3B0cy50aW1lb3V0IHx8IDApIHx8IHVuZGVmaW5lZCxcbiAgICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbiAgICAgIGJhc2U6IGAke29wdHMudXJsfWAsXG4gICAgICBoYW5kbGVFcnJvcjogZXJyb3JIYW5kbGVyLFxuICAgICAgdHJhbnNmb3JtU2VhcmNoUGFyYW1zOiAoc2VhcmNoKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdmFsdWUgIT09ICdudWxsJyAmJlxuICAgICAgICAgICAga2V5ICE9PSAnc2lnbmFsJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgb3V0LmFwcGVuZChrZWJhYkNhc2Uoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXJ2ZXIgdGltZW91dHMgYXJlIHN0cmluZ3NcbiAgICAgICAgICBpZiAoa2V5ID09PSAndGltZW91dCcgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgb3V0LmFwcGVuZChrZWJhYkNhc2Uoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dFxuICAgICAgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBjYW4gYmUgYSBodHRwcyBhZ2VudCBvciBhIGh0dHAgYWdlbnRcbiAgICAgIGFnZW50OiBvcHRzLmFnZW50XG4gICAgfSlcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBjYW5ub3QgZGVsZXRlIG5vLW9wdGlvbmFsIGZpZWxkc1xuICAgIGRlbGV0ZSB0aGlzLmdldFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBjYW5ub3QgZGVsZXRlIG5vLW9wdGlvbmFsIGZpZWxkc1xuICAgIGRlbGV0ZSB0aGlzLnB1dFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBjYW5ub3QgZGVsZXRlIG5vLW9wdGlvbmFsIGZpZWxkc1xuICAgIGRlbGV0ZSB0aGlzLmRlbGV0ZVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBjYW5ub3QgZGVsZXRlIG5vLW9wdGlvbmFsIGZpZWxkc1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnNcblxuICAgIGNvbnN0IGZldGNoID0gdGhpcy5mZXRjaFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBSZXF1ZXN0fSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSB7SFRUUE9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmZldGNoID0gKHJlc291cmNlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnICYmICFyZXNvdXJjZS5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmVzb3VyY2UgPSBgJHtvcHRzLnVybH0vJHtyZXNvdXJjZX1gXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZXRjaC5jYWxsKHRoaXMsIHJlc291cmNlLCBtZXJnZShvcHRpb25zLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICB9KSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEhUVFBFcnJvciA9IEhUVFAuSFRUUEVycm9yXG4iLCJpbXBvcnQgeyBmcm9tU3RyaW5nIGFzIHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvZnJvbS1zdHJpbmcnXG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnXG5pbXBvcnQgeyBiYXNlNjR1cmwgfSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzZXMvYmFzZTY0J1xuXG4vKiBIVFRQIFJQQzpcbiAqIC0gd3JhcHMgYmluYXJ5IGRhdGEgaW4gbXVsdGliYXNlLiBiYXNlNjR1cmwgaXMgdXNlZCB0byBhdm9pZCBpc3N1ZXNcbiAqICAgd2hlbiBhIGJpbmFyeSBkYXRhIGlzIHBhc3NlZCBhcyBzZWFyY2ggcGFyYW0gaW4gVVJMLlxuICogICBIaXN0b3JpY2FsIGNvbnRleHQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2dvLWlwZnMvaXNzdWVzLzc5MzlcbiAqICAgTXVsdGliYXNlIHdyYXBwaW5nIGludHJvZHVjZWQgaW46IGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2dvLWlwZnMvcHVsbC84MTgzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHN0cmluZ3NcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBzdHJpbmdzXG4gKi9cbmNvbnN0IHJwY0FycmF5VG9UZXh0QXJyYXkgPSBzdHJpbmdzID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyaW5ncykpIHtcbiAgICByZXR1cm4gc3RyaW5ncy5tYXAocnBjVG9UZXh0KVxuICB9XG4gIHJldHVybiBzdHJpbmdzXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1iXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBycGNUb1RleHQgPSBtYiA9PiB1aW50OEFycmF5VG9TdHJpbmcocnBjVG9CeXRlcyhtYikpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1iXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgcnBjVG9CeXRlcyA9IG1iID0+IGJhc2U2NHVybC5kZWNvZGUobWIpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1iXG4gKiBAcmV0dXJucyB7YmlnaW50fVxuICovXG5jb25zdCBycGNUb0JpZ0ludCA9IG1iID0+IEJpZ0ludChgMHgke3VpbnQ4QXJyYXlUb1N0cmluZyhiYXNlNjR1cmwuZGVjb2RlKG1iKSwgJ2Jhc2UxNicpfWApXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRleHRUb1VybFNhZmVScGMgPSB0ZXh0ID0+IGJhc2U2NHVybC5lbmNvZGUodWludDhBcnJheUZyb21TdHJpbmcodGV4dCkpXG5cbmV4cG9ydCB7IHJwY0FycmF5VG9UZXh0QXJyYXksIHJwY1RvVGV4dCwgcnBjVG9CeXRlcywgcnBjVG9CaWdJbnQsIHRleHRUb1VybFNhZmVScGMgfVxuIiwiXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkfSBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2RlVG9TdHJpbmcgKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbW9kZVxuICB9XG5cbiAgcmV0dXJuIG1vZGUudG9TdHJpbmcoOCkucGFkU3RhcnQoNCwgJzAnKVxufVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4vb2JqZWN0LXRvLWNhbWVsLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gZW50cnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdFRvQ2FtZWxXaXRoTWV0YWRhdGEgKGVudHJ5KSB7XG4gIGNvbnN0IGZpbGUgPSBvYmplY3RUb0NhbWVsKGVudHJ5KVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZmlsZSwgJ21vZGUnKSkge1xuICAgIGZpbGUubW9kZSA9IHBhcnNlSW50KGZpbGUubW9kZSwgOClcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZmlsZSwgJ210aW1lJykpIHtcbiAgICBmaWxlLm10aW1lID0ge1xuICAgICAgc2VjczogZmlsZS5tdGltZSxcbiAgICAgIG5zZWNzOiBmaWxlLm10aW1lTnNlY3MgfHwgMFxuICAgIH1cblxuICAgIGRlbGV0ZSBmaWxlLm10aW1lTnNlY3NcbiAgfVxuXG4gIHJldHVybiBmaWxlXG59XG4iLCJcbi8qKlxuICogQ29udmVydCBvYmplY3QgcHJvcGVydGllcyB0byBjYW1lbCBjYXNlLlxuICogTk9UIHJlY3Vyc2l2ZSFcbiAqIGUuZy5cbiAqIEFnZW50VmVyc2lvbiA9PiBhZ2VudFZlcnNpb25cbiAqIElEID0+IGlkXG4gKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdFRvQ2FtZWwgKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBjb25zdCBjYXBzID0gL15bQS1aXSskL1xuXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3Qgb3V0cHV0ID0ge31cblxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKGNhbWVsT2JqLCBrKSA9PiB7XG4gICAgaWYgKGNhcHMudGVzdChrKSkgeyAvLyBhbGwgY2Fwc1xuICAgICAgY2FtZWxPYmpbay50b0xvd2VyQ2FzZSgpXSA9IG9ialtrXVxuICAgIH0gZWxzZSBpZiAoY2Fwcy50ZXN0KGtbMF0pKSB7IC8vIHBhc2NhbFxuICAgICAgY2FtZWxPYmpba1swXS50b0xvd2VyQ2FzZSgpICsgay5zbGljZSgxKV0gPSBvYmpba11cbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZWxPYmpba10gPSBvYmpba11cbiAgICB9XG4gICAgcmV0dXJuIGNhbWVsT2JqXG4gIH0sIG91dHB1dClcbn1cbiIsImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJ1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBpbnB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNdGltZSAoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICAvKiogQHR5cGUge3sgc2VjczogbnVtYmVyLCBuc2Vjcz86IG51bWJlciB9IHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgbXRpbWVcblxuICAvLyB7IHNlY3MsIG5zZWNzIH1cbiAgaWYgKGlucHV0LnNlY3MgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuc2VjcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5uc2Vjc1xuICAgIH1cbiAgfVxuXG4gIC8vIFVuaXhGUyBUaW1lU3BlY1xuICBpZiAoaW5wdXQuU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgbXRpbWUgPSB7XG4gICAgICBzZWNzOiBpbnB1dC5TZWNvbmRzLFxuICAgICAgbnNlY3M6IGlucHV0LkZyYWN0aW9uYWxOYW5vc2Vjb25kc1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb2Nlc3MuaHJ0aW1lKClcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgbXRpbWUgPSB7XG4gICAgICBzZWNzOiBpbnB1dFswXSxcbiAgICAgIG5zZWNzOiBpbnB1dFsxXVxuICAgIH1cbiAgfVxuXG4gIC8vIEphdmFzY3JpcHQgRGF0ZVxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgY29uc3QgbXMgPSBpbnB1dC5nZXRUaW1lKClcbiAgICBjb25zdCBzZWNzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApXG5cbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IHNlY3MsXG4gICAgICBuc2VjczogKG1zIC0gKHNlY3MgKiAxMDAwKSkgKiAxMDAwXG4gICAgfVxuICB9XG5cbiAgLypcbiAgVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvYWVnaXIvaXNzdWVzLzQ4N1xuXG4gIC8vIHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIEJpZ0ludCkge1xuICAgIGNvbnN0IHNlY3MgPSBpbnB1dCAvIEJpZ0ludCgxZTkpXG4gICAgY29uc3QgbnNlY3MgPSBpbnB1dCAtIChzZWNzICogQmlnSW50KDFlOSkpXG5cbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IHBhcnNlSW50KHNlY3MudG9TdHJpbmcoKSksXG4gICAgICBuc2VjczogcGFyc2VJbnQobnNlY3MudG9TdHJpbmcoKSlcbiAgICB9XG4gIH1cbiAgKi9cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtdGltZSwgJ3NlY3MnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGlmIChtdGltZSAhPSBudWxsICYmIG10aW1lLm5zZWNzICE9IG51bGwgJiYgKG10aW1lLm5zZWNzIDwgMCB8fCBtdGltZS5uc2VjcyA+IDk5OTk5OTk5OSkpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignbXRpbWUtbnNlY3MgbXVzdCBiZSB3aXRoaW4gdGhlIHJhbmdlIFswLDk5OTk5OTk5OV0nKSwgJ0VSUl9JTlZBTElEX01USU1FX05TRUNTJylcbiAgfVxuXG4gIHJldHVybiBtdGltZVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5BYm9ydE9wdGlvbnN9IEFib3J0T3B0aW9uc1xuICovXG5cbi8qKlxuICogUmV0cmlldmVzIElQTEQgTm9kZXMgYWxvbmcgdGhlIGBwYXRoYCB0aGF0IGlzIHJvb3RlZCBhdCBgY2lkYC5cbiAqXG4gKiBAcGFyYW0ge0NJRH0gY2lkIC0gdGhlIENJRCB3aGVyZSB0aGUgcmVzb2x2aW5nIHN0YXJ0c1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCB0aGF0IHNob3VsZCBiZSByZXNvbHZlZFxuICogQHBhcmFtIHtpbXBvcnQoJ2lwZnMtY29yZS11dGlscy9tdWx0aWNvZGVjcycpLk11bHRpY29kZWNzfSBjb2RlY3NcbiAqIEBwYXJhbSB7KGNpZDogQ0lELCBvcHRpb25zPzogQWJvcnRPcHRpb25zKSA9PiBQcm9taXNlPFVpbnQ4QXJyYXk+fSBnZXRCbG9ja1xuICogQHBhcmFtIHtBYm9ydE9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gKiByZXNvbHZlIChjaWQsIHBhdGgsIGNvZGVjcywgZ2V0QmxvY2ssIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAgICovXG4gIGNvbnN0IGxvYWQgPSBhc3luYyAoY2lkKSA9PiB7XG4gICAgY29uc3QgY29kZWMgPSBhd2FpdCBjb2RlY3MuZ2V0Q29kZWMoY2lkLmNvZGUpXG4gICAgY29uc3QgYmxvY2sgPSBhd2FpdCBnZXRCbG9jayhjaWQsIG9wdGlvbnMpXG5cbiAgICByZXR1cm4gY29kZWMuZGVjb2RlKGJsb2NrKVxuICB9XG5cbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pXG4gIGxldCB2YWx1ZSA9IGF3YWl0IGxvYWQoY2lkKVxuICBsZXQgbGFzdENpZCA9IGNpZFxuXG4gIC8vIEVuZCBpdGVyYXRpb24gaWYgdGhlcmUgaXNuJ3QgYSBDSUQgdG8gZm9sbG93IGFueSBtb3JlXG4gIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpXG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIHBhdGggXCIke3BhdGh9XCJgKSwgJ0VSUl9JTlZBTElEX1BBVEgnKVxuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVba2V5XVxuXG4gICAgICB5aWVsZCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICByZW1haW5kZXJQYXRoOiBwYXJ0cy5qb2luKCcvJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYG5vIGxpbmsgbmFtZWQgXCIke2tleX1cIiB1bmRlciAke2xhc3RDaWR9YCksICdFUlJfTk9fTElOSycpXG4gICAgfVxuXG4gICAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKHZhbHVlKVxuXG4gICAgaWYgKGNpZCkge1xuICAgICAgbGFzdENpZCA9IGNpZFxuICAgICAgdmFsdWUgPSBhd2FpdCBsb2FkKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHlpZWxkIHtcbiAgICB2YWx1ZSxcbiAgICByZW1haW5kZXJQYXRoOiAnJ1xuICB9XG59XG4iLCJpbXBvcnQgeyBtb2RlVG9TdHJpbmcgfSBmcm9tICcuL21vZGUtdG8tc3RyaW5nLmpzJ1xuaW1wb3J0IHsgcGFyc2VNdGltZSB9IGZyb20gJy4uL2xpYi9wYXJzZS1tdGltZS5qcydcblxuLyoqXG4gKiBAcGFyYW0geyp9IHBhcmFtc1xuICogQHJldHVybnMge1VSTFNlYXJjaFBhcmFtc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXJsU2VhcmNoUGFyYW1zICh7IGFyZywgc2VhcmNoUGFyYW1zLCBoYXNoQWxnLCBtdGltZSwgbW9kZSwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgaWYgKHNlYXJjaFBhcmFtcykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4uc2VhcmNoUGFyYW1zXG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc2hBbGcpIHtcbiAgICBvcHRpb25zLmhhc2ggPSBoYXNoQWxnXG4gIH1cblxuICBpZiAobXRpbWUgIT0gbnVsbCkge1xuICAgIG10aW1lID0gcGFyc2VNdGltZShtdGltZSlcblxuICAgIG9wdGlvbnMubXRpbWUgPSBtdGltZS5zZWNzXG4gICAgb3B0aW9ucy5tdGltZU5zZWNzID0gbXRpbWUubnNlY3NcbiAgfVxuXG4gIGlmIChtb2RlICE9IG51bGwpIHtcbiAgICBvcHRpb25zLm1vZGUgPSBtb2RlVG9TdHJpbmcobW9kZSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRpbWVvdXQgJiYgIWlzTmFOKG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAvLyBzZXJ2ZXIgQVBJIGV4cGVjdHMgdGltZW91dHMgYXMgc3RyaW5nc1xuICAgIG9wdGlvbnMudGltZW91dCA9IGAke29wdGlvbnMudGltZW91dH1tc2BcbiAgfVxuXG4gIGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpIHtcbiAgICBhcmcgPSBbXVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBhcmcgPSBbYXJnXVxuICB9XG5cbiAgY29uc3QgdXJsU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zKVxuXG4gIGFyZy5mb3JFYWNoKCgvKiogQHR5cGUge2FueX0gKi8gYXJnKSA9PiB1cmxTZWFyY2hQYXJhbXMuYXBwZW5kKCdhcmcnLCBhcmcpKVxuXG4gIHJldHVybiB1cmxTZWFyY2hQYXJhbXNcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUxldmVsIH0gZnJvbSAnLi9sZXZlbC5qcydcbmltcG9ydCB7IGNyZWF0ZUxzIH0gZnJvbSAnLi9scy5qcydcbmltcG9ydCB7IGNyZWF0ZVRhaWwgfSBmcm9tICcuL3RhaWwuanMnXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2cgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGxldmVsOiBjcmVhdGVMZXZlbChjb25maWcpLFxuICAgIGxzOiBjcmVhdGVMcyhjb25maWcpLFxuICAgIHRhaWw6IGNyZWF0ZVRhaWwoY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvbG9nJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBMb2dBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTGV2ZWwgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtMb2dBUElbXCJsZXZlbFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGxldmVsIChzdWJzeXN0ZW0sIGxldmVsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnbG9nL2xldmVsJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IFtcbiAgICAgICAgICBzdWJzeXN0ZW0sXG4gICAgICAgICAgbGV2ZWxcbiAgICAgICAgXSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSlcbiAgfVxuICByZXR1cm4gbGV2ZWxcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL2xvZycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gTG9nQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUxzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TG9nQVBJW1wibHNcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBscyAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2xvZy9scycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG4gICAgcmV0dXJuIGRhdGEuU3RyaW5nc1xuICB9XG4gIHJldHVybiBsc1xufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvbG9nJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBMb2dBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGFpbCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0xvZ0FQSVtcInRhaWxcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiAqIHRhaWwgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdsb2cvdGFpbCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIHlpZWxkICogcmVzLm5kanNvbigpXG4gIH1cbiAgcmV0dXJuIHRhaWxcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IGNyZWF0ZVN0YXQgfSBmcm9tICcuL2ZpbGVzL3N0YXQuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUm9vdEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMcyA9IGNvbmZpZ3VyZSgoYXBpLCBvcHRzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Um9vdEFQSVtcImxzXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBscyAocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aFN0ciA9IGAke3BhdGggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gQ0lELmRlY29kZShwYXRoKSA6IHBhdGh9YFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBsaW5rXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gbWFwTGluayAobGluaykge1xuICAgICAgbGV0IGhhc2ggPSBsaW5rLkhhc2hcblxuICAgICAgaWYgKGhhc2guaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICAvLyB0aGUgaGFzaCBpcyBhIHBhdGgsIGJ1dCB3ZSBuZWVkIHRoZSBDSURcbiAgICAgICAgY29uc3QgaXBmc1BhdGggPSBoYXNoLnN0YXJ0c1dpdGgoJy9pcGZzLycpID8gaGFzaCA6IGAvaXBmcy8ke2hhc2h9YFxuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGNyZWF0ZVN0YXQob3B0cykoaXBmc1BhdGgpXG5cbiAgICAgICAgaGFzaCA9IHN0YXRzLmNpZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzaCA9IENJRC5wYXJzZShoYXNoKVxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yb290JykuSVBGU0VudHJ5fSAqL1xuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIG5hbWU6IGxpbmsuTmFtZSxcbiAgICAgICAgcGF0aDogcGF0aFN0ciArIChsaW5rLk5hbWUgPyBgLyR7bGluay5OYW1lfWAgOiAnJyksXG4gICAgICAgIHNpemU6IGxpbmsuU2l6ZSxcbiAgICAgICAgY2lkOiBoYXNoLFxuICAgICAgICB0eXBlOiB0eXBlT2YobGluaylcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmsuTW9kZSkge1xuICAgICAgICBlbnRyeS5tb2RlID0gcGFyc2VJbnQobGluay5Nb2RlLCA4KVxuICAgICAgfVxuXG4gICAgICBpZiAobGluay5NdGltZSAhPT0gdW5kZWZpbmVkICYmIGxpbmsuTXRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgZW50cnkubXRpbWUgPSB7XG4gICAgICAgICAgc2VjczogbGluay5NdGltZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmsuTXRpbWVOc2VjcyAhPT0gdW5kZWZpbmVkICYmIGxpbmsuTXRpbWVOc2VjcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGVudHJ5Lm10aW1lLm5zZWNzID0gbGluay5NdGltZU5zZWNzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2xzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGhTdHIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGZvciBhd2FpdCAobGV0IHJlc3VsdCBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5PYmplY3RzXG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgLk9iamVjdHMgaW4gcmVzdWx0cycpXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdFswXVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBvbmUgYXJyYXkgaW4gcmVzdWx0cy5PYmplY3RzJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGlua3MgPSByZXN1bHQuTGlua3NcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaW5rcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBvbmUgYXJyYXkgaW4gcmVzdWx0cy5PYmplY3RzWzBdLkxpbmtzJylcbiAgICAgIH1cblxuICAgICAgaWYgKCFsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gbGlua3MsIHRoaXMgaXMgYSBmaWxlLCB5aWVsZCBhIHNpbmdsZSByZXN1bHRcbiAgICAgICAgeWllbGQgbWFwTGluayhyZXN1bHQpXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHlpZWxkICogbGlua3MubWFwKG1hcExpbmspXG4gICAgfVxuICB9XG4gIHJldHVybiBsc1xufSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbGlua1xuICovXG5mdW5jdGlvbiB0eXBlT2YgKGxpbmspIHtcbiAgc3dpdGNoIChsaW5rLlR5cGUpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuICdkaXInXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuICdmaWxlJ1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cbn1cbiIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3Jvb3QnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJvb3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTW91bnQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSb290QVBJW1wibW91bnRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBtb3VudCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2RucycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIHJldHVybiBvYmplY3RUb0NhbWVsKGF3YWl0IHJlcy5qc29uKCkpXG4gIH1cbiAgcmV0dXJuIG1vdW50XG59KVxuIiwiaW1wb3J0IHsgY3JlYXRlUHVibGlzaCB9IGZyb20gJy4vcHVibGlzaC5qcydcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmUgfSBmcm9tICcuL3Jlc29sdmUuanMnXG5pbXBvcnQgeyBjcmVhdGVQdWJzdWIgfSBmcm9tICcuL3B1YnN1Yi9pbmRleC5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5hbWUgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHB1Ymxpc2g6IGNyZWF0ZVB1Ymxpc2goY29uZmlnKSxcbiAgICByZXNvbHZlOiBjcmVhdGVSZXNvbHZlKGNvbmZpZyksXG4gICAgcHVic3ViOiBjcmVhdGVQdWJzdWIoY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvbmFtZScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gTmFtZUFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQdWJsaXNoID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TmFtZUFQSVtcInB1Ymxpc2hcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBwdWJsaXNoIChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnbmFtZS9wdWJsaXNoJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGAke3BhdGh9YCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXJ2ZXIgb3V0cHV0IGlzIG5vdCB0eXBlZFxuICAgIHJldHVybiBvYmplY3RUb0NhbWVsKGF3YWl0IHJlcy5qc29uKCkpXG4gIH1cbiAgcmV0dXJuIHB1Ymxpc2hcbn0pXG4iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vLi4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvbmFtZS9wdWJzdWInKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IE5hbWVQdWJzdWJBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ2FuY2VsID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TmFtZVB1YnN1YkFQSVtcImNhbmNlbFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbmNlbCAobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ25hbWUvcHVic3ViL2NhbmNlbCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBuYW1lLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHNlcnZlciBvdXRwdXQgaXMgbm90IHR5cGVkXG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSlcbiAgfVxuICByZXR1cm4gY2FuY2VsXG59KVxuIiwiaW1wb3J0IHsgY3JlYXRlQ2FuY2VsIH0gZnJvbSAnLi9jYW5jZWwuanMnXG5pbXBvcnQgeyBjcmVhdGVTdGF0ZSB9IGZyb20gJy4vc3RhdGUuanMnXG5pbXBvcnQgeyBjcmVhdGVTdWJzIH0gZnJvbSAnLi9zdWJzLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHVic3ViIChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBjYW5jZWw6IGNyZWF0ZUNhbmNlbChjb25maWcpLFxuICAgIHN0YXRlOiBjcmVhdGVTdGF0ZShjb25maWcpLFxuICAgIHN1YnM6IGNyZWF0ZVN1YnMoY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vLi4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvbmFtZS9wdWJzdWInKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IE5hbWVQdWJzdWJBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdGUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtOYW1lUHVic3ViQVBJW1wic3RhdGVcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGF0ZSAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ25hbWUvcHVic3ViL3N0YXRlJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXJ2ZXIgb3V0cHV0IGlzIG5vdCB0eXBlZFxuICAgIHJldHVybiBvYmplY3RUb0NhbWVsKGF3YWl0IHJlcy5qc29uKCkpXG4gIH1cbiAgcmV0dXJuIHN0YXRlXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9uYW1lL3B1YnN1YicpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gTmFtZVB1YnN1YkFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTdWJzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TmFtZVB1YnN1YkFQSVtcInN1YnNcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdWJzIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnbmFtZS9wdWJzdWIvc3VicycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIGRhdGEuU3RyaW5ncyB8fCBbXVxuICB9XG4gIHJldHVybiBzdWJzXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9uYW1lJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBOYW1lQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlc29sdmUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtOYW1lQVBJW1wicmVzb2x2ZVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogcmVzb2x2ZSAocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ25hbWUvcmVzb2x2ZScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgeWllbGQgcmVzdWx0LlBhdGhcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9vYmplY3QnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IE9iamVjdEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEYXRhID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0QVBJW1wiZGF0YVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGRhdGEgKGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ29iamVjdC9kYXRhJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGAke2NpZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBDSUQuZGVjb2RlKGNpZCkgOiBjaWR9YCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKVxuXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZGF0YVxufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBmcm9tU3RyaW5nIGFzIHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvZnJvbS1zdHJpbmcnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL29iamVjdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gT2JqZWN0QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdEFQSVtcImdldFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGdldCAoY2lkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnb2JqZWN0L2dldCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBgJHtjaWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gQ0lELmRlY29kZShjaWQpIDogY2lkfWAsXG4gICAgICAgIGRhdGFFbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIERhdGE6IHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGRhdGEuRGF0YSwgJ2Jhc2U2NHBhZCcpLFxuICAgICAgTGlua3M6IChkYXRhLkxpbmtzIHx8IFtdKS5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyBsaW5rKSA9PiAoe1xuICAgICAgICBOYW1lOiBsaW5rLk5hbWUsXG4gICAgICAgIEhhc2g6IENJRC5wYXJzZShsaW5rLkhhc2gpLFxuICAgICAgICBUc2l6ZTogbGluay5TaXplXG4gICAgICB9KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFxufSlcbiIsImltcG9ydCB7IGNyZWF0ZURhdGEgfSBmcm9tICcuL2RhdGEuanMnXG5pbXBvcnQgeyBjcmVhdGVHZXQgfSBmcm9tICcuL2dldC5qcydcbmltcG9ydCB7IGNyZWF0ZUxpbmtzIH0gZnJvbSAnLi9saW5rcy5qcydcbmltcG9ydCB7IGNyZWF0ZU5ldyB9IGZyb20gJy4vbmV3LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUHV0IH0gZnJvbSAnLi9wdXQuanMnXG5pbXBvcnQgeyBjcmVhdGVTdGF0IH0gZnJvbSAnLi9zdGF0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlUGF0Y2ggfSBmcm9tICcuL3BhdGNoL2luZGV4LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNvcmUtdXRpbHMvbXVsdGljb2RlY3MnKS5NdWx0aWNvZGVjc30gY29kZWNzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9iamVjdCAoY29kZWNzLCBjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBjcmVhdGVEYXRhKGNvbmZpZyksXG4gICAgZ2V0OiBjcmVhdGVHZXQoY29uZmlnKSxcbiAgICBsaW5rczogY3JlYXRlTGlua3MoY29uZmlnKSxcbiAgICBuZXc6IGNyZWF0ZU5ldyhjb25maWcpLFxuICAgIHB1dDogY3JlYXRlUHV0KGNvZGVjcywgY29uZmlnKSxcbiAgICBzdGF0OiBjcmVhdGVTdGF0KGNvbmZpZyksXG4gICAgcGF0Y2g6IGNyZWF0ZVBhdGNoKGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvb2JqZWN0JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBPYmplY3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTGlua3MgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3RBUElbXCJsaW5rc1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGxpbmtzIChjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3QvbGlua3MnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYCR7Y2lkIGluc3RhbmNlb2YgVWludDhBcnJheSA/IENJRC5kZWNvZGUoY2lkKSA6IGNpZH1gLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiAoZGF0YS5MaW5rcyB8fCBbXSkubWFwKCgvKiogQHR5cGUge2FueX0gKi8gbCkgPT4gKHtcbiAgICAgIE5hbWU6IGwuTmFtZSxcbiAgICAgIFRzaXplOiBsLlNpemUsXG4gICAgICBIYXNoOiBDSUQucGFyc2UobC5IYXNoKVxuICAgIH0pKVxuICB9XG4gIHJldHVybiBsaW5rc1xufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL29iamVjdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gT2JqZWN0QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5ldyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdEFQSVtcIm5ld1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIG5ld09iamVjdCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ29iamVjdC9uZXcnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogb3B0aW9ucy50ZW1wbGF0ZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3QgeyBIYXNoIH0gPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gQ0lELnBhcnNlKEhhc2gpXG4gIH1cbiAgcmV0dXJuIG5ld09iamVjdFxufSlcbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL29iamVjdC9wYXRjaCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gT2JqZWN0UGF0Y2hBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQWRkTGluayA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdFBhdGNoQVBJW1wiYWRkTGlua1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGFkZExpbmsgKGNpZCwgZExpbmssIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3QvcGF0Y2gvYWRkLWxpbmsnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogW1xuICAgICAgICAgIGAke2NpZH1gLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9vc2UgdHlwZXNcbiAgICAgICAgICBkTGluay5OYW1lIHx8IGRMaW5rLm5hbWUgfHwgJycsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29zZSB0eXBlc1xuICAgICAgICAgIChkTGluay5IYXNoIHx8IGRMaW5rLmNpZCB8fCAnJykudG9TdHJpbmcoKSB8fCBudWxsXG4gICAgICAgIF0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IHsgSGFzaCB9ID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIENJRC5wYXJzZShIYXNoKVxuICB9XG5cbiAgcmV0dXJuIGFkZExpbmtcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi4vLi4vbGliL2Fib3J0LXNpZ25hbC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvb2JqZWN0L3BhdGNoJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBPYmplY3RQYXRjaEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVBcHBlbmREYXRhID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0UGF0Y2hBUElbXCJhcHBlbmREYXRhXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gYXBwZW5kRGF0YSAoY2lkLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBhbGxvdyBhYm9ydGluZyByZXF1ZXN0cyBvbiBib2R5IGVycm9yc1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnb2JqZWN0L3BhdGNoL2FwcGVuZC1kYXRhJywge1xuICAgICAgc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYCR7Y2lkfWAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgLi4uKFxuICAgICAgICBhd2FpdCBtdWx0aXBhcnRSZXF1ZXN0KFtkYXRhXSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgKVxuICAgIH0pXG5cbiAgICBjb25zdCB7IEhhc2ggfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiBDSUQucGFyc2UoSGFzaClcbiAgfVxuICByZXR1cm4gYXBwZW5kRGF0YVxufSlcbiIsImltcG9ydCB7IGNyZWF0ZUFkZExpbmsgfSBmcm9tICcuL2FkZC1saW5rLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQXBwZW5kRGF0YSB9IGZyb20gJy4vYXBwZW5kLWRhdGEuanMnXG5pbXBvcnQgeyBjcmVhdGVSbUxpbmsgfSBmcm9tICcuL3JtLWxpbmsuanMnXG5pbXBvcnQgeyBjcmVhdGVTZXREYXRhIH0gZnJvbSAnLi9zZXQtZGF0YS5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGNoIChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBhZGRMaW5rOiBjcmVhdGVBZGRMaW5rKGNvbmZpZyksXG4gICAgYXBwZW5kRGF0YTogY3JlYXRlQXBwZW5kRGF0YShjb25maWcpLFxuICAgIHJtTGluazogY3JlYXRlUm1MaW5rKGNvbmZpZyksXG4gICAgc2V0RGF0YTogY3JlYXRlU2V0RGF0YShjb25maWcpXG4gIH1cbn1cbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL29iamVjdC9wYXRjaCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gT2JqZWN0UGF0Y2hBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUm1MaW5rID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0UGF0Y2hBUElbXCJybUxpbmtcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBybUxpbmsgKGNpZCwgZExpbmssIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3QvcGF0Y2gvcm0tbGluaycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBbXG4gICAgICAgICAgYCR7Y2lkfWAsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29zZSB0eXBlc1xuICAgICAgICAgIGRMaW5rLk5hbWUgfHwgZExpbmsubmFtZSB8fCBudWxsXG4gICAgICAgIF0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGNvbnN0IHsgSGFzaCB9ID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIENJRC5wYXJzZShIYXNoKVxuICB9XG4gIHJldHVybiBybUxpbmtcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi4vLi4vbGliL2Fib3J0LXNpZ25hbC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvb2JqZWN0L3BhdGNoJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBPYmplY3RQYXRjaEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXREYXRhID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0UGF0Y2hBUElbXCJzZXREYXRhXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc2V0RGF0YSAoY2lkLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBhbGxvdyBhYm9ydGluZyByZXF1ZXN0cyBvbiBib2R5IGVycm9yc1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnb2JqZWN0L3BhdGNoL3NldC1kYXRhJywge1xuICAgICAgc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogW1xuICAgICAgICAgIGAke2NpZH1gXG4gICAgICAgIF0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgLi4uKFxuICAgICAgICBhd2FpdCBtdWx0aXBhcnRSZXF1ZXN0KFtkYXRhXSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgKVxuICAgIH0pXG5cbiAgICBjb25zdCB7IEhhc2ggfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiBDSUQucGFyc2UoSGFzaClcbiAgfVxuICByZXR1cm4gc2V0RGF0YVxufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyBjcmVhdGVQdXQgYXMgY3JlYXRlRGFnUHV0IH0gZnJvbSAnLi4vZGFnL3B1dC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvb2JqZWN0JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBPYmplY3RBUElcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNvcmUtdXRpbHMvbXVsdGljb2RlY3MnKS5NdWx0aWNvZGVjc30gY29kZWNzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQdXQgPSAoY29kZWNzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZuID0gY29uZmlndXJlKChhcGkpID0+IHtcbiAgICBjb25zdCBkYWdQdXQgPSBjcmVhdGVEYWdQdXQoY29kZWNzLCBvcHRpb25zKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdEFQSVtcInB1dFwiXX1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBwdXQgKG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICByZXR1cm4gZGFnUHV0KG9iaiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzdG9yZUNvZGVjOiAnZGFnLXBiJyxcbiAgICAgICAgaGFzaEFsZzogJ3NoYTItMjU2JyxcbiAgICAgICAgdmVyc2lvbjogMVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHB1dFxuICB9KVxuXG4gIHJldHVybiBmbihvcHRpb25zKVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvb2JqZWN0JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBPYmplY3RBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdEFQSVtcInN0YXRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGF0IChjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3Qvc3RhdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBgJHtjaWR9YCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm91dHB1dCxcbiAgICAgIEhhc2g6IENJRC5wYXJzZShvdXRwdXQuSGFzaClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IG5vcm1hbGlzZUlucHV0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL3BpbnMvbm9ybWFsaXNlLWlucHV0J1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3BpbicpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUGluQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUFkZEFsbCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1BpbkFQSVtcImFkZEFsbFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogYWRkQWxsIChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgeyBwYXRoLCByZWN1cnNpdmUsIG1ldGFkYXRhIH0gb2Ygbm9ybWFsaXNlSW5wdXQoc291cmNlKSkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3Bpbi9hZGQnLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAgIHJlY3Vyc2l2ZSxcbiAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEgPyBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgIH0pXG5cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcGluIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgICBpZiAocGluLlBpbnMpIHsgLy8gbm9uLXN0cmVhbWluZyByZXNwb25zZVxuICAgICAgICAgIGZvciAoY29uc3QgY2lkIG9mIHBpbi5QaW5zKSB7XG4gICAgICAgICAgICB5aWVsZCBDSUQucGFyc2UoY2lkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgeWllbGQgQ0lELnBhcnNlKHBpbilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEFsbFxufSlcbiIsImltcG9ydCB7IGNyZWF0ZUFkZEFsbCB9IGZyb20gJy4vYWRkLWFsbC5qcydcbmltcG9ydCBsYXN0IGZyb20gJ2l0LWxhc3QnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9waW4nKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFBpbkFQSVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZGQgKGNvbmZpZykge1xuICBjb25zdCBhbGwgPSBjcmVhdGVBZGRBbGwoY29uZmlnKVxuXG4gIHJldHVybiBjb25maWd1cmUoKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQaW5BUElbXCJhZGRcIl19XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gYWRkIChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbGFzdCBjYW4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIGxhc3QoYWxsKFt7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH1dLCBvcHRpb25zKSlcbiAgICB9XG4gICAgcmV0dXJuIGFkZFxuICB9KShjb25maWcpXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVBZGRBbGwgfSBmcm9tICcuL2FkZC1hbGwuanMnXG5pbXBvcnQgeyBjcmVhdGVBZGQgfSBmcm9tICcuL2FkZC5qcydcbmltcG9ydCB7IGNyZWF0ZUxzIH0gZnJvbSAnLi9scy5qcydcbmltcG9ydCB7IGNyZWF0ZVJtQWxsIH0gZnJvbSAnLi9ybS1hbGwuanMnXG5pbXBvcnQgeyBjcmVhdGVSbSB9IGZyb20gJy4vcm0uanMnXG5pbXBvcnQgeyBjcmVhdGVSZW1vdGUgfSBmcm9tICcuL3JlbW90ZS9pbmRleC5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBpbiAoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgYWRkQWxsOiBjcmVhdGVBZGRBbGwoY29uZmlnKSxcbiAgICBhZGQ6IGNyZWF0ZUFkZChjb25maWcpLFxuICAgIGxzOiBjcmVhdGVMcyhjb25maWcpLFxuICAgIHJtQWxsOiBjcmVhdGVSbUFsbChjb25maWcpLFxuICAgIHJtOiBjcmVhdGVSbShjb25maWcpLFxuICAgIHJlbW90ZTogY3JlYXRlUmVtb3RlKGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBQaW5BUElcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHRvUGluICh0eXBlLCBjaWQsIG1ldGFkYXRhKSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3BpbicpLkxzUmVzdWx0fSAqL1xuICBjb25zdCBwaW4gPSB7XG4gICAgdHlwZSxcbiAgICBjaWQ6IENJRC5wYXJzZShjaWQpXG4gIH1cblxuICBpZiAobWV0YWRhdGEpIHtcbiAgICBwaW4ubWV0YWRhdGEgPSBtZXRhZGF0YVxuICB9XG5cbiAgcmV0dXJuIHBpblxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlTHMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtQaW5BUElbXCJsc1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogbHMgKG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKiBAdHlwZSB7YW55W119ICovXG4gICAgbGV0IHBhdGhzID0gW11cblxuICAgIGlmIChvcHRpb25zLnBhdGhzKSB7XG4gICAgICBwYXRocyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRocykgPyBvcHRpb25zLnBhdGhzIDogW29wdGlvbnMucGF0aHNdXG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3Bpbi9scycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgYXJnOiBwYXRocy5tYXAocGF0aCA9PiBgJHtwYXRofWApLFxuICAgICAgICBzdHJlYW06IHRydWVcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGZvciBhd2FpdCAoY29uc3QgcGluIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgaWYgKHBpbi5LZXlzKSB7IC8vIG5vbi1zdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgZm9yIChjb25zdCBjaWQgb2YgT2JqZWN0LmtleXMocGluLktleXMpKSB7XG4gICAgICAgICAgeWllbGQgdG9QaW4ocGluLktleXNbY2lkXS5UeXBlLCBjaWQsIHBpbi5LZXlzW2NpZF0uTWV0YWRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHRvUGluKHBpbi5UeXBlLCBwaW4uQ2lkLCBwaW4uTWV0YWRhdGEpXG4gICAgfVxuICB9XG4gIHJldHVybiBsc1xufSlcbiIsImltcG9ydCB7IGVuY29kZUFkZFBhcmFtcywgZGVjb2RlUGluIH0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUmVtb3RlUGluaW5nQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vbGliL2NvcmUnKS5DbGllbnR9IGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRkIChjbGllbnQpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSZW1vdGVQaW5pbmdBUElbXCJhZGRcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBhZGQgKGNpZCwgeyB0aW1lb3V0LCBzaWduYWwsIGhlYWRlcnMsIC4uLnF1ZXJ5IH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL2FkZCcsIHtcbiAgICAgIHRpbWVvdXQsXG4gICAgICBzaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2VhcmNoUGFyYW1zOiBlbmNvZGVBZGRQYXJhbXMoeyBjaWQsIC4uLnF1ZXJ5IH0pXG4gICAgfSlcblxuICAgIHJldHVybiBkZWNvZGVQaW4oYXdhaXQgcmVzcG9uc2UuanNvbigpKVxuICB9XG5cbiAgcmV0dXJuIGFkZFxufVxuIiwiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSAnLi4vLi4vbGliL2NvcmUuanMnXG5pbXBvcnQgeyBjcmVhdGVBZGQgfSBmcm9tICcuL2FkZC5qcydcbmltcG9ydCB7IGNyZWF0ZUxzIH0gZnJvbSAnLi9scy5qcydcbmltcG9ydCB7IGNyZWF0ZVJtIH0gZnJvbSAnLi9ybS5qcydcbmltcG9ydCB7IGNyZWF0ZVJtQWxsIH0gZnJvbSAnLi9ybS1hbGwuanMnXG5pbXBvcnQgeyBjcmVhdGVTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlL2luZGV4LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVtb3RlIChjb25maWcpIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudChjb25maWcpXG5cbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGNyZWF0ZUFkZChjbGllbnQpLFxuICAgIGxzOiBjcmVhdGVMcyhjbGllbnQpLFxuICAgIHJtOiBjcmVhdGVSbShjbGllbnQpLFxuICAgIHJtQWxsOiBjcmVhdGVSbUFsbChjbGllbnQpLFxuICAgIHNlcnZpY2U6IGNyZWF0ZVNlcnZpY2UoY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBlbmNvZGVRdWVyeSwgZGVjb2RlUGluIH0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUmVtb3RlUGluaW5nQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vbGliL2NvcmUnKS5DbGllbnR9IGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTHMgKGNsaWVudCkge1xuICAvKipcbiAgICogQHR5cGUge1JlbW90ZVBpbmluZ0FQSVtcImxzXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBscyAoeyB0aW1lb3V0LCBzaWduYWwsIGhlYWRlcnMsIC4uLnF1ZXJ5IH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL2xzJywge1xuICAgICAgdGltZW91dCxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXM6IGVuY29kZVF1ZXJ5KHF1ZXJ5KVxuICAgIH0pXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBpbiBvZiByZXNwb25zZS5uZGpzb24oKSkge1xuICAgICAgeWllbGQgZGVjb2RlUGluKHBpbilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbHNcbn1cbiIsImltcG9ydCB7IGVuY29kZVF1ZXJ5IH0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUmVtb3RlUGluaW5nQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vbGliL2NvcmUnKS5DbGllbnR9IGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm1BbGwgKGNsaWVudCkge1xuICAvKipcbiAgICogQHR5cGUge1JlbW90ZVBpbmluZ0FQSVtcInJtQWxsXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcm1BbGwgKHsgdGltZW91dCwgc2lnbmFsLCBoZWFkZXJzLCAuLi5xdWVyeSB9KSB7XG4gICAgYXdhaXQgY2xpZW50LnBvc3QoJ3Bpbi9yZW1vdGUvcm0nLCB7XG4gICAgICB0aW1lb3V0LFxuICAgICAgc2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNlYXJjaFBhcmFtczogZW5jb2RlUXVlcnkoe1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgYWxsOiB0cnVlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcm1BbGxcbn1cbiIsImltcG9ydCB7IGVuY29kZVF1ZXJ5IH0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUmVtb3RlUGluaW5nQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vbGliL2NvcmUnKS5DbGllbnR9IGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm0gKGNsaWVudCkge1xuICAvKipcbiAgICogQHR5cGUge1JlbW90ZVBpbmluZ0FQSVtcInJtXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcm0gKHsgdGltZW91dCwgc2lnbmFsLCBoZWFkZXJzLCAuLi5xdWVyeSB9KSB7XG4gICAgYXdhaXQgY2xpZW50LnBvc3QoJ3Bpbi9yZW1vdGUvcm0nLCB7XG4gICAgICB0aW1lb3V0LFxuICAgICAgc2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNlYXJjaFBhcmFtczogZW5jb2RlUXVlcnkoe1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgYWxsOiBmYWxzZVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHJtXG59XG4iLCJpbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IGVuY29kZUVuZHBvaW50IH0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBSZW1vdGVQaW5pbmdTZXJ2aWNlQVBJXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vLi4vbGliL2NvcmUnKS5DbGllbnR9IGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRkIChjbGllbnQpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSZW1vdGVQaW5pbmdTZXJ2aWNlQVBJW1wiYWRkXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gYWRkIChuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbmRwb2ludCwga2V5LCBoZWFkZXJzLCB0aW1lb3V0LCBzaWduYWwgfSA9IG9wdGlvbnNcblxuICAgIGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL3NlcnZpY2UvYWRkJywge1xuICAgICAgdGltZW91dCxcbiAgICAgIHNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IFtuYW1lLCBlbmNvZGVFbmRwb2ludChlbmRwb2ludCksIGtleV1cbiAgICAgIH0pLFxuICAgICAgaGVhZGVyc1xuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYWRkXG59XG4iLCJpbXBvcnQgeyBDbGllbnQgfSBmcm9tICcuLi8uLi8uLi9saWIvY29yZS5qcydcbmltcG9ydCB7IGNyZWF0ZUFkZCB9IGZyb20gJy4vYWRkLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTHMgfSBmcm9tICcuL2xzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmljZSAoY29uZmlnKSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoY29uZmlnKVxuXG4gIHJldHVybiB7XG4gICAgYWRkOiBjcmVhdGVBZGQoY2xpZW50KSxcbiAgICBsczogY3JlYXRlTHMoY2xpZW50KSxcbiAgICBybTogY3JlYXRlUm0oY2xpZW50KVxuICB9XG59XG4iLCJpbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IGRlY29kZVJlbW90ZVNlcnZpY2UgfSBmcm9tICcuL3V0aWxzLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uLy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9waW4vcmVtb3RlL3NlcnZpY2UnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJlbW90ZVBpbmluZ1NlcnZpY2VBUElcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi8uLi9saWIvY29yZScpLkNsaWVudH0gY2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMcyAoY2xpZW50KSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UmVtb3RlUGluaW5nU2VydmljZUFQSVtcImxzXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gbHMgKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IGRlcml2ZSBvcHRpb24gdHlwZSBmcm9tIHR5cGVkZWZcbiAgICBjb25zdCB7IHN0YXQsIGhlYWRlcnMsIHRpbWVvdXQsIHNpZ25hbCB9ID0gb3B0aW9uc1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQucG9zdCgncGluL3JlbW90ZS9zZXJ2aWNlL2xzJywge1xuICAgICAgdGltZW91dCxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXM6IHN0YXQgPT09IHRydWUgPyB0b1VybFNlYXJjaFBhcmFtcyh7IHN0YXQgfSkgOiB1bmRlZmluZWRcbiAgICB9KVxuXG4gICAgLyoqIEB0eXBlIHt7UmVtb3RlU2VydmljZXM6IG9iamVjdFtdfX0gKi9cbiAgICBjb25zdCB7IFJlbW90ZVNlcnZpY2VzIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIHJldHVybiBSZW1vdGVTZXJ2aWNlcy5tYXAoZGVjb2RlUmVtb3RlU2VydmljZSlcbiAgfVxuXG4gIHJldHVybiBsc1xufVxuIiwiaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3Bpbi9yZW1vdGUvc2VydmljZScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUmVtb3RlUGluaW5nU2VydmljZUFQSVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uLy4uL2xpYi9jb3JlJykuQ2xpZW50fSBjbGllbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJtIChjbGllbnQpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSZW1vdGVQaW5pbmdTZXJ2aWNlQVBJW1wicm1cIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBybSAobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXdhaXQgY2xpZW50LnBvc3QoJ3Bpbi9yZW1vdGUvc2VydmljZS9ybScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBuYW1lXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcm1cbn1cbiIsIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9waW4vcmVtb3RlL3NlcnZpY2UnKS5SZW1vdGVQaW5TZXJ2aWNlV2l0aFN0YXR9IFJlbW90ZVBpblNlcnZpY2VXaXRoU3RhdFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRW5kcG9pbnQgKHVybCkge1xuICBjb25zdCBocmVmID0gU3RyaW5nKHVybClcbiAgaWYgKGhyZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2VuZHBvaW50IGlzIHJlcXVpcmVkJylcbiAgfVxuICAvLyBXb3JrYXJvdW5kIHRyYWlsaW5nIGAvYCBpc3N1ZSBpbiBnby1pcGZzXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvZ28taXBmcy9pc3N1ZXMvNzgyNlxuICByZXR1cm4gaHJlZltocmVmLmxlbmd0aCAtIDFdID09PSAnLycgPyBocmVmLnNsaWNlKDAsIC0xKSA6IGhyZWZcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ganNvblxuICogQHJldHVybnMge1JlbW90ZVBpblNlcnZpY2VXaXRoU3RhdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJlbW90ZVNlcnZpY2UgKGpzb24pIHtcbiAgcmV0dXJuIHtcbiAgICBzZXJ2aWNlOiBqc29uLlNlcnZpY2UsXG4gICAgZW5kcG9pbnQ6IG5ldyBVUkwoanNvbi5BcGlFbmRwb2ludCksXG4gICAgLi4uKGpzb24uU3RhdCAmJiB7IHN0YXQ6IGRlY29kZVN0YXQoanNvbi5TdGF0KSB9KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGpzb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlJykuU3RhdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0YXQgKGpzb24pIHtcbiAgc3dpdGNoIChqc29uLlN0YXR1cykge1xuICAgIGNhc2UgJ3ZhbGlkJzoge1xuICAgICAgY29uc3QgeyBQaW5uaW5nLCBQaW5uZWQsIFF1ZXVlZCwgRmFpbGVkIH0gPSBqc29uLlBpbkNvdW50XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICd2YWxpZCcsXG4gICAgICAgIHBpbkNvdW50OiB7XG4gICAgICAgICAgcXVldWVkOiBRdWV1ZWQsXG4gICAgICAgICAgcGlubmluZzogUGlubmluZyxcbiAgICAgICAgICBwaW5uZWQ6IFBpbm5lZCxcbiAgICAgICAgICBmYWlsZWQ6IEZhaWxlZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgJ2ludmFsaWQnOiB7XG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdpbnZhbGlkJyB9XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB7IHN0YXR1czoganNvbi5TdGF0dXMgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5BYm9ydE9wdGlvbnN9IEFib3J0T3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9waW4vcmVtb3RlJykuUGlufSBQaW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZScpLkFkZE9wdGlvbnN9IEFkZE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluL3JlbW90ZScpLlF1ZXJ5fSBRdWVyeVxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9waW4vcmVtb3RlJykuU3RhdHVzfSBTdGF0dXNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBqc29uXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvbi5OYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvbi5DaWRcbiAqIEBwYXJhbSB7U3RhdHVzfSBqc29uLlN0YXR1c1xuICogQHJldHVybnMge1Bpbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVBpbiA9ICh7IE5hbWU6IG5hbWUsIFN0YXR1czogc3RhdHVzLCBDaWQ6IGNpZCB9KSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2lkOiBDSUQucGFyc2UoY2lkKSxcbiAgICBuYW1lLFxuICAgIHN0YXR1c1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNlcnZpY2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTZXJ2aWNlID0gKHNlcnZpY2UpID0+IHtcbiAgaWYgKHR5cGVvZiBzZXJ2aWNlID09PSAnc3RyaW5nJyAmJiBzZXJ2aWNlICE9PSAnJykge1xuICAgIHJldHVybiBzZXJ2aWNlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2VydmljZSBuYW1lIG11c3QgYmUgcGFzc2VkJylcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBjaWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVDSUQgPSAoY2lkKSA9PiB7XG4gIGlmIChDSUQuYXNDSUQoY2lkKSkge1xuICAgIHJldHVybiBjaWQudG9TdHJpbmcoKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENJRCBpbnN0YW5jZSBleHBlY3RlZCBpbnN0ZWFkIG9mICR7dHlwZW9mIGNpZH1gKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtRdWVyeSAmIHsgYWxsPzogYm9vbGVhbiB9fSBxdWVyeVxuICogQHJldHVybnMge1VSTFNlYXJjaFBhcmFtc31cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVF1ZXJ5ID0gKHsgc2VydmljZSwgY2lkLCBuYW1lLCBzdGF0dXMsIGFsbCB9KSA9PiB7XG4gIGNvbnN0IHF1ZXJ5ID0gdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgIHNlcnZpY2U6IGVuY29kZVNlcnZpY2Uoc2VydmljZSksXG4gICAgbmFtZSxcbiAgICBmb3JjZTogYWxsID8gdHJ1ZSA6IHVuZGVmaW5lZFxuICB9KVxuXG4gIGlmIChjaWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGNpZCkge1xuICAgICAgcXVlcnkuYXBwZW5kKCdjaWQnLCBlbmNvZGVDSUQodmFsdWUpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0dXMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHN0YXR1cykge1xuICAgICAgcXVlcnkuYXBwZW5kKCdzdGF0dXMnLCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVlcnlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FkZE9wdGlvbnMgJiB7Y2lkOkNJRH19IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtVUkxTZWFyY2hQYXJhbXN9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBZGRQYXJhbXMgPSAoeyBjaWQsIHNlcnZpY2UsIGJhY2tncm91bmQsIG5hbWUsIG9yaWdpbnMgfSkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgYXJnOiBlbmNvZGVDSUQoY2lkKSxcbiAgICBzZXJ2aWNlOiBlbmNvZGVTZXJ2aWNlKHNlcnZpY2UpLFxuICAgIG5hbWUsXG4gICAgYmFja2dyb3VuZDogYmFja2dyb3VuZCA/IHRydWUgOiB1bmRlZmluZWRcbiAgfSlcblxuICBpZiAob3JpZ2lucykge1xuICAgIGZvciAoY29uc3Qgb3JpZ2luIG9mIG9yaWdpbnMpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ29yaWdpbicsIG9yaWdpbi50b1N0cmluZygpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn1cbiIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgbm9ybWFsaXNlSW5wdXQgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvcGlucy9ub3JtYWxpc2UtaW5wdXQnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBQaW5BUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUm1BbGwgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtQaW5BUElbXCJybUFsbFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uICogcm1BbGwgKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB7IHBhdGgsIHJlY3Vyc2l2ZSB9IG9mIG5vcm1hbGlzZUlucHV0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5zZWFyY2hQYXJhbXMpXG4gICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKCdhcmcnLCBgJHtwYXRofWApXG5cbiAgICAgIGlmIChyZWN1cnNpdmUgIT0gbnVsbCkgc2VhcmNoUGFyYW1zLnNldCgncmVjdXJzaXZlJywgU3RyaW5nKHJlY3Vyc2l2ZSkpXG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdwaW4vcm0nLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBhcmc6IGAke3BhdGh9YCxcbiAgICAgICAgICByZWN1cnNpdmVcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcGluIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgICBpZiAocGluLlBpbnMpIHsgLy8gbm9uLXN0cmVhbWluZyByZXNwb25zZVxuICAgICAgICAgIHlpZWxkICogcGluLlBpbnMubWFwKCgvKiogQHR5cGUge3N0cmluZ30gKi8gY2lkKSA9PiBDSUQucGFyc2UoY2lkKSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIENJRC5wYXJzZShwaW4pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBybUFsbFxufSlcbiIsImltcG9ydCB7IGNyZWF0ZVJtQWxsIH0gZnJvbSAnLi9ybS1hbGwuanMnXG5pbXBvcnQgbGFzdCBmcm9tICdpdC1sYXN0J1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcGluJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBQaW5BUElcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUm0gPSAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IGFsbCA9IGNyZWF0ZVJtQWxsKGNvbmZpZylcblxuICByZXR1cm4gY29uZmlndXJlKCgpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UGluQVBJW1wicm1cIl19XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gcm0gKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsYXN0IGNhbiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gbGFzdChhbGwoW3tcbiAgICAgICAgcGF0aCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfV0sIG9wdGlvbnMpKVxuICAgIH1cbiAgICByZXR1cm4gcm1cbiAgfSkoY29uZmlnKVxufVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUm9vdEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQaW5nID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Um9vdEFQSVtcInBpbmdcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiAqIHBpbmcgKHBlZXJJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3BpbmcnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYCR7cGVlcklkfWAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgdHJhbnNmb3JtOiBvYmplY3RUb0NhbWVsXG4gICAgfSlcblxuICAgIHlpZWxkICogcmVzLm5kanNvbigpXG4gIH1cbiAgcmV0dXJuIHBpbmdcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVMcyB9IGZyb20gJy4vbHMuanMnXG5pbXBvcnQgeyBjcmVhdGVQZWVycyB9IGZyb20gJy4vcGVlcnMuanMnXG5pbXBvcnQgeyBjcmVhdGVQdWJsaXNoIH0gZnJvbSAnLi9wdWJsaXNoLmpzJ1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaWJlIH0gZnJvbSAnLi9zdWJzY3JpYmUuanMnXG5pbXBvcnQgeyBjcmVhdGVVbnN1YnNjcmliZSB9IGZyb20gJy4vdW5zdWJzY3JpYmUuanMnXG5pbXBvcnQgeyBTdWJzY3JpcHRpb25UcmFja2VyIH0gZnJvbSAnLi9zdWJzY3JpcHRpb24tdHJhY2tlci5qcydcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVB1YnN1YiAoY29uZmlnKSB7XG4gIGNvbnN0IHN1YnNjcmlwdGlvblRyYWNrZXIgPSBuZXcgU3Vic2NyaXB0aW9uVHJhY2tlcigpXG5cbiAgcmV0dXJuIHtcbiAgICBsczogY3JlYXRlTHMoY29uZmlnKSxcbiAgICBwZWVyczogY3JlYXRlUGVlcnMoY29uZmlnKSxcbiAgICBwdWJsaXNoOiBjcmVhdGVQdWJsaXNoKGNvbmZpZyksXG4gICAgc3Vic2NyaWJlOiBjcmVhdGVTdWJzY3JpYmUoY29uZmlnLCBzdWJzY3JpcHRpb25UcmFja2VyKSxcbiAgICB1bnN1YnNjcmliZTogY3JlYXRlVW5zdWJzY3JpYmUoY29uZmlnLCBzdWJzY3JpcHRpb25UcmFja2VyKVxuICB9XG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBycGNBcnJheVRvVGV4dEFycmF5IH0gZnJvbSAnLi4vbGliL2h0dHAtcnBjLXdpcmUtZm9ybWF0LmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9wdWJzdWInKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFB1YnN1YkFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMcyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1B1YnN1YkFQSVtcImxzXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gbHMgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgU3RyaW5ncyB9ID0gYXdhaXQgKGF3YWl0IGFwaS5wb3N0KCdwdWJzdWIvbHMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pKS5qc29uKClcblxuICAgIHJldHVybiBycGNBcnJheVRvVGV4dEFycmF5KFN0cmluZ3MpIHx8IFtdXG4gIH1cbiAgcmV0dXJuIGxzXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuaW1wb3J0IHsgdGV4dFRvVXJsU2FmZVJwYyB9IGZyb20gJy4uL2xpYi9odHRwLXJwYy13aXJlLWZvcm1hdC5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcHVic3ViJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBQdWJzdWJBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUGVlcnMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtQdWJzdWJBUElbXCJwZWVyc1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHBlZXJzICh0b3BpYywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3B1YnN1Yi9wZWVycycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiB0ZXh0VG9VcmxTYWZlUnBjKHRvcGljKSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgY29uc3QgeyBTdHJpbmdzIH0gPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gU3RyaW5ncyB8fCBbXVxuICB9XG4gIHJldHVybiBwZWVyc1xufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IG11bHRpcGFydFJlcXVlc3QgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGlwYXJ0LXJlcXVlc3QnXG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnXG5pbXBvcnQgeyB0ZXh0VG9VcmxTYWZlUnBjIH0gZnJvbSAnLi4vbGliL2h0dHAtcnBjLXdpcmUtZm9ybWF0LmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9wdWJzdWInKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFB1YnN1YkFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQdWJsaXNoID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UHVic3ViQVBJW1wicHVibGlzaFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHB1Ymxpc2ggKHRvcGljLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICBhcmc6IHRleHRUb1VybFNhZmVScGModG9waWMpLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pXG5cbiAgICAvLyBhbGxvdyBhYm9ydGluZyByZXF1ZXN0cyBvbiBib2R5IGVycm9yc1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgncHVic3ViL3B1YicsIHtcbiAgICAgIHNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgIC4uLihcbiAgICAgICAgYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdChbZGF0YV0sIGNvbnRyb2xsZXIsIG9wdGlvbnMuaGVhZGVycylcbiAgICAgIClcbiAgICB9KVxuXG4gICAgYXdhaXQgcmVzLnRleHQoKVxuICB9XG4gIHJldHVybiBwdWJsaXNoXG59KVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQGxpYnAycC9sb2dnZXInXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyB0ZXh0VG9VcmxTYWZlUnBjLCBycGNUb1RleHQsIHJwY1RvQnl0ZXMsIHJwY1RvQmlnSW50IH0gZnJvbSAnLi4vbGliL2h0dHAtcnBjLXdpcmUtZm9ybWF0LmpzJ1xuaW1wb3J0IHsgcGVlcklkRnJvbVN0cmluZyB9IGZyb20gJ0BsaWJwMnAvcGVlci1pZCdcbmNvbnN0IGxvZyA9IGxvZ2dlcignaXBmcy1odHRwLWNsaWVudDpwdWJzdWI6c3Vic2NyaWJlJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ0BsaWJwMnAvaW50ZXJmYWNlLXB1YnN1YicpLk1lc3NhZ2V9IE1lc3NhZ2VcbiAqIEB0eXBlZGVmIHsoZXJyOiBFcnJvciwgZmF0YWw6IGJvb2xlYW4sIG1zZz86IE1lc3NhZ2UpID0+IHZvaWR9IEVycm9ySGFuZGxlckZuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3B1YnN1YicpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zICYgeyBvbkVycm9yPzogRXJyb3JIYW5kbGVyRm4gfT59IFB1YnN1YkFQSVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5PcHRpb25zfSBPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3N1YnNjcmlwdGlvbi10cmFja2VyJykuU3Vic2NyaXB0aW9uVHJhY2tlcn0gc3Vic1RyYWNrZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN1YnNjcmliZSA9IChvcHRpb25zLCBzdWJzVHJhY2tlcikgPT4ge1xuICByZXR1cm4gY29uZmlndXJlKChhcGkpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHVic3ViQVBJW1wic3Vic2NyaWJlXCJdfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHN1YnNjcmliZSAodG9waWMsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICAgIG9wdGlvbnMuc2lnbmFsID0gc3Vic1RyYWNrZXIuc3Vic2NyaWJlKHRvcGljLCBoYW5kbGVyLCBvcHRpb25zLnNpZ25hbClcblxuICAgICAgLyoqIEB0eXBlIHsodmFsdWU/OiBhbnkpID0+IHZvaWR9ICovXG4gICAgICBsZXQgZG9uZVxuICAgICAgLyoqIEB0eXBlIHsoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSAqL1xuICAgICAgbGV0IGZhaWxcblxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBkb25lID0gcmVzb2x2ZVxuICAgICAgICBmYWlsID0gcmVqZWN0XG4gICAgICB9KVxuXG4gICAgICAvLyBJbiBGaXJlZm94LCB0aGUgaW5pdGlhbCBjYWxsIHRvIGZldGNoIGRvZXMgbm90IHJlc29sdmUgdW50aWwgc29tZSBkYXRhXG4gICAgICAvLyBpcyByZWNlaXZlZC4gSWYgdGhpcyBkb2Vzbid0IGhhcHBlbiB3aXRoaW4gMSBzZWNvbmQgYXNzdW1lIHN1Y2Nlc3NcbiAgICAgIGNvbnN0IGZmV29ya2Fyb3VuZCA9IHNldFRpbWVvdXQoKCkgPT4gZG9uZSgpLCAxMDAwKVxuXG4gICAgICAvLyBEbyB0aGlzIGFzeW5jIHRvIG5vdCBibG9jayBGaXJlZm94XG4gICAgICBhcGkucG9zdCgncHVic3ViL3N1YicsIHtcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgYXJnOiB0ZXh0VG9VcmxTYWZlUnBjKHRvcGljKSxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgLy8gSW5pdGlhbCBzdWJzY3JpYmUgZmFpbCwgZW5zdXJlIHdlIGNsZWFuIHVwXG4gICAgICAgICAgc3Vic1RyYWNrZXIudW5zdWJzY3JpYmUodG9waWMsIGhhbmRsZXIpXG5cbiAgICAgICAgICBmYWlsKGVycilcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGZmV29ya2Fyb3VuZClcblxuICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyByZXNwb25zZSwgdGhlIHN1YnNjcmliZSBmYWlsZWRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRNZXNzYWdlcyhyZXNwb25zZSwge1xuICAgICAgICAgICAgb25NZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZSlcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5oYW5kbGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuaGFuZGxlRXZlbnQobWVzc2FnZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRW5kOiAoKSA9PiBzdWJzVHJhY2tlci51bnN1YnNjcmliZSh0b3BpYywgaGFuZGxlciksXG4gICAgICAgICAgICBvbkVycm9yOiBvcHRpb25zLm9uRXJyb3JcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgZG9uZSgpXG4gICAgICAgIH0pXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmliZVxuICB9KShvcHRpb25zKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLXV0aWxzL3NyYy90eXBlcycpLkV4dGVuZGVkUmVzcG9uc2V9IHJlc3BvbnNlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHsobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZH0gb3B0aW9ucy5vbk1lc3NhZ2VcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gb3B0aW9ucy5vbkVuZFxuICogQHBhcmFtIHtFcnJvckhhbmRsZXJGbn0gW29wdGlvbnMub25FcnJvcl1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZE1lc3NhZ2VzIChyZXNwb25zZSwgeyBvbk1lc3NhZ2UsIG9uRW5kLCBvbkVycm9yIH0pIHtcbiAgb25FcnJvciA9IG9uRXJyb3IgfHwgbG9nXG5cbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1zZyBvZiByZXNwb25zZS5uZGpzb24oKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFtc2cuZnJvbSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobXNnLmZyb20gIT0gbnVsbCAmJiBtc2cuc2Vxbm8gIT0gbnVsbCkge1xuICAgICAgICAgIG9uTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnc2lnbmVkJyxcbiAgICAgICAgICAgIGZyb206IHBlZXJJZEZyb21TdHJpbmcobXNnLmZyb20pLFxuICAgICAgICAgICAgZGF0YTogcnBjVG9CeXRlcyhtc2cuZGF0YSksXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogcnBjVG9CaWdJbnQobXNnLnNlcW5vKSxcbiAgICAgICAgICAgIHRvcGljOiBycGNUb1RleHQobXNnLnRvcGljSURzWzBdKSxcbiAgICAgICAgICAgIGtleTogcnBjVG9CeXRlcyhtc2cua2V5ID8/ICd1JyksXG4gICAgICAgICAgICBzaWduYXR1cmU6IHJwY1RvQnl0ZXMobXNnLnNpZ25hdHVyZSA/PyAndScpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3Vuc2lnbmVkJyxcbiAgICAgICAgICAgIGRhdGE6IHJwY1RvQnl0ZXMobXNnLmRhdGEpLFxuICAgICAgICAgICAgdG9waWM6IHJwY1RvVGV4dChtc2cudG9waWNJRHNbMF0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoLyoqIEB0eXBlIHthbnl9ICovIGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGBGYWlsZWQgdG8gcGFyc2UgcHVic3ViIG1lc3NhZ2U6ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICBvbkVycm9yKGVyciwgZmFsc2UsIG1zZykgLy8gTm90IGZhdGFsXG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoICgvKiogQHR5cGUge2FueX0gKi8gZXJyKSB7XG4gICAgaWYgKCFpc0Fib3J0RXJyb3IoZXJyKSkge1xuICAgICAgb25FcnJvcihlcnIsIHRydWUpIC8vIEZhdGFsXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIG9uRW5kKClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3IgJiB7dHlwZT86c3RyaW5nfX0gZXJyb3JcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc0Fib3J0RXJyb3IgPSBlcnJvciA9PiB7XG4gIHN3aXRjaCAoZXJyb3IudHlwZSkge1xuICAgIGNhc2UgJ2Fib3J0ZWQnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyBJdCBpcyBgYWJvcnRgIGluIEVsZWN0cm9uIGluc3RlYWQgb2YgYGFib3J0ZWRgXG4gICAgY2FzZSAnYWJvcnQnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRklYTUU6IEluIHRlc3Rpbmcgd2l0aCBDaHJvbWUsIGVyci50eXBlIGlzIHVuZGVmaW5lZCAoc2hvdWxkIG5vdCBiZSEpXG4gICAgICAvLyBUZW1wb3JhcmlseSB1c2UgdGhlIG5hbWUgcHJvcGVydHkgaW5zdGVhZC5cbiAgICAgIHJldHVybiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcidcbiAgfVxufVxuIiwiXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ0BsaWJwMnAvaW50ZXJmYWNlLXB1YnN1YicpLk1lc3NhZ2V9IE1lc3NhZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ0BsaWJwMnAvaW50ZXJmYWNlcy9ldmVudHMnKS5FdmVudEhhbmRsZXI8TWVzc2FnZT59IE1lc3NhZ2VIYW5kbGVyRm5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdWJzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7TWVzc2FnZUhhbmRsZXJGbn0gaGFuZGxlclxuICogQHByb3BlcnR5IHtBYm9ydENvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAqL1xuXG5leHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uVHJhY2tlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIFN1YnNjcmlwdGlvbltdPn0gKi9cbiAgICB0aGlzLl9zdWJzID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7TWVzc2FnZUhhbmRsZXJGbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXVxuICAgKi9cbiAgc3Vic2NyaWJlICh0b3BpYywgaGFuZGxlciwgc2lnbmFsKSB7XG4gICAgY29uc3QgdG9waWNTdWJzID0gdGhpcy5fc3Vicy5nZXQodG9waWMpIHx8IFtdXG5cbiAgICBpZiAodG9waWNTdWJzLmZpbmQocyA9PiBzLmhhbmRsZXIgPT09IGhhbmRsZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgc3Vic2NyaWJlZCB0byAke3RvcGljfSB3aXRoIHRoaXMgaGFuZGxlcmApXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNvbnRyb2xsZXIgc28gYSBjYWxsIHRvIHVuc3Vic2NyaWJlIGNhbiBjYW5jZWwgdGhlIHJlcXVlc3RcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cbiAgICB0aGlzLl9zdWJzLnNldCh0b3BpYywgW3sgaGFuZGxlciwgY29udHJvbGxlciB9XS5jb25jYXQodG9waWNTdWJzKSlcblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4dGVybmFsIHNpZ25hbCwgZm9yd2FyZCB0aGUgYWJvcnQgZXZlbnRcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKHRvcGljLCBoYW5kbGVyKSlcbiAgICB9XG5cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtNZXNzYWdlSGFuZGxlckZufSBbaGFuZGxlcl1cbiAgICovXG4gIHVuc3Vic2NyaWJlICh0b3BpYywgaGFuZGxlcikge1xuICAgIGNvbnN0IHN1YnMgPSB0aGlzLl9zdWJzLmdldCh0b3BpYykgfHwgW11cbiAgICBsZXQgdW5zdWJzXG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgdGhpcy5fc3Vicy5zZXQodG9waWMsIHN1YnMuZmlsdGVyKHMgPT4gcy5oYW5kbGVyICE9PSBoYW5kbGVyKSlcbiAgICAgIHVuc3VicyA9IHN1YnMuZmlsdGVyKHMgPT4gcy5oYW5kbGVyID09PSBoYW5kbGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJzLnNldCh0b3BpYywgW10pXG4gICAgICB1bnN1YnMgPSBzdWJzXG4gICAgfVxuXG4gICAgaWYgKCEodGhpcy5fc3Vicy5nZXQodG9waWMpIHx8IFtdKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N1YnMuZGVsZXRlKHRvcGljKVxuICAgIH1cblxuICAgIHVuc3Vicy5mb3JFYWNoKHMgPT4gcy5jb250cm9sbGVyLmFib3J0KCkpXG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcHVic3ViJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBQdWJzdWJBUElcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuT3B0aW9uc30gT3B0aW9uc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zdWJzY3JpcHRpb24tdHJhY2tlcicpLlN1YnNjcmlwdGlvblRyYWNrZXJ9IHN1YnNUcmFja2VyXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVVbnN1YnNjcmliZSA9IChvcHRpb25zLCBzdWJzVHJhY2tlcikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1B1YnN1YkFQSVtcInVuc3Vic2NyaWJlXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gdW5zdWJzY3JpYmUgKHRvcGljLCBoYW5kbGVyKSB7XG4gICAgc3Vic1RyYWNrZXIudW5zdWJzY3JpYmUodG9waWMsIGhhbmRsZXIpXG4gIH1cbiAgcmV0dXJuIHVuc3Vic2NyaWJlXG59XG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5pbXBvcnQgeyBjcmVhdGVMb2NhbCB9IGZyb20gJy4vbG9jYWwuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3JlZnMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJlZnNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVmcyA9IGNvbmZpZ3VyZSgoYXBpLCBvcHRzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UmVmc0FQSVtcInJlZnNcIl19XG4gICAqL1xuICBjb25zdCByZWZzID0gYXN5bmMgZnVuY3Rpb24gKiAoYXJncywgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMnKS5JUEZTUGF0aFtdfSAqL1xuICAgIGNvbnN0IGFyZ3NBcnIgPSBBcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3JlZnMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYXJnc0Fyci5tYXAoYXJnID0+IGAke2FyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBDSUQuZGVjb2RlKGFyZykgOiBhcmd9YCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgdHJhbnNmb3JtOiBvYmplY3RUb0NhbWVsXG4gICAgfSlcblxuICAgIHlpZWxkICogcmVzLm5kanNvbigpXG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZWZzLCB7XG4gICAgbG9jYWw6IGNyZWF0ZUxvY2FsKG9wdHMpXG4gIH0pXG59KVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnXG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3JlZnMnKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJlZnNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTG9jYWwgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSZWZzQVBJW1wibG9jYWxcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiAqIHJlZnNMb2NhbCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3JlZnMvbG9jYWwnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgdHJhbnNmb3JtOiBvYmplY3RUb0NhbWVsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICB5aWVsZCAqIHJlcy5uZGpzb24oKVxuICB9XG4gIHJldHVybiByZWZzTG9jYWxcbn0pXG4iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yZXBvJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBSZXBvQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdjID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UmVwb0FQSVtcImdjXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBnYyAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3JlcG8vZ2MnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgIHRyYW5zZm9ybTogKHJlcykgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycjogcmVzLkVycm9yID8gbmV3IEVycm9yKHJlcy5FcnJvcikgOiBudWxsLFxuICAgICAgICAgIGNpZDogKHJlcy5LZXkgfHwge30pWycvJ10gPyBDSUQucGFyc2UocmVzLktleVsnLyddKSA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB5aWVsZCAqIHJlcy5uZGpzb24oKVxuICB9XG4gIHJldHVybiBnY1xufSlcbiIsImltcG9ydCB7IGNyZWF0ZUdjIH0gZnJvbSAnLi9nYy5qcydcbmltcG9ydCB7IGNyZWF0ZVN0YXQgfSBmcm9tICcuL3N0YXQuanMnXG5pbXBvcnQgeyBjcmVhdGVWZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVwbyAoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgZ2M6IGNyZWF0ZUdjKGNvbmZpZyksXG4gICAgc3RhdDogY3JlYXRlU3RhdChjb25maWcpLFxuICAgIHZlcnNpb246IGNyZWF0ZVZlcnNpb24oY29uZmlnKVxuICB9XG59XG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3JlcG8nKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJlcG9BUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1JlcG9BUElbXCJzdGF0XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhdCAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3JlcG8vc3RhdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG51bU9iamVjdHM6IEJpZ0ludChkYXRhLk51bU9iamVjdHMpLFxuICAgICAgcmVwb1NpemU6IEJpZ0ludChkYXRhLlJlcG9TaXplKSxcbiAgICAgIHJlcG9QYXRoOiBkYXRhLlJlcG9QYXRoLFxuICAgICAgdmVyc2lvbjogZGF0YS5WZXJzaW9uLFxuICAgICAgc3RvcmFnZU1heDogQmlnSW50KGRhdGEuU3RvcmFnZU1heClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRcbn0pXG4iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3JlcG8nKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFJlcG9BUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVmVyc2lvbiA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1JlcG9BUElbXCJ2ZXJzaW9uXCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gdmVyc2lvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgKGF3YWl0IGFwaS5wb3N0KCdyZXBvL3ZlcnNpb24nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pKS5qc29uKClcblxuICAgIHJldHVybiByZXMuVmVyc2lvblxuICB9XG4gIHJldHVybiB2ZXJzaW9uXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yb290JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBSb290QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlc29sdmUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSb290QVBJW1wicmVzb2x2ZVwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmUgKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdyZXNvbHZlJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcbiAgICBjb25zdCB7IFBhdGggfSA9IGF3YWl0IHJlcy5qc29uKClcbiAgICByZXR1cm4gUGF0aFxuICB9XG4gIHJldHVybiByZXNvbHZlXG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUm9vdEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTdGFydCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1Jvb3RBUElbXCJzdGFydFwiXX1cbiAgICovXG4gIGNvbnN0IHN0YXJ0ID0gYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKSwgJ0VSUl9OT1RfSU1QTEVNRU5URUQnKVxuICB9XG5cbiAgcmV0dXJuIHN0YXJ0XG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9zdGF0cycpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gU3RhdHNBUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQncgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTdGF0c0FQSVtcImJ3XCJdfVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gKiBidyAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3N0YXRzL2J3Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICB0cmFuc2Zvcm06IChzdGF0cykgPT4gKHtcbiAgICAgICAgdG90YWxJbjogQmlnSW50KHN0YXRzLlRvdGFsSW4pLFxuICAgICAgICB0b3RhbE91dDogQmlnSW50KHN0YXRzLlRvdGFsT3V0KSxcbiAgICAgICAgcmF0ZUluOiBwYXJzZUZsb2F0KHN0YXRzLlJhdGVJbiksXG4gICAgICAgIHJhdGVPdXQ6IHBhcnNlRmxvYXQoc3RhdHMuUmF0ZU91dClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHlpZWxkICogcmVzLm5kanNvbigpXG4gIH1cbiAgcmV0dXJuIGJ3XG59KVxuIiwiaW1wb3J0IHsgY3JlYXRlU3RhdCBhcyBjcmVhdGVCaXRzd2FwIH0gZnJvbSAnLi4vYml0c3dhcC9zdGF0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlU3RhdCBhcyBjcmVhdGVSZXBvIH0gZnJvbSAnLi4vcmVwby9zdGF0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlQncgfSBmcm9tICcuL2J3LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RhdHMgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGJpdHN3YXA6IGNyZWF0ZUJpdHN3YXAoY29uZmlnKSxcbiAgICByZXBvOiBjcmVhdGVSZXBvKGNvbmZpZyksXG4gICAgYnc6IGNyZWF0ZUJ3KGNvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJ1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9yb290JykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBSb290QVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3AgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtSb290QVBJW1wic3RvcFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHN0b3AgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzaHV0ZG93bicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIGF3YWl0IHJlcy50ZXh0KClcbiAgfVxuICByZXR1cm4gc3RvcFxufSlcbiIsImltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuaW1wb3J0IHsgcGVlcklkRnJvbVN0cmluZyB9IGZyb20gJ0BsaWJwMnAvcGVlci1pZCdcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvc3dhcm0nKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFN3YXJtQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUFkZHJzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7U3dhcm1BUElbXCJhZGRyc1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGFkZHJzIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnc3dhcm0vYWRkcnMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG5cbiAgICAvKiogQHR5cGUge3sgQWRkcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiB9fSAqL1xuICAgIGNvbnN0IHsgQWRkcnMgfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhBZGRycykubWFwKGlkID0+ICh7XG4gICAgICBpZDogcGVlcklkRnJvbVN0cmluZyhpZCksXG4gICAgICBhZGRyczogKEFkZHJzW2lkXSB8fCBbXSkubWFwKGEgPT4gbXVsdGlhZGRyKGEpKVxuICAgIH0pKVxuICB9XG4gIHJldHVybiBhZGRyc1xufSlcbiIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvc3dhcm0nKS5BUEk8SFRUUENsaWVudEV4dHJhT3B0aW9ucz59IFN3YXJtQVBJXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbm5lY3QgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTd2FybUFQSVtcImNvbm5lY3RcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0IChhZGRyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnc3dhcm0vY29ubmVjdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBhZGRyLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pXG4gICAgY29uc3QgeyBTdHJpbmdzIH0gPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gU3RyaW5ncyB8fCBbXVxuICB9XG4gIHJldHVybiBjb25uZWN0XG59KVxuIiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9zd2FybScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gU3dhcm1BUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRGlzY29ubmVjdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1N3YXJtQVBJW1wiZGlzY29ubmVjdFwiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3QgKGFkZHIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzd2FybS9kaXNjb25uZWN0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGFkZHIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcbiAgICBjb25zdCB7IFN0cmluZ3MgfSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgIHJldHVybiBTdHJpbmdzIHx8IFtdXG4gIH1cbiAgcmV0dXJuIGRpc2Nvbm5lY3Rcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVBZGRycyB9IGZyb20gJy4vYWRkcnMuanMnXG5pbXBvcnQgeyBjcmVhdGVDb25uZWN0IH0gZnJvbSAnLi9jb25uZWN0LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRGlzY29ubmVjdCB9IGZyb20gJy4vZGlzY29ubmVjdC5qcydcbmltcG9ydCB7IGNyZWF0ZUxvY2FsQWRkcnMgfSBmcm9tICcuL2xvY2FsLWFkZHJzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlUGVlcnMgfSBmcm9tICcuL3BlZXJzLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcycpLk9wdGlvbnN9IGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3dhcm0gKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGFkZHJzOiBjcmVhdGVBZGRycyhjb25maWcpLFxuICAgIGNvbm5lY3Q6IGNyZWF0ZUNvbm5lY3QoY29uZmlnKSxcbiAgICBkaXNjb25uZWN0OiBjcmVhdGVEaXNjb25uZWN0KGNvbmZpZyksXG4gICAgbG9jYWxBZGRyczogY3JlYXRlTG9jYWxBZGRycyhjb25maWcpLFxuICAgIHBlZXJzOiBjcmVhdGVQZWVycyhjb25maWcpXG4gIH1cbn1cbiIsImltcG9ydCB7IG11bHRpYWRkciB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyJ1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzJykuSFRUUENsaWVudEV4dHJhT3B0aW9uc30gSFRUUENsaWVudEV4dHJhT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy9zd2FybScpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gU3dhcm1BUElcbiAqL1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTG9jYWxBZGRycyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1N3YXJtQVBJW1wibG9jYWxBZGRyc1wiXX1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGxvY2FsQWRkcnMgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzd2FybS9hZGRycy9sb2NhbCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIC8qKiBAdHlwZSB7eyBTdHJpbmdzOiBzdHJpbmdbXSB9fSAqL1xuICAgIGNvbnN0IHsgU3RyaW5ncyB9ID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgcmV0dXJuIChTdHJpbmdzIHx8IFtdKS5tYXAoYSA9PiBtdWx0aWFkZHIoYSkpXG4gIH1cbiAgcmV0dXJuIGxvY2FsQWRkcnNcbn0pXG4iLCJpbXBvcnQgeyBtdWx0aWFkZHIgfSBmcm9tICdAbXVsdGlmb3JtYXRzL211bHRpYWRkcidcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnXG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcydcbmltcG9ydCB7IHBlZXJJZEZyb21TdHJpbmcgfSBmcm9tICdAbGlicDJwL3BlZXItaWQnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5IVFRQQ2xpZW50RXh0cmFPcHRpb25zfSBIVFRQQ2xpZW50RXh0cmFPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3N3YXJtJykuQVBJPEhUVFBDbGllbnRFeHRyYU9wdGlvbnM+fSBTd2FybUFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQZWVycyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1N3YXJtQVBJW1wicGVlcnNcIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBwZWVycyAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3N3YXJtL3BlZXJzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KVxuXG4gICAgLyoqIEB0eXBlIHt7IFBlZXJzOiB7IFBlZXI6IHN0cmluZywgQWRkcjogc3RyaW5nLCBNdXhlcj86IHN0cmluZywgTGF0ZW5jeT86IHN0cmluZywgU3RyZWFtcz86IHN0cmluZ1tdLCBEaXJlY3Rpb24/OiAwIHwgMSB9W10gfX0gKi9cbiAgICBjb25zdCB7IFBlZXJzIH0gPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICByZXR1cm4gKFBlZXJzIHx8IFtdKS5tYXAocGVlciA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyOiBtdWx0aWFkZHIocGVlci5BZGRyKSxcbiAgICAgICAgcGVlcjogcGVlcklkRnJvbVN0cmluZyhwZWVyLlBlZXIpLFxuICAgICAgICBtdXhlcjogcGVlci5NdXhlcixcbiAgICAgICAgbGF0ZW5jeTogcGVlci5MYXRlbmN5LFxuICAgICAgICBzdHJlYW1zOiBwZWVyLlN0cmVhbXMsXG4gICAgICAgIGRpcmVjdGlvbjogcGVlci5EaXJlY3Rpb24gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBlZXIuRGlyZWN0aW9uID09PSAwID8gJ2luYm91bmQnIDogJ291dGJvdW5kJ1xuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHBlZXJzXG59KVxuIiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4vbGliL29iamVjdC10by1jYW1lbC5qcydcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcydcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBDbGllbnRFeHRyYU9wdGlvbnN9IEhUVFBDbGllbnRFeHRyYU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvcm9vdCcpLkFQSTxIVFRQQ2xpZW50RXh0cmFPcHRpb25zPn0gUm9vdEFQSVxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVWZXJzaW9uID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Um9vdEFQSVtcInZlcnNpb25cIl19XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiB2ZXJzaW9uIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgndmVyc2lvbicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSlcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2VydmVyIG91dHB1dCBpcyBub3QgdHlwZWRcbiAgICByZXR1cm4ge1xuICAgICAgLi4ub2JqZWN0VG9DYW1lbChhd2FpdCByZXMuanNvbigpKSxcbiAgICAgICdpcGZzLWh0dHAtY2xpZW50JzogJzEuMC4wJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uXG59KVxuIiwiaW1wb3J0IGVycmNvZGUgZnJvbSAnZXJyLWNvZGUnXG5pbXBvcnQgKiBhcyBQYiBmcm9tICcuL3VuaXhmcy5qcydcbmNvbnN0IFBCRGF0YSA9IFBiLkRhdGFcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuTXRpbWV9IE10aW1lXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuTXRpbWVMaWtlfSBNdGltZUxpa2VcbiAqL1xuXG5jb25zdCB0eXBlcyA9IFtcbiAgJ3JhdycsXG4gICdkaXJlY3RvcnknLFxuICAnZmlsZScsXG4gICdtZXRhZGF0YScsXG4gICdzeW1saW5rJyxcbiAgJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknXG5dXG5cbmNvbnN0IGRpclR5cGVzID0gW1xuICAnZGlyZWN0b3J5JyxcbiAgJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknXG5dXG5cbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gcGFyc2VJbnQoJzA2NDQnLCA4KVxuY29uc3QgREVGQVVMVF9ESVJFQ1RPUllfTU9ERSA9IHBhcnNlSW50KCcwNzU1JywgOClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZH0gW21vZGVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1vZGUgKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbW9kZSAmIDB4RkZGXG4gIH1cblxuICBtb2RlID0gbW9kZS50b1N0cmluZygpXG5cbiAgaWYgKG1vZGUuc3Vic3RyaW5nKDAsIDEpID09PSAnMCcpIHtcbiAgICAvLyBvY3RhbCBzdHJpbmdcbiAgICByZXR1cm4gcGFyc2VJbnQobW9kZSwgOCkgJiAweEZGRlxuICB9XG5cbiAgLy8gZGVjaW1hbCBzdHJpbmdcbiAgcmV0dXJuIHBhcnNlSW50KG1vZGUsIDEwKSAmIDB4RkZGXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU10aW1lIChpbnB1dCkge1xuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKiBAdHlwZSB7TXRpbWUgfCB1bmRlZmluZWR9ICovXG4gIGxldCBtdGltZVxuXG4gIC8vIHsgc2VjcywgbnNlY3MgfVxuICBpZiAoaW5wdXQuc2VjcyAhPSBudWxsKSB7XG4gICAgbXRpbWUgPSB7XG4gICAgICBzZWNzOiBpbnB1dC5zZWNzLFxuICAgICAgbnNlY3M6IGlucHV0Lm5zZWNzXG4gICAgfVxuICB9XG5cbiAgLy8gVW5peEZTIFRpbWVTcGVjXG4gIGlmIChpbnB1dC5TZWNvbmRzICE9IG51bGwpIHtcbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IGlucHV0LlNlY29uZHMsXG4gICAgICBuc2VjczogaW5wdXQuRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgfVxuICB9XG5cbiAgLy8gcHJvY2Vzcy5ocnRpbWUoKVxuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IGlucHV0WzBdLFxuICAgICAgbnNlY3M6IGlucHV0WzFdXG4gICAgfVxuICB9XG5cbiAgLy8gSmF2YXNjcmlwdCBEYXRlXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBjb25zdCBtcyA9IGlucHV0LmdldFRpbWUoKVxuICAgIGNvbnN0IHNlY3MgPSBNYXRoLmZsb29yKG1zIC8gMTAwMClcblxuICAgIG10aW1lID0ge1xuICAgICAgc2Vjczogc2VjcyxcbiAgICAgIG5zZWNzOiAobXMgLSAoc2VjcyAqIDEwMDApKSAqIDEwMDBcbiAgICB9XG4gIH1cblxuICAvKlxuICBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vaXBmcy9hZWdpci9pc3N1ZXMvNDg3XG5cbiAgLy8gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KClcbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgQmlnSW50KSB7XG4gICAgY29uc3Qgc2VjcyA9IGlucHV0IC8gQmlnSW50KDFlOSlcbiAgICBjb25zdCBuc2VjcyA9IGlucHV0IC0gKHNlY3MgKiBCaWdJbnQoMWU5KSlcblxuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogcGFyc2VJbnQoc2Vjcy50b1N0cmluZygpKSxcbiAgICAgIG5zZWNzOiBwYXJzZUludChuc2Vjcy50b1N0cmluZygpKVxuICAgIH1cbiAgfVxuICAqL1xuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG10aW1lLCAnc2VjcycpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKG10aW1lICE9IG51bGwgJiYgbXRpbWUubnNlY3MgIT0gbnVsbCAmJiAobXRpbWUubnNlY3MgPCAwIHx8IG10aW1lLm5zZWNzID4gOTk5OTk5OTk5KSkge1xuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdtdGltZS1uc2VjcyBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2UgWzAsOTk5OTk5OTk5XScpLCAnRVJSX0lOVkFMSURfTVRJTUVfTlNFQ1MnKVxuICB9XG5cbiAgcmV0dXJuIG10aW1lXG59XG5cbmNsYXNzIFVuaXhGUyB7XG4gIC8qKlxuICAgKiBEZWNvZGUgZnJvbSBwcm90b2J1ZiBodHRwczovL2dpdGh1Yi5jb20vaXBmcy9zcGVjcy9ibG9iL21hc3Rlci9VTklYRlMubWRcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtYXJzaGFsZWRcbiAgICovXG4gIHN0YXRpYyB1bm1hcnNoYWwgKG1hcnNoYWxlZCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBQQkRhdGEuZGVjb2RlKG1hcnNoYWxlZClcbiAgICBjb25zdCBkZWNvZGVkID0gUEJEYXRhLnRvT2JqZWN0KG1lc3NhZ2UsIHtcbiAgICAgIGRlZmF1bHRzOiBmYWxzZSxcbiAgICAgIGFycmF5czogdHJ1ZSxcbiAgICAgIGxvbmdzOiBOdW1iZXIsXG4gICAgICBvYmplY3RzOiBmYWxzZVxuICAgIH0pXG5cbiAgICBjb25zdCBkYXRhID0gbmV3IFVuaXhGUyh7XG4gICAgICB0eXBlOiB0eXBlc1tkZWNvZGVkLlR5cGVdLFxuICAgICAgZGF0YTogZGVjb2RlZC5EYXRhLFxuICAgICAgYmxvY2tTaXplczogZGVjb2RlZC5ibG9ja3NpemVzLFxuICAgICAgbW9kZTogZGVjb2RlZC5tb2RlLFxuICAgICAgbXRpbWU6IGRlY29kZWQubXRpbWVcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBzZWNzOiBkZWNvZGVkLm10aW1lLlNlY29uZHMsXG4gICAgICAgICAgICBuc2VjczogZGVjb2RlZC5tdGltZS5GcmFjdGlvbmFsTmFub3NlY29uZHNcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgfSlcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBob25vdXIgdGhlIG9yaWdpbmFsIG1vZGVcbiAgICBkYXRhLl9vcmlnaW5hbE1vZGUgPSBkZWNvZGVkLm1vZGUgfHwgMFxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50eXBlPSdmaWxlJ11cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbb3B0aW9ucy5kYXRhXVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBbb3B0aW9ucy5ibG9ja1NpemVzXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGFzaFR5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mYW5vdXRdXG4gICAqIEBwYXJhbSB7TXRpbWVMaWtlIHwgbnVsbH0gW29wdGlvbnMubXRpbWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSBbb3B0aW9ucy5tb2RlXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7XG4gICAgdHlwZTogJ2ZpbGUnXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZGF0YSxcbiAgICAgIGJsb2NrU2l6ZXMsXG4gICAgICBoYXNoVHlwZSxcbiAgICAgIGZhbm91dCxcbiAgICAgIG10aW1lLFxuICAgICAgbW9kZVxuICAgIH0gPSBvcHRpb25zXG5cbiAgICBpZiAodHlwZSAmJiAhdHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdUeXBlOiAnICsgdHlwZSArICcgaXMgbm90IHZhbGlkJyksICdFUlJfSU5WQUxJRF9UWVBFJylcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8ICdmaWxlJ1xuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmhhc2hUeXBlID0gaGFzaFR5cGVcbiAgICB0aGlzLmZhbm91dCA9IGZhbm91dFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJbXX0gKi9cbiAgICB0aGlzLmJsb2NrU2l6ZXMgPSBibG9ja1NpemVzIHx8IFtdXG4gICAgdGhpcy5fb3JpZ2luYWxNb2RlID0gMFxuICAgIHRoaXMubW9kZSA9IHBhcnNlTW9kZShtb2RlKVxuXG4gICAgaWYgKG10aW1lKSB7XG4gICAgICB0aGlzLm10aW1lID0gcGFyc2VNdGltZShtdGltZSlcblxuICAgICAgaWYgKHRoaXMubXRpbWUgJiYgIXRoaXMubXRpbWUubnNlY3MpIHtcbiAgICAgICAgdGhpcy5tdGltZS5uc2VjcyA9IDBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IG1vZGVcbiAgICovXG4gIHNldCBtb2RlIChtb2RlKSB7XG4gICAgdGhpcy5fbW9kZSA9IHRoaXMuaXNEaXJlY3RvcnkoKSA/IERFRkFVTFRfRElSRUNUT1JZX01PREUgOiBERUZBVUxUX0ZJTEVfTU9ERVxuXG4gICAgY29uc3QgcGFyc2VkTW9kZSA9IHBhcnNlTW9kZShtb2RlKVxuXG4gICAgaWYgKHBhcnNlZE1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbW9kZSA9IHBhcnNlZE1vZGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBtb2RlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZVxuICB9XG5cbiAgaXNEaXJlY3RvcnkgKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudHlwZSAmJiBkaXJUeXBlcy5pbmNsdWRlcyh0aGlzLnR5cGUpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqL1xuICBhZGRCbG9ja1NpemUgKHNpemUpIHtcbiAgICB0aGlzLmJsb2NrU2l6ZXMucHVzaChzaXplKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgcmVtb3ZlQmxvY2tTaXplIChpbmRleCkge1xuICAgIHRoaXMuYmxvY2tTaXplcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgMGAgZm9yIGRpcmVjdG9yaWVzIG9yIGBkYXRhLmxlbmd0aCArIHN1bShibG9ja1NpemVzKWAgZm9yIGV2ZXJ5dGhpbmcgZWxzZVxuICAgKi9cbiAgZmlsZVNpemUgKCkge1xuICAgIGlmICh0aGlzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIC8vIGRpcnMgZG9uJ3QgaGF2ZSBmaWxlIHNpemVcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgbGV0IHN1bSA9IDBcbiAgICB0aGlzLmJsb2NrU2l6ZXMuZm9yRWFjaCgoc2l6ZSkgPT4ge1xuICAgICAgc3VtICs9IHNpemVcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgc3VtICs9IHRoaXMuZGF0YS5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtXG4gIH1cblxuICAvKipcbiAgICogZW5jb2RlIHRvIHByb3RvYnVmIFVpbnQ4QXJyYXlcbiAgICovXG4gIG1hcnNoYWwgKCkge1xuICAgIGxldCB0eXBlXG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAncmF3JzogdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5SYXc7IGJyZWFrXG4gICAgICBjYXNlICdkaXJlY3RvcnknOiB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkRpcmVjdG9yeTsgYnJlYWtcbiAgICAgIGNhc2UgJ2ZpbGUnOiB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkZpbGU7IGJyZWFrXG4gICAgICBjYXNlICdtZXRhZGF0YSc6IHR5cGUgPSBQQkRhdGEuRGF0YVR5cGUuTWV0YWRhdGE7IGJyZWFrXG4gICAgICBjYXNlICdzeW1saW5rJzogdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5TeW1saW5rOyBicmVha1xuICAgICAgY2FzZSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6IHR5cGUgPSBQQkRhdGEuRGF0YVR5cGUuSEFNVFNoYXJkOyBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgZXJyY29kZShuZXcgRXJyb3IoJ1R5cGU6ICcgKyB0eXBlICsgJyBpcyBub3QgdmFsaWQnKSwgJ0VSUl9JTlZBTElEX1RZUEUnKVxuICAgIH1cblxuICAgIGxldCBkYXRhID0gdGhpcy5kYXRhXG5cbiAgICBpZiAoIXRoaXMuZGF0YSB8fCAhdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgZGF0YSA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGxldCBtb2RlXG5cbiAgICBpZiAodGhpcy5tb2RlICE9IG51bGwpIHtcbiAgICAgIG1vZGUgPSAodGhpcy5fb3JpZ2luYWxNb2RlICYgMHhGRkZGRjAwMCkgfCAocGFyc2VNb2RlKHRoaXMubW9kZSkgfHwgMClcblxuICAgICAgaWYgKG1vZGUgPT09IERFRkFVTFRfRklMRV9NT0RFICYmICF0aGlzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgbW9kZSA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gREVGQVVMVF9ESVJFQ1RPUllfTU9ERSAmJiB0aGlzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgbW9kZSA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtdGltZVxuXG4gICAgaWYgKHRoaXMubXRpbWUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VNdGltZSh0aGlzLm10aW1lKVxuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIG10aW1lID0ge1xuICAgICAgICAgIFNlY29uZHM6IHBhcnNlZC5zZWNzLFxuICAgICAgICAgIEZyYWN0aW9uYWxOYW5vc2Vjb25kczogcGFyc2VkLm5zZWNzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG10aW1lLkZyYWN0aW9uYWxOYW5vc2Vjb25kc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGJEYXRhID0ge1xuICAgICAgVHlwZTogdHlwZSxcbiAgICAgIERhdGE6IGRhdGEsXG4gICAgICBmaWxlc2l6ZTogdGhpcy5pc0RpcmVjdG9yeSgpID8gdW5kZWZpbmVkIDogdGhpcy5maWxlU2l6ZSgpLFxuICAgICAgYmxvY2tzaXplczogdGhpcy5ibG9ja1NpemVzLFxuICAgICAgaGFzaFR5cGU6IHRoaXMuaGFzaFR5cGUsXG4gICAgICBmYW5vdXQ6IHRoaXMuZmFub3V0LFxuICAgICAgbW9kZSxcbiAgICAgIG10aW1lXG4gICAgfVxuXG4gICAgcmV0dXJuIFBCRGF0YS5lbmNvZGUocGJEYXRhKS5maW5pc2goKVxuICB9XG59XG5cbmV4cG9ydCB7IFVuaXhGUyB9XG4iLCIvKmVzbGludC1kaXNhYmxlKi9cbmltcG9ydCAkcHJvdG9idWYgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbC5qc1wiO1xuXG4vLyBDb21tb24gYWxpYXNlc1xuY29uc3QgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xuXG4vLyBFeHBvcnRlZCByb290IG5hbWVzcGFjZVxuY29uc3QgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJpcGZzLXVuaXhmc1wiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiaXBmcy11bml4ZnNcIl0gPSB7fSk7XG5cbmV4cG9ydCBjb25zdCBEYXRhID0gJHJvb3QuRGF0YSA9ICgoKSA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgRGF0YS5cbiAgICAgKiBAZXhwb3J0cyBJRGF0YVxuICAgICAqIEBpbnRlcmZhY2UgSURhdGFcbiAgICAgKiBAcHJvcGVydHkge0RhdGEuRGF0YVR5cGV9IFR5cGUgRGF0YSBUeXBlXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtEYXRhXSBEYXRhIERhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZmlsZXNpemVdIERhdGEgZmlsZXNpemVcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtibG9ja3NpemVzXSBEYXRhIGJsb2Nrc2l6ZXNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbaGFzaFR5cGVdIERhdGEgaGFzaFR5cGVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZmFub3V0XSBEYXRhIGZhbm91dFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFttb2RlXSBEYXRhIG1vZGVcbiAgICAgKiBAcHJvcGVydHkge0lVbml4VGltZXxudWxsfSBbbXRpbWVdIERhdGEgbXRpbWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGF0YS5cbiAgICAgKiBAZXhwb3J0cyBEYXRhXG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRGF0YS5cbiAgICAgKiBAaW1wbGVtZW50cyBJRGF0YVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SURhdGE9fSBbcF0gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhKHApIHtcbiAgICAgICAgdGhpcy5ibG9ja3NpemVzID0gW107XG4gICAgICAgIGlmIChwKVxuICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIFR5cGUuXG4gICAgICogQG1lbWJlciB7RGF0YS5EYXRhVHlwZX0gVHlwZVxuICAgICAqIEBtZW1iZXJvZiBEYXRhXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRGF0YS5wcm90b3R5cGUuVHlwZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIERhdGEuXG4gICAgICogQG1lbWJlciB7VWludDhBcnJheX0gRGF0YVxuICAgICAqIEBtZW1iZXJvZiBEYXRhXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRGF0YS5wcm90b3R5cGUuRGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGZpbGVzaXplLlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZmlsZXNpemVcbiAgICAgKiBAbWVtYmVyb2YgRGF0YVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIERhdGEucHJvdG90eXBlLmZpbGVzaXplID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLHRydWUpIDogMDtcblxuICAgIC8qKlxuICAgICAqIERhdGEgYmxvY2tzaXplcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gYmxvY2tzaXplc1xuICAgICAqIEBtZW1iZXJvZiBEYXRhXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRGF0YS5wcm90b3R5cGUuYmxvY2tzaXplcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGhhc2hUeXBlLlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gaGFzaFR5cGVcbiAgICAgKiBAbWVtYmVyb2YgRGF0YVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIERhdGEucHJvdG90eXBlLmhhc2hUeXBlID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLHRydWUpIDogMDtcblxuICAgIC8qKlxuICAgICAqIERhdGEgZmFub3V0LlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZmFub3V0XG4gICAgICogQG1lbWJlcm9mIERhdGFcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBEYXRhLnByb3RvdHlwZS5mYW5vdXQgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsdHJ1ZSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBtb2RlLlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbW9kZVxuICAgICAqIEBtZW1iZXJvZiBEYXRhXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRGF0YS5wcm90b3R5cGUubW9kZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIG10aW1lLlxuICAgICAqIEBtZW1iZXIge0lVbml4VGltZXxudWxsfHVuZGVmaW5lZH0gbXRpbWVcbiAgICAgKiBAbWVtYmVyb2YgRGF0YVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIERhdGEucHJvdG90eXBlLm10aW1lID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBEYXRhIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIERhdGEudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7SURhdGF9IG0gRGF0YSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3XSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIERhdGEuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG0sIHcpIHtcbiAgICAgICAgaWYgKCF3KVxuICAgICAgICAgICAgdyA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIHcudWludDMyKDgpLmludDMyKG0uVHlwZSk7XG4gICAgICAgIGlmIChtLkRhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCBcIkRhdGFcIikpXG4gICAgICAgICAgICB3LnVpbnQzMigxOCkuYnl0ZXMobS5EYXRhKTtcbiAgICAgICAgaWYgKG0uZmlsZXNpemUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCBcImZpbGVzaXplXCIpKVxuICAgICAgICAgICAgdy51aW50MzIoMjQpLnVpbnQ2NChtLmZpbGVzaXplKTtcbiAgICAgICAgaWYgKG0uYmxvY2tzaXplcyAhPSBudWxsICYmIG0uYmxvY2tzaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5ibG9ja3NpemVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHcudWludDMyKDMyKS51aW50NjQobS5ibG9ja3NpemVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobS5oYXNoVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sIFwiaGFzaFR5cGVcIikpXG4gICAgICAgICAgICB3LnVpbnQzMig0MCkudWludDY0KG0uaGFzaFR5cGUpO1xuICAgICAgICBpZiAobS5mYW5vdXQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCBcImZhbm91dFwiKSlcbiAgICAgICAgICAgIHcudWludDMyKDQ4KS51aW50NjQobS5mYW5vdXQpO1xuICAgICAgICBpZiAobS5tb2RlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgXCJtb2RlXCIpKVxuICAgICAgICAgICAgdy51aW50MzIoNTYpLnVpbnQzMihtLm1vZGUpO1xuICAgICAgICBpZiAobS5tdGltZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sIFwibXRpbWVcIikpXG4gICAgICAgICAgICAkcm9vdC5Vbml4VGltZS5lbmNvZGUobS5tdGltZSwgdy51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgRGF0YSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2YgRGF0YVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge0RhdGF9IERhdGFcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIERhdGEuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LkRhdGEoKTtcbiAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbS5UeXBlID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG0uRGF0YSA9IHIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtLmZpbGVzaXplID0gci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAoIShtLmJsb2Nrc2l6ZXMgJiYgbS5ibG9ja3NpemVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIG0uYmxvY2tzaXplcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmJsb2Nrc2l6ZXMucHVzaChyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbS5ibG9ja3NpemVzLnB1c2goci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgbS5oYXNoVHlwZSA9IHIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgbS5mYW5vdXQgPSByLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG0ubW9kZSA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgbS5tdGltZSA9ICRyb290LlVuaXhUaW1lLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtLmhhc093blByb3BlcnR5KFwiVHlwZVwiKSlcbiAgICAgICAgICAgIHRocm93ICR1dGlsLlByb3RvY29sRXJyb3IoXCJtaXNzaW5nIHJlcXVpcmVkICdUeXBlJ1wiLCB7IGluc3RhbmNlOiBtIH0pO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERhdGEgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIERhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7RGF0YX0gRGF0YVxuICAgICAqL1xuICAgIERhdGEuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoZCkge1xuICAgICAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290LkRhdGEpXG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgdmFyIG0gPSBuZXcgJHJvb3QuRGF0YSgpO1xuICAgICAgICBzd2l0Y2ggKGQuVHlwZSkge1xuICAgICAgICBjYXNlIFwiUmF3XCI6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG0uVHlwZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRpcmVjdG9yeVwiOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtLlR5cGUgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGaWxlXCI6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIG0uVHlwZSA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1ldGFkYXRhXCI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIG0uVHlwZSA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlN5bWxpbmtcIjpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgbS5UeXBlID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSEFNVFNoYXJkXCI6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIG0uVHlwZSA9IDU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZC5EYXRhID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUoZC5EYXRhLCBtLkRhdGEgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChkLkRhdGEpKSwgMCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkLkRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG0uRGF0YSA9IGQuRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5maWxlc2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAobS5maWxlc2l6ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKGQuZmlsZXNpemUpKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZC5maWxlc2l6ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtLmZpbGVzaXplID0gcGFyc2VJbnQoZC5maWxlc2l6ZSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmlsZXNpemUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbS5maWxlc2l6ZSA9IGQuZmlsZXNpemU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZC5maWxlc2l6ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICBtLmZpbGVzaXplID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuZmlsZXNpemUubG93ID4+PiAwLCBkLmZpbGVzaXplLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLmJsb2Nrc2l6ZXMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkLmJsb2Nrc2l6ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5EYXRhLmJsb2Nrc2l6ZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbS5ibG9ja3NpemVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQuYmxvY2tzaXplcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobS5ibG9ja3NpemVzW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5ibG9ja3NpemVzW2ldKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmJsb2Nrc2l6ZXNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG0uYmxvY2tzaXplc1tpXSA9IHBhcnNlSW50KGQuYmxvY2tzaXplc1tpXSwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmJsb2Nrc2l6ZXNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG0uYmxvY2tzaXplc1tpXSA9IGQuYmxvY2tzaXplc1tpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZC5ibG9ja3NpemVzW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtLmJsb2Nrc2l6ZXNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5ibG9ja3NpemVzW2ldLmxvdyA+Pj4gMCwgZC5ibG9ja3NpemVzW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkLmhhc2hUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgIChtLmhhc2hUeXBlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5oYXNoVHlwZSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG0uaGFzaFR5cGUgPSBwYXJzZUludChkLmhhc2hUeXBlLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZC5oYXNoVHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtLmhhc2hUeXBlID0gZC5oYXNoVHlwZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIG0uaGFzaFR5cGUgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5oYXNoVHlwZS5sb3cgPj4+IDAsIGQuaGFzaFR5cGUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZmFub3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgIChtLmZhbm91dCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKGQuZmFub3V0KSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmFub3V0ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG0uZmFub3V0ID0gcGFyc2VJbnQoZC5mYW5vdXQsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmZhbm91dCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtLmZhbm91dCA9IGQuZmFub3V0O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmFub3V0ID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIG0uZmFub3V0ID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuZmFub3V0LmxvdyA+Pj4gMCwgZC5mYW5vdXQuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQubW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtLm1vZGUgPSBkLm1vZGUgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQubXRpbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLm10aW1lICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5EYXRhLm10aW1lOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtLm10aW1lID0gJHJvb3QuVW5peFRpbWUuZnJvbU9iamVjdChkLm10aW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRGF0YSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIERhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtEYXRhfSBtIERhdGFcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIERhdGEudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtLCBvKSB7XG4gICAgICAgIGlmICghbylcbiAgICAgICAgICAgIG8gPSB7fTtcbiAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgaWYgKG8uYXJyYXlzIHx8IG8uZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGQuYmxvY2tzaXplcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBkLlR5cGUgPSBvLmVudW1zID09PSBTdHJpbmcgPyBcIlJhd1wiIDogMDtcbiAgICAgICAgICAgIGlmIChvLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgZC5EYXRhID0gXCJcIjtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGQuRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChvLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgZC5EYXRhID0gJHV0aWwubmV3QnVmZmVyKGQuRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZC5maWxlc2l6ZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IG4udG9TdHJpbmcoKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG4udG9OdW1iZXIoKSA6IG47XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBkLmZpbGVzaXplID0gby5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgJHV0aWwuTG9uZygwLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkLmZhbm91dCA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IG4udG9TdHJpbmcoKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG4udG9OdW1iZXIoKSA6IG47XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBkLmZhbm91dCA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIGQubW9kZSA9IDA7XG4gICAgICAgICAgICBkLm10aW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobS5UeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eShcIlR5cGVcIikpIHtcbiAgICAgICAgICAgIGQuVHlwZSA9IG8uZW51bXMgPT09IFN0cmluZyA/ICRyb290LkRhdGEuRGF0YVR5cGVbbS5UeXBlXSA6IG0uVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobS5EYXRhICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eShcIkRhdGFcIikpIHtcbiAgICAgICAgICAgIGQuRGF0YSA9IG8uYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobS5EYXRhLCAwLCBtLkRhdGEubGVuZ3RoKSA6IG8uYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobS5EYXRhKSA6IG0uRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobS5maWxlc2l6ZSAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoXCJmaWxlc2l6ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtLmZpbGVzaXplID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIGQuZmlsZXNpemUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobS5maWxlc2l6ZSkgOiBtLmZpbGVzaXplO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGQuZmlsZXNpemUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uZmlsZXNpemUpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uZmlsZXNpemUubG93ID4+PiAwLCBtLmZpbGVzaXplLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5maWxlc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobS5ibG9ja3NpemVzICYmIG0uYmxvY2tzaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQuYmxvY2tzaXplcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtLmJsb2Nrc2l6ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG0uYmxvY2tzaXplc1tqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgZC5ibG9ja3NpemVzW2pdID0gby5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG0uYmxvY2tzaXplc1tqXSkgOiBtLmJsb2Nrc2l6ZXNbal07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkLmJsb2Nrc2l6ZXNbal0gPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uYmxvY2tzaXplc1tqXSkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5ibG9ja3NpemVzW2pdLmxvdyA+Pj4gMCwgbS5ibG9ja3NpemVzW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5ibG9ja3NpemVzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtLmhhc2hUeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eShcImhhc2hUeXBlXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG0uaGFzaFR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmhhc2hUeXBlKSA6IG0uaGFzaFR5cGU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5oYXNoVHlwZSkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5oYXNoVHlwZS5sb3cgPj4+IDAsIG0uaGFzaFR5cGUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtLmhhc2hUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtLmZhbm91dCAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoXCJmYW5vdXRcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbS5mYW5vdXQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobS5mYW5vdXQpIDogbS5mYW5vdXQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uZmFub3V0KSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtLmZhbm91dC5sb3cgPj4+IDAsIG0uZmFub3V0LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5mYW5vdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0ubW9kZSAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoXCJtb2RlXCIpKSB7XG4gICAgICAgICAgICBkLm1vZGUgPSBtLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0ubXRpbWUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KFwibXRpbWVcIikpIHtcbiAgICAgICAgICAgIGQubXRpbWUgPSAkcm9vdC5Vbml4VGltZS50b09iamVjdChtLm10aW1lLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBEYXRhIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBEYXRhXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIERhdGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGFUeXBlIGVudW0uXG4gICAgICogQG5hbWUgRGF0YS5EYXRhVHlwZVxuICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJhdz0wIFJhdyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEaXJlY3Rvcnk9MSBEaXJlY3RvcnkgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRmlsZT0yIEZpbGUgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTWV0YWRhdGE9MyBNZXRhZGF0YSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTeW1saW5rPTQgU3ltbGluayB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBIQU1UU2hhcmQ9NSBIQU1UU2hhcmQgdmFsdWVcbiAgICAgKi9cbiAgICBEYXRhLkRhdGFUeXBlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJSYXdcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiRGlyZWN0b3J5XCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIkZpbGVcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiTWV0YWRhdGFcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiU3ltbGlua1wiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJIQU1UU2hhcmRcIl0gPSA1O1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gRGF0YTtcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBVbml4VGltZSA9ICRyb290LlVuaXhUaW1lID0gKCgpID0+IHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYW4gVW5peFRpbWUuXG4gICAgICogQGV4cG9ydHMgSVVuaXhUaW1lXG4gICAgICogQGludGVyZmFjZSBJVW5peFRpbWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU2Vjb25kcyBVbml4VGltZSBTZWNvbmRzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0ZyYWN0aW9uYWxOYW5vc2Vjb25kc10gVW5peFRpbWUgRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFVuaXhUaW1lLlxuICAgICAqIEBleHBvcnRzIFVuaXhUaW1lXG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIFVuaXhUaW1lLlxuICAgICAqIEBpbXBsZW1lbnRzIElVbml4VGltZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SVVuaXhUaW1lPX0gW3BdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gVW5peFRpbWUocCkge1xuICAgICAgICBpZiAocClcbiAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5peFRpbWUgU2Vjb25kcy5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFNlY29uZHNcbiAgICAgKiBAbWVtYmVyb2YgVW5peFRpbWVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBVbml4VGltZS5wcm90b3R5cGUuU2Vjb25kcyA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogVW5peFRpbWUgRnJhY3Rpb25hbE5hbm9zZWNvbmRzLlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgICogQG1lbWJlcm9mIFVuaXhUaW1lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVW5peFRpbWUucHJvdG90eXBlLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVW5peFRpbWUgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgVW5peFRpbWUudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBVbml4VGltZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0lVbml4VGltZX0gbSBVbml4VGltZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3XSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFVuaXhUaW1lLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtLCB3KSB7XG4gICAgICAgIGlmICghdylcbiAgICAgICAgICAgIHcgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICB3LnVpbnQzMig4KS5pbnQ2NChtLlNlY29uZHMpO1xuICAgICAgICBpZiAobS5GcmFjdGlvbmFsTmFub3NlY29uZHMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCBcIkZyYWN0aW9uYWxOYW5vc2Vjb25kc1wiKSlcbiAgICAgICAgICAgIHcudWludDMyKDIxKS5maXhlZDMyKG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzKTtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYW4gVW5peFRpbWUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIFVuaXhUaW1lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7VW5peFRpbWV9IFVuaXhUaW1lXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBVbml4VGltZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QuVW5peFRpbWUoKTtcbiAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbS5TZWNvbmRzID0gci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzID0gci5maXhlZDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbS5oYXNPd25Qcm9wZXJ0eShcIlNlY29uZHNcIikpXG4gICAgICAgICAgICB0aHJvdyAkdXRpbC5Qcm90b2NvbEVycm9yKFwibWlzc2luZyByZXF1aXJlZCAnU2Vjb25kcydcIiwgeyBpbnN0YW5jZTogbSB9KTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gVW5peFRpbWUgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIFVuaXhUaW1lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGQgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge1VuaXhUaW1lfSBVbml4VGltZVxuICAgICAqL1xuICAgIFVuaXhUaW1lLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGQpIHtcbiAgICAgICAgaWYgKGQgaW5zdGFuY2VvZiAkcm9vdC5Vbml4VGltZSlcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB2YXIgbSA9IG5ldyAkcm9vdC5Vbml4VGltZSgpO1xuICAgICAgICBpZiAoZC5TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgIChtLlNlY29uZHMgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShkLlNlY29uZHMpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuU2Vjb25kcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtLlNlY29uZHMgPSBwYXJzZUludChkLlNlY29uZHMsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLlNlY29uZHMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbS5TZWNvbmRzID0gZC5TZWNvbmRzO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuU2Vjb25kcyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICBtLlNlY29uZHMgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5TZWNvbmRzLmxvdyA+Pj4gMCwgZC5TZWNvbmRzLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuRnJhY3Rpb25hbE5hbm9zZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzID0gZC5GcmFjdGlvbmFsTmFub3NlY29uZHMgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBVbml4VGltZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIFVuaXhUaW1lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7VW5peFRpbWV9IG0gVW5peFRpbWVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFVuaXhUaW1lLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgICAgICBpZiAoIW8pXG4gICAgICAgICAgICBvID0ge307XG4gICAgICAgIHZhciBkID0ge307XG4gICAgICAgIGlmIChvLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGQuU2Vjb25kcyA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IG4udG9TdHJpbmcoKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG4udG9OdW1iZXIoKSA6IG47XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0uU2Vjb25kcyAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoXCJTZWNvbmRzXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG0uU2Vjb25kcyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobS5TZWNvbmRzKSA6IG0uU2Vjb25kcztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uU2Vjb25kcykgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5TZWNvbmRzLmxvdyA+Pj4gMCwgbS5TZWNvbmRzLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtLlNlY29uZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eShcIkZyYWN0aW9uYWxOYW5vc2Vjb25kc1wiKSkge1xuICAgICAgICAgICAgZC5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSBtLkZyYWN0aW9uYWxOYW5vc2Vjb25kcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBVbml4VGltZSB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2YgVW5peFRpbWVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVW5peFRpbWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBVbml4VGltZTtcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBNZXRhZGF0YSA9ICRyb290Lk1ldGFkYXRhID0gKCgpID0+IHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBNZXRhZGF0YS5cbiAgICAgKiBAZXhwb3J0cyBJTWV0YWRhdGFcbiAgICAgKiBAaW50ZXJmYWNlIElNZXRhZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtNaW1lVHlwZV0gTWV0YWRhdGEgTWltZVR5cGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWV0YWRhdGEuXG4gICAgICogQGV4cG9ydHMgTWV0YWRhdGFcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBNZXRhZGF0YS5cbiAgICAgKiBAaW1wbGVtZW50cyBJTWV0YWRhdGFcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0lNZXRhZGF0YT19IFtwXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1ldGFkYXRhKHApIHtcbiAgICAgICAgaWYgKHApXG4gICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIE1pbWVUeXBlLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gTWltZVR5cGVcbiAgICAgKiBAbWVtYmVyb2YgTWV0YWRhdGFcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNZXRhZGF0YS5wcm90b3R5cGUuTWltZVR5cGUgPSBcIlwiO1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE1ldGFkYXRhIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIE1ldGFkYXRhLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2YgTWV0YWRhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtJTWV0YWRhdGF9IG0gTWV0YWRhdGEgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd10gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBNZXRhZGF0YS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobSwgdykge1xuICAgICAgICBpZiAoIXcpXG4gICAgICAgICAgICB3ID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgaWYgKG0uTWltZVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCBcIk1pbWVUeXBlXCIpKVxuICAgICAgICAgICAgdy51aW50MzIoMTApLnN0cmluZyhtLk1pbWVUeXBlKTtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBNZXRhZGF0YSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2YgTWV0YWRhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtNZXRhZGF0YX0gTWV0YWRhdGFcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIE1ldGFkYXRhLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC5NZXRhZGF0YSgpO1xuICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtLk1pbWVUeXBlID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBNZXRhZGF0YSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgTWV0YWRhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGF9IE1ldGFkYXRhXG4gICAgICovXG4gICAgTWV0YWRhdGEuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoZCkge1xuICAgICAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290Lk1ldGFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIHZhciBtID0gbmV3ICRyb290Lk1ldGFkYXRhKCk7XG4gICAgICAgIGlmIChkLk1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG0uTWltZVR5cGUgPSBTdHJpbmcoZC5NaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIE1ldGFkYXRhIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgTWV0YWRhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtNZXRhZGF0YX0gbSBNZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29dIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgTWV0YWRhdGEudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtLCBvKSB7XG4gICAgICAgIGlmICghbylcbiAgICAgICAgICAgIG8gPSB7fTtcbiAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgaWYgKG8uZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGQuTWltZVR5cGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtLk1pbWVUeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eShcIk1pbWVUeXBlXCIpKSB7XG4gICAgICAgICAgICBkLk1pbWVUeXBlID0gbS5NaW1lVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBNZXRhZGF0YSB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2YgTWV0YWRhdGFcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgTWV0YWRhdGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBNZXRhZGF0YTtcbn0pKCk7XG5cbmV4cG9ydCB7ICRyb290IGFzIGRlZmF1bHQgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=